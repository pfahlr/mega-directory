OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a782e-f512-7213-87af-475c161cd732
--------
user
Implement the functionality described in codex/TASKS/30_set_up_geocoding_integration_with_fallback_support.yaml, then verify with any available tests.
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX

thinking
**Preparing to inspect repo structure**
exec
bash -lc ls in /var/home/rick/Development/mega-directory succeeded in 46ms:
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
env.json
Makefile
package.json
packages
README.md
scripts
tests
tsconfig.json

thinking
**Opening integration setup instructions**
exec
bash -lc "sed -n '1,160p' codex/TASKS/30_set_up_geocoding_integration_with_fallback_support.yaml" in /var/home/rick/Development/mega-directory succeeded in 46ms:
id: 30
filename: 30_set_up_geocoding_integration_with_fallback_support.yaml
title: Set Up Geocoding Integration with Fallback Support
description: >
- Implement geolocation logic using geocode.maps.co with fallback to Google Maps Geocode API.
- Automatically trigger geolocation on listing/address creation or update.
- Populate lat/lon fields and handle API failure scenarios.
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
dependencies: []

thinking
**Preparing to implement geocoding integration**
exec
bash -lc 'rg -n "geocode" -n' in /var/home/rick/Development/mega-directory succeeded in 52ms:
docs/development_phase_1b.md:36:Not all listings will be tied to a specific location... buisinessess and organizations that operate purely over the internet may not list an address, and it may just not make any sense for us to use one in our data presentation to begin with. If an address is available, we should probably store it, but for certain categories, we can probably treat all of the listings as location agnostic. But let's leave that to be determined by the directory configuration. Each listing should have a latitude and longitude value, this should be obtainable from the google maps api or some other such service. A quick google search turns up: MapQuest API, Geocodio, geocode.maps.co, locationIQ. 
docs/development_phase_1b.md:102:### Preferred fallback or order of geocoding services (e.g., geocode.maps.co -> MapQuest -> Google)?
docs/development_phase_1b.md:104:- Let's primarily use geocode.maps.co and fallback on Google Maps Geocode API, omit mapquest since they require a payment method. 
codex/LOGS/tasklog_30_set_up_geocoding_integration_with_fallback_support_1762952934.log:54:- Implement geolocation logic using geocode.maps.co with fallback to Google Maps Geocode API.
codex/LOGS/tasklog_30_set_up_geocoding_integration_with_fallback_support_1762952934.log:63:bash -lc 'rg -n "geocode" -n' in /var/home/rick/Development/mega-directory
codex/TASKS/30_set_up_geocoding_integration_with_fallback_support.yaml:5:- Implement geolocation logic using geocode.maps.co with fallback to Google Maps Geocode API.
codex/TASKS/codex_phase_1b_2.yaml:88:        source: geocode.maps.co → fallback: Google Maps Geocode API

thinking
**Preparing to inspect code structure**
exec
bash -lc 'ls apps' in /var/home/rick/Development/mega-directory succeeded in 46ms:
admin
api
crawler
web

thinking
**Inspecting API directory for geocoding**
exec
bash -lc 'ls apps/api' in /var/home/rick/Development/mega-directory succeeded in 42ms:
dist
Dockerfile
node_modules
package.json
package-lock.json
src
test
tsconfig.json
types

thinking
**Exploring API source structure**
exec
bash -lc 'ls apps/api/src' in /var/home/rick/Development/mega-directory succeeded in 40ms:
logger.ts
server.ts

thinking
**Checking project files and server entry**
exec
bash -lc "sed -n '1,200p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 42ms:
import express, { type Express, type Request, type RequestHandler } from 'express';
import jwt, { type JwtPayload } from 'jsonwebtoken';
import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
import { createLogger, createRequestLogger, type Logger } from './logger';

const DEFAULT_PORT = DEFAULT_PORTS.api;
const DEFAULT_LISTING_STATUS: ListingStatus = 'INACTIVE';
const MAX_SLUG_LENGTH = 80;
const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;

type ListingStatus = 'INACTIVE' | 'ACTIVE';

type NullableString = string | null;

type ListingLocation =
  | {
      addressLine1?: string;
      addressLine2?: string;
      city?: string;
      region?: string;

thinking
**Continuing to review file**
exec
bash -lc "sed -n '200,520p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 42ms:
  return app;
}

export function startServer() {
  const app = createServer();
  const { port } = getAppLocals(app).config;
  app.listen(port, () => {
    getAppLocals(app).logger.info(
      { event: 'api.start', port, environment: process.env.NODE_ENV || 'development' },
      `API server running at http://localhost:${port}`
    );
  });
}

if (require.main === module) {
  startServer();
}

function extractBearerToken(req: Request) {
  const headerSource =

thinking
**Reviewing file end for context**
exec
bash -lc "sed -n '520,1040p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 42ms:
  try {
    const parsed = new URL(value.trim());
    return parsed.toString();
  } catch (_err) {
    errors.push(`${fieldName} must be a valid URL string`);
    return null;
  }
}

function optionalEmail(value: unknown, fieldName: string, errors: string[]): NullableString {
  if (value === undefined || value === null) {
    return null;
  }
  if (typeof value !== 'string' || !value.trim()) {
    errors.push(`${fieldName} must be a valid email address`);
    return null;
  }
  const email = value.trim();
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {

thinking
**Checking test setup for API**
exec
bash -lc 'ls apps/api/test' in /var/home/rick/Development/mega-directory succeeded in 40ms:
server.test.js

thinking
**Opening test file to understand environment**
exec
bash -lc "sed -n '1,200p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 42ms:
const test = require('node:test');
const assert = require('node:assert');
const jwt = require('jsonwebtoken');
const { createServer } = require('..');

const baseConfig = Object.freeze({
  adminJwtSecret: 'test-admin-secret',
  adminJwtIssuer: 'mega-directory',
  adminJwtAudience: 'admin',
  adminLoginEmail: 'admin@example.com',
  adminLoginPasscode: 'letmein',
  crawlerBearerToken: 'crawler-token'
});

function findRoute(app, method, path) {
  const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
  const methodName = method.toLowerCase();
  return stack.find(
    (layer) => layer.route && layer.route.path === path && layer.route.methods[methodName]
  );

thinking
**Requesting more test code**
exec
bash -lc "sed -n '200,400p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 43ms:
  assert.strictEqual(loginRes.body.expiresIn, 900);

  const decoded = jwt.verify(loginRes.body.token, baseConfig.adminJwtSecret, {
    issuer: baseConfig.adminJwtIssuer,
    audience: baseConfig.adminJwtAudience
  });
  assert.strictEqual(decoded.role, 'admin');
  assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());

  const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
  const pingRes = runRoute(
    pingRoute,
    createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
    createResponse()
  );

  assert.strictEqual(pingRes.statusCode, 200);
  assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
});


thinking
**Planning geocoding implementation**
exec
bash -lc "sed -n '1,200p' codex/TASKS/codex_phase_1b_2.yaml" in /var/home/rick/Development/mega-directory succeeded in 41ms:
project: mega-directory
version: 1.0
phases:
  - phase: 1
    description: Core system buildout — listings pipeline, directory structure, admin tools, crawler, API, and frontend delivery

    components:
      api_server:
        language: TypeScript
        framework: Node/Express
        deployment: Railway
        endpoints:
          - listings: [GET, POST, PUT, DELETE]
          - addresses: [GET, POST, PUT, DELETE]
          - categories: [GET, POST, PUT, DELETE]
          - directory_pages: [GET, POST, PUT, DELETE]
          - directory_metadata: [GET, PUT]
        notes:
          - Postal, city, state/province, and country tables are loaded from external datasets.
          - Listings reference postal_code_id or city_id depending on geography.

thinking
**Planning geolocation integration**
exec
bash -lc 'rg -n "longitude" -n' in /var/home/rick/Development/mega-directory succeeded in 47ms:
tests/listings_table_enhancements.test.js:91:  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
db/schema.prisma:69:  longitude      Float?
db/schema.prisma:92:  longitude   Float?
db/schema.prisma:114:  longitude   Float?
db/schema.prisma:150:  longitude   Float?
db/schema.prisma:192:  longitude       Float?
db/schema.prisma:350:  longitude     Float?
db/scripts/seedGeography.ts:25:  longitude?: string | number | null;
db/scripts/seedGeography.ts:40:  longitude?: string | number | null;
db/scripts/seedGeography.ts:54:  longitude?: string | number | null;
db/scripts/seedGeography.ts:70:  longitude?: string | null;
db/scripts/seedGeography.ts:203:    longitude: toFloat(country.longitude),
db/scripts/seedGeography.ts:242:      longitude: toFloat(state.longitude),
db/scripts/seedGeography.ts:276:      longitude: toFloat(city.longitude),
db/scripts/seedGeography.ts:341:      longitude: toFloat(row.longitude),
db/scripts/seedGeography.ts:449:    longitude: parts[10] || null,
docs/development_phase_1b.md:36:Not all listings will be tied to a specific location... buisinessess and organizations that operate purely over the internet may not list an address, and it may just not make any sense for us to use one in our data presentation to begin with. If an address is available, we should probably store it, but for certain categories, we can probably treat all of the listings as location agnostic. But let's leave that to be determined by the directory configuration. Each listing should have a latitude and longitude value, this should be obtainable from the google maps api or some other such service. A quick google search turns up: MapQuest API, Geocodio, geocode.maps.co, locationIQ. 
db/geography/sample/cities.json:13:    "longitude": "-74.00597280",
db/geography/sample/cities.json:27:    "longitude": "-122.41941550",
db/geography/sample/cities.json:41:    "longitude": "-79.34701500",

thinking
**Evaluating implementation scope**
exec
bash -lc 'ls packages' in /var/home/rick/Development/mega-directory succeeded in 42ms:
shared-config

thinking
**Exploring shared-config package**
exec
bash -lc 'ls packages/shared-config' in /var/home/rick/Development/mega-directory succeeded in 47ms:
index.d.ts
index.js
package.json
README.md

thinking
**Planning geolocation implementation with TDD**

I'm interpreting the requirement to implement geolocation using geocode.maps.co with Google Maps as fallback, triggered automatically on listing creation or update, populating lat/lon fields, and handling failures. Since network access is restricted and no approvals are allowed, I'll aim to implement the geocode service module with fetch calls but stub or mock network requests in tests. I also need to check package dependencies and environment constraints before proceeding.
exec
bash -lc 'cat apps/api/package.json' in /var/home/rick/Development/mega-directory succeeded in 41ms:
{
  "name": "mega-directory-api",
  "private": true,
  "version": "0.1.0",
  "type": "commonjs",
  "main": "dist/server.js",
  "types": "dist/server.d.ts",
  "scripts": {
    "dev": "npm run build && node dist/server.js",
    "dev:watch": "tsc -p tsconfig.json --watch",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "test": "npm run build && node --test test/**/*.test.js"
  },
  "dependencies": {
    "@mega-directory/config": "file:../../packages/shared-config",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {

thinking
**Preparing for testing and code inspection**
exec
bash -lc "sed -n '1,200p' apps/api/src/logger.ts" in /var/home/rick/Development/mega-directory succeeded in 42ms:
import os from 'os';
import type { NextFunction, Request, Response } from 'express';

const LEVEL_INDEX = {
  fatal: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4,
  trace: 5
} as const;

type LogLevel = keyof typeof LEVEL_INDEX;

type LogPayload = Record<string, unknown>;

type LogMethod = (arg1?: string | LogPayload, arg2?: string | LogPayload) => void;

export interface Logger {
  level: LogLevel;

thinking
**Planning geocoding service implementation**

I'm figuring out how to add latitude and longitude fields to the listing location data structure and when to call the geocoding service during listing ingestion. I realize the ingestion handler will need to become asynchronous to support the HTTP geocode call, so I plan to inspect the handler’s full code to understand how best to integrate this.
exec
bash -lc "sed -n '240,520p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 42ms:
    if (!token) {
      return res.status(401).json({ error: 'Admin token missing or invalid' });
    }

    try {
      const payload = jwt.verify(token, config.adminJwtSecret, {
        issuer: config.adminJwtIssuer,
        audience: config.adminJwtAudience
      });
      req.admin = payload;
      return next();
    } catch (_err) {
      return res.status(401).json({ error: 'Admin token missing or invalid' });
    }
  };
}

function requireCrawlerToken(config: ServerConfig): RequestHandler {
  return (req, res, next) => {
    const token = extractBearerToken(req);

thinking
**Continuing to review ingestion function**
exec
bash -lc "sed -n '350,460p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 40ms:

    if (invalidEntries.length > 0) {
      logger.warn(
        {
          event: 'listings.ingest.invalid',
          reason: 'validation-failed',
          failures: invalidEntries.length
        },
        'Rejected crawler listings batch due to validation errors'
      );
      return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
    }

    const store = getAppLocals(app).ingestionStore;
    const savedRecords = validEntries.map(({ index, value }) =>
      store.insert(value, payloads[index])
    );
    const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
    logger.info(
      {

thinking
**Planning geocoding integration and testing**

I'm mapping out how to add geocoding with fallback to Google, considering config extensions for API keys and handling environment secrets. I’ll review existing tests to guide a test-driven design and figure out how to mock network calls since real requests aren’t possible in tests.
exec
bash -lc 'cat apps/api/tsconfig.json' in /var/home/rick/Development/mega-directory succeeded in 42ms:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "tsBuildInfoFile": "dist/.tsbuildinfo",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "typeRoots": [
      "./types",
      "node_modules/@types",
      "../web/node_modules/@types"
    ]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["dist", "node_modules", "test"]
}

thinking
**Checking tsconfig for fetch support**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/mega-directory succeeded in 41ms:
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true
  }
}

thinking
**Evaluating HTTP request options and geocoding approach**

I’m exploring using Node 18's built-in fetch API for HTTP calls without extra dependencies, checking if TypeScript supports its types by default. Next, I’ll implement geolocation logic with a primary geocode.maps.co API and a Google Maps fallback, designing data structures and error handling to populate lat/lon fields for ListingLocation. Before proceeding, I want to review existing logs for relevant instructions or prior attempts.
exec
bash -lc "sed -n '1,200p' codex/LOGS/tasklog_30_set_up_geocoding_integration_with_fallback_support_1762952934.log" in /var/home/rick/Development/mega-directory succeeded in 46ms:
OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a782e-f512-7213-87af-475c161cd732
--------
user
Implement the functionality described in codex/TASKS/30_set_up_geocoding_integration_with_fallback_support.yaml, then verify with any available tests.
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:

thinking
**Outlining TDD plan for geocoding**

I’m mapping out a multi-step plan to test and implement automatic geocoding on listing ingestion, including config keys, graceful failure handling, and updating location data with lat/lon. I’ll start by extending tests to handle async routes and mock fetch, then build the geocoding service, and finally run tests and refine. This way, I ensure robust, test-driven progress.
Plan update
  → Add tests covering geocoding behavior and async handling for crawler ingestion.
  • Implement geocoding integration with fallback support and config plumbing.
  • Run API test suite and adjust as needed.


thinking
**Planning test updates and geocoding integration**

I'm mapping out how to adapt tests for async route handling and to mock global fetch for geocoding API calls, ensuring coverage of fallback and error scenarios. I’m also designing new geocode helpers, considering where to place types to avoid circular imports, and thinking through how to store lat/lon in listings while carefully updating configs and interfaces.
thinking
**Designing type sharing and test refactoring for geocoding**

I'm planning to move address-related types into the geocoding module to avoid circular imports, enabling clear type reuse between server and geocoding code. I’m also outlining extensive test refactoring: making route handling async, adding fetch mocks with proper restoration, and converting existing tests to async functions while adding new geocoding-specific tests.
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -14,2 +14,36 @@
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
apply_patch(auto_approved=true) exited 0 in 54ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..32b9b70bcc14d94c6ba68a246555aa1d7576f3ad
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..32b9b70bcc14d94c6ba68a246555aa1d7576f3ad
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();


thinking
**Ensuring nativeFetch defined and updating runRoute**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -107,3 +107,3 @@
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
@@ -117,3 +117,6 @@
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..426f7367c49193c20db0204e044b8af68a5b519d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..426f7367c49193c20db0204e044b8af68a5b519d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }


thinking
**Preparing tests for async updates**
exec
bash -lc "sed -n '1,260p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 44ms:
const test = require('node:test');
const assert = require('node:assert');
const jwt = require('jsonwebtoken');
const { createServer } = require('..');

const baseConfig = Object.freeze({
  adminJwtSecret: 'test-admin-secret',
  adminJwtIssuer: 'mega-directory',
  adminJwtAudience: 'admin',
  adminLoginEmail: 'admin@example.com',
  adminLoginPasscode: 'letmein',
  crawlerBearerToken: 'crawler-token'
});

const nativeFetch = global.fetch;

function createFetchMock(responses = []) {
  const queue = responses.slice();
  const calls = [];

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..426f7367c49193c20db0204e044b8af68a5b519d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }


thinking
**Planning test updates to async**
exec
bash -lc "sed -n '260,520p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 43ms:
  const res = runRoute(
    route,
    createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
    createResponse()
  );

  assert.strictEqual(res.statusCode, 401);
  assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
});

test('crawler ping accepts matching bearer token', () => {
  const app = createServer(baseConfig);
  const route = findRoute(app, 'post', '/v1/crawler/ping');
  const req = createRequest({
    method: 'POST',
    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
  });
  const res = runRoute(route, req, createResponse());

  assert.strictEqual(res.statusCode, 200);
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..426f7367c49193c20db0204e044b8af68a5b519d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }


thinking
**Planning async test conversion**

I’m preparing to convert existing synchronous tests to async by patching the file globally, focusing on updating all `test('…', () => {` calls to async versions. I’m thinking about using a Python script with regex to automate adding `async` to test callbacks and `await` to `runRoute` calls, while manually handling edge cases like non-assigned calls and avoiding false replacements inside function definitions. Let’s proceed carefully to ensure correctness!
exec
bash -lc "python - <<'PY'
from pathlib import Path
path = Path('apps/api/test/server.test.js')
text = path.read_text()
import re
text = re.sub(r\"(test\\('["'^'"']+', )\\(\\) => {\", r\"\\\\1async () => {\", text)
text = text.replace(\" = runRoute(\", \" = await runRoute(\")
text = text.replace(\"\\n  runRoute(route, req, createResponse());\", \"\\n  await runRoute(route, req, createResponse());\")
path.write_text(text)
PY
" in /var/home/rick/Development/mega-directory succeeded in 203ms:

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..ed363c1a686a1cb4665ef6a90c8c24c7991f21dd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+\1async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying async function modifications**
exec
bash -lc "sed -n '120,420p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 43ms:
      await result;
    }
    if (!nextCalled || res.finished) {
      break;
    }
  }

  return res;
}

function createStubLogger() {
  const calls = [];
  const logger = {
    calls,
    info(...args) {
      calls.push({ level: 'info', args });
    },
    warn(...args) {
      calls.push({ level: 'warn', args });
    },
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..ed363c1a686a1cb4665ef6a90c8c24c7991f21dd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+\1async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Analyzing regex replacement issue**
exec
bash -lc 'git show HEAD:apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory exited 128 in 45ms:
fatal: path 'apps/api/test/server.test.js' exists on disk, but not in 'HEAD'
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..ed363c1a686a1cb4665ef6a90c8c24c7991f21dd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+\1async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying Git repository status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/mega-directory succeeded in 50ms:
## main...origin/main [ahead 6]
 M .env.example
?? .editorconfig
?? .vscode/
?? apps/
?? codex/LOGS/codex_run_2025-11-12_06-13-21.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log.done
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log.done
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log.done
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log.done
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log.done
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log.done
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log.done
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..ed363c1a686a1cb4665ef6a90c8c24c7991f21dd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+\1async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Planning manual test file reconstruction**

I see that the repo is untracked, so I can't revert the test file via git commands. Instead, I’m figuring out how to rebuild the entire test file by merging two earlier saved `sed` outputs that together cover the full file before recent script changes. Since the file now has swapped out `test(...)` lines for `\1async () => {`, I’m considering manually searching and replacing these markers with the original `test('description', async () => {` lines using known descriptions. It seems doable with about a dozen tests to fix up.
exec
bash -lc "rg -n \"\\\\1async\" apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory exited 2 in 51ms:
rg: regex parse error:
    (?:\1async)
       ^^
error: backreferences are not supported

Consider enabling PCRE2 with the --pcre2 flag, which can handle backreferences
and look-around.
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..ed363c1a686a1cb4665ef6a90c8c24c7991f21dd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+\1async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Testing ripgrep for literal string search**
exec
bash -lc "rg -n --fixed-strings \"\\1async\" apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 43ms:
150:\1async () => {
162:\1async () => {
171:\1async () => {
190:\1async () => {
206:\1async () => {
222:\1async () => {
257:\1async () => {
270:\1async () => {
283:\1async () => {
296:\1async () => {
324:\1async () => {
353:\1async () => {
373:\1async () => {
399:\1async () => {
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..ed363c1a686a1cb4665ef6a90c8c24c7991f21dd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+\1async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Mapping test placeholders to descriptions**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -149,3 +149,3 @@
 
-\1async () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..1beddb7cc6687aabc05f5f1558225e454a17397f
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..1beddb7cc6687aabc05f5f1558225e454a17397f
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Updating test case line**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -161,3 +161,3 @@
 
-\1async () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..0f26c6f3a707f96e5bb07d420331b3b32265c2ad
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..0f26c6f3a707f96e5bb07d420331b3b32265c2ad
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying patch application accuracy**
exec
bash -lc "sed -n '140,220p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 45ms:
    error(...args) {
      calls.push({ level: 'error', args });
    },
    child() {
      return logger;
    }
  };
  return logger;
}

test('health endpoint reports monitoring metadata', async () => {
  const app = createServer({ ...baseConfig, logger: createStubLogger() });
  const route = findRoute(app, 'get', '/health');
  const res = await runRoute(route, createRequest(), createResponse());

  assert.strictEqual(res.statusCode, 200);
  assert.strictEqual(res.body.status, 'ok');
  assert.ok(typeof res.body.uptime === 'number');
  assert.ok(res.body.timestamp);
  assert.ok(res.body.startedAt);
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..0f26c6f3a707f96e5bb07d420331b3b32265c2ad
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Replacing third test occurrence**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -170,3 +170,3 @@
 
-\1async () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..8cda11486d2dff7f9df00803b60aac3d968b7220
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..8cda11486d2dff7f9df00803b60aac3d968b7220
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Checking admin auth route behavior**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -189,3 +189,3 @@
 
-\1async () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..9a4ac5110e24352b44fe27a2b980a72a4c14598b
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..9a4ac5110e24352b44fe27a2b980a72a4c14598b
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Listing test case name**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -205,3 +205,3 @@
 
-\1async () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..abae69c7d9f7edec5c8f8445035c8b19546bd24e
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..abae69c7d9f7edec5c8f8445035c8b19546bd24e
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Listing feature descriptions**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -221,3 +221,3 @@
 
-\1async () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..e111a8d03944e17719af5d8710d3bd42dccfb291
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..e111a8d03944e17719af5d8710d3bd42dccfb291
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Checking later file portion**
exec
bash -lc "sed -n '220,340p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 49ms:
});

test('admin auth issues JWTs that unlock protected routes', async () => {
  const app = createServer(baseConfig);
  const authRoute = findRoute(app, 'post', '/v1/admin/auth');
  const loginRes = await runRoute(
    authRoute,
    createRequest({
      method: 'POST',
      body: { email: baseConfig.adminLoginEmail, passcode: baseConfig.adminLoginPasscode }
    }),
    createResponse()
  );

  assert.strictEqual(loginRes.statusCode, 200);
  assert.strictEqual(typeof loginRes.body.token, 'string');
  assert.strictEqual(loginRes.body.tokenType, 'Bearer');
  assert.strictEqual(loginRes.body.expiresIn, 900);

  const decoded = jwt.verify(loginRes.body.token, baseConfig.adminJwtSecret, {
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..e111a8d03944e17719af5d8710d3bd42dccfb291
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Continuing sequential replacements**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -256,3 +256,3 @@
 
-\1async () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..6a1a621b18080e28945deabe774790ec7e19ff06
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..6a1a621b18080e28945deabe774790ec7e19ff06
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -269,3 +269,3 @@
 
-\1async () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..7b6a51dd4e3034b60e23dea69616dcbc44d8dd39
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..7b6a51dd4e3034b60e23dea69616dcbc44d8dd39
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -282,3 +282,3 @@
 
-\1async () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..fd45c2bf31cd0e379a44b9294cb7c976e20efccd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..fd45c2bf31cd0e379a44b9294cb7c976e20efccd
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -295,3 +295,3 @@
 
-\1async () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..67ad16750752eb443ed6b693a0f9e72e74c24e01
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..67ad16750752eb443ed6b693a0f9e72e74c24e01
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -323,3 +323,3 @@
 
-\1async () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..bff7e5d663441ca28d974d3231e157e58b7f1d56
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..bff7e5d663441ca28d974d3231e157e58b7f1d56
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+\1async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Preparing to handle logging test**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -352,3 +352,3 @@
 
-\1async () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..2195512f612a00345ab7a5d4b7eb6916a70643af
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..2195512f612a00345ab7a5d4b7eb6916a70643af
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+\1async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Preparing for validation test**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -372,3 +372,3 @@
 
-\1async () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..efbbe33036072011cb5ecc07b8219c001e41b42c
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..efbbe33036072011cb5ecc07b8219c001e41b42c
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+\1async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Running configuration test**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -398,3 +398,3 @@
 
-\1async () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..b0b8441d1c4062dd2503d702567a2d43f1c186f1
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..b0b8441d1c4062dd2503d702567a2d43f1c186f1
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying test function adjustments**
exec
bash -lc "rg -n --fixed-strings \"\\1async\" apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory exited 1 in 50ms:

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..b0b8441d1c4062dd2503d702567a2d43f1c186f1
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying async usage update**
exec
bash -lc "sed -n '120,420p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 44ms:
      await result;
    }
    if (!nextCalled || res.finished) {
      break;
    }
  }

  return res;
}

function createStubLogger() {
  const calls = [];
  const logger = {
    calls,
    info(...args) {
      calls.push({ level: 'info', args });
    },
    warn(...args) {
      calls.push({ level: 'warn', args });
    },
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..b0b8441d1c4062dd2503d702567a2d43f1c186f1
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -71,7 +105,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +115,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +147,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +159,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +180,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +203,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +219,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +244,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +254,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +267,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +301,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +321,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +335,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +350,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +360,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +370,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +384,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +396,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Planning geocoding ingestion tests**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -85,2 +85,13 @@
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..7707731f16b6b37f743439e39f75a5310ba49f9e
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +346,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +361,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +371,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +381,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +395,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +407,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..7707731f16b6b37f743439e39f75a5310ba49f9e
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,7 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +346,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +361,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +371,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +381,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +395,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +407,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Inserting new tests in existing suite**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -334,2 +334,116 @@
 
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
 test('crawler listing ingestion accepts batches and reports metadata', async () => {
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying test setup and fetch mocking behavior**

I’m making sure the fetch mock works correctly even if `global.fetch` is undefined or not called, that tests handle fallback scenarios with queued responses, and that new geocoding-related tests correctly fail before implementation. Next, I plan to run the tests inside `apps/api` with the appropriate working directory to confirm expected failures as part of TDD.
exec
bash -lc 'npm run test' in /var/home/rick/Development/mega-directory/apps/api exited 1 in 3.26s:

> mega-directory-api@0.1.0 test
> npm run build && node --test test/**/*.test.js


> mega-directory-api@0.1.0 build
> tsc -p tsconfig.json

TAP version 13
# Subtest: test/server.test.js
not ok 1 - test/server.test.js
  ---
  duration_ms: 418.104003
  type: 'test'
  location: '/var/home/rick/Development/mega-directory/apps/api/test/server.test.js:1:1'
  failureType: 'testCodeFailure'
  exitCode: 1
  signal: ~
  error: 'test failed'
  code: 'ERR_TEST_FAILURE'
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);



thinking
**Planning geocoding feature implementation**

I'm gathering ideas to add geocoding support by creating a new module with multiple provider fallbacks and updating server types, sanitization, and listing ingestion flow to fetch and store lat/lon coordinates securely after validating addresses. This involves careful TypeScript types, async handling, and logging around external API calls for robust geocoding integration.
thinking
**Detailing geocoding module and server integration**

I'm outlining the full geocoding module implementation for both providers with careful error handling, logging, and result parsing, then planning precise server-side type updates, config extensions, and ingestion handler modifications to call geocoding asynchronously and merge coordinates into listings before storage. This thorough approach ensures smooth fallback and consistent typing across the API.
Plan update
  ✓ Add tests covering geocoding behavior and async handling for crawler ingestion.
  → Implement geocoding integration with fallback support and config plumbing.
  • Run API test suite and adjust as needed.
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Implementing geocoding file**
exec
bash -lc "cat <<'EOF' > apps/api/src/geocoding.ts
import type { Logger } from './logger';

export interface GeocodingAddress {
  addressLine1?: string;
  addressLine2?: string;
  city?: string;
  region?: string;
  postalCode?: string;
  country?: string;
}

export interface GeocodingConfig {
  geocodeMapsApiKey?: string;
  googleGeocodeApiKey?: string;
}

export interface GeocodeResult {
  latitude: number;
  longitude: number;
  provider: 'geocode-maps' | 'google-maps';
}

const GEOCODE_MAPS_ENDPOINT = 'https://geocode.maps.co/search';
const GOOGLE_GEOCODE_ENDPOINT = 'https://maps.googleapis.com/maps/api/geocode/json';

export async function geocodeListingLocation(
  location: GeocodingAddress | null,
  config: GeocodingConfig,
  logger?: Logger
): Promise<GeocodeResult | null> {
  const query = buildAddressQuery(location);
  if ("'!query) {
    return null;
  }

  const providers: Array<() => Promise<GeocodeResult | null>> = [
    () => geocodeWithGeocodeMaps(query, config.geocodeMapsApiKey, logger),
    () => geocodeWithGoogle(query, config.googleGeocodeApiKey, logger)
  ];

  for (const lookup of providers) {
    try {
      const result = await lookup();
      if (result) {
        return result;
      }
    } catch (error) {
      logger?.warn(
        { event: '"'geocode.provider.error', error: describeError(error) },
        'Geocoding provider threw an unexpected error'
      );
    }
  }

  return null;
}

function buildAddressQuery(location?: GeocodingAddress | null): string | null {
  if ("'!location) {
    return null;
  }
  const parts = [
    location.addressLine1,
    location.addressLine2,
    location.city,
    location.region,
    location.postalCode,
    location.country
  ]
    .map((part) => (typeof part === '"'string' ? part.trim() : ''))
    .filter((part) => part.length > 0);

  return parts.length > 0 ? parts.join(', ') : null;
}

async function geocodeWithGeocodeMaps(
  query: string,
  apiKey: string | undefined,
  logger?: Logger
): Promise<GeocodeResult | null> {
  const url = new URL(GEOCODE_MAPS_ENDPOINT);
  url.searchParams.set('q', query);
  url.searchParams.set('format', 'json');
  if (apiKey) {
    url.searchParams.set('api_key', apiKey);
  }

  try {
    const response = await fetch(url.toString(), {
      headers: { accept: 'application/json' }
    });
    if ("'!response.ok) {
      const details = await safeReadBody(response);
      logger?.warn(
        {
          event: '"'geocode.maps.http_error',
          status: response.status,
          provider: 'geocode-maps',
          details
        },
        'Geocode Maps request failed'
      );
      return null;
    }

    const payload = await response.json();
    if ("'!Array.isArray(payload) || payload.length === 0) {
      logger?.debug?.({ event: '"'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
      return null;
    }

    for (const candidate of payload) {
      const lat = safeNumber(candidate?.lat);
      const lon = safeNumber(candidate?.lon);
      if (lat "'!== null && lon !== null) {
        return { latitude: lat, longitude: lon, provider: '"'geocode-maps' };
      }
    }

    logger?.warn(
      { event: 'geocode.maps.invalid_result', provider: 'geocode-maps' },
      'Geocode Maps response lacked numeric coordinates'
    );
    return null;
  } catch (error) {
    logger?.warn(
      { event: 'geocode.maps.error', provider: 'geocode-maps', error: describeError(error) },
      'Geocode Maps lookup failed'
    );
    return null;
  }
}

async function geocodeWithGoogle(
  query: string,
  apiKey: string | undefined,
  logger?: Logger
): Promise<GeocodeResult | null> {
  if ("'!apiKey) {
    logger?.debug?.({ event: '"'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
    return null;
  }

  const url = new URL(GOOGLE_GEOCODE_ENDPOINT);
  url.searchParams.set('address', query);
  url.searchParams.set('key', apiKey);

  try {
    const response = await fetch(url.toString(), {
      headers: { accept: 'application/json' }
    });
    if ("'!response.ok) {
      const details = await safeReadBody(response);
      logger?.warn(
        {
          event: '"'geocode.google.http_error',
          status: response.status,
          provider: 'google-maps',
          details
        },
        'Google geocoding request failed'
      );
      return null;
    }

    const payload = await response.json();
    if ("'!payload || payload.status !== '"'OK' || "'!Array.isArray(payload.results) || payload.results.length === 0) {
      logger?.debug?.(
        {
          event: '"'geocode.google.non_ok_status',
          provider: 'google-maps',
          status: payload?.status ?? 'UNKNOWN'
        },
        'Google geocoding did not return any matches'
      );
      return null;
    }

    const primary = payload.results[0]?.geometry?.location;
    const lat = safeNumber(primary?.lat);
    const lon = safeNumber(primary?.lng);
    if (lat === null || lon === null) {
      logger?.warn(
        { event: 'geocode.google.invalid_result', provider: 'google-maps' },
        'Google geocoding returned coordinates in an unexpected format'
      );
      return null;
    }

    return { latitude: lat, longitude: lon, provider: 'google-maps' };
  } catch (error) {
    logger?.warn(
      { event: 'geocode.google.error', provider: 'google-maps', error: describeError(error) },
      'Google geocoding lookup failed'
    );
    return null;
  }
}

function safeNumber(value: unknown): number | null {
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === 'string') {
    const parsed = Number.parseFloat(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

async function safeReadBody(response: Response): Promise<string | undefined> {
  try {
    return await response.text();
  } catch (_err) {
    return undefined;
  }
}

function describeError(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  if (typeof error === 'string') {
    return error;
  }
  try {
    return JSON.stringify(error);
  } catch (_err) {
    return 'Unknown error';
  }
}
EOF
" in /var/home/rick/Development/mega-directory succeeded in 41ms:

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Adjusting TypeScript Response typing**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/geocoding.ts
@@ -210,3 +210,3 @@
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/api/src/geocoding.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Reviewing and planning server.ts geocoding integration**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -3,2 +3,3 @@
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
@@ -15,10 +16,8 @@
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..b5c56c5d270adad041ebf1c7f643e70bc64eae33
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..b5c56c5d270adad041ebf1c7f643e70bc64eae33
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Updating ServerConfig interface**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -71,2 +71,4 @@
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..48a660ca242df7ab7c46dddc8cfeb3f6e1e5048a
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..48a660ca242df7ab7c46dddc8cfeb3f6e1e5048a
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Updating baseConfig with API keys**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -128,3 +128,5 @@
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..d94d62e9bb841d21675cb43c94b8977040e13886
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..d94d62e9bb841d21675cb43c94b8977040e13886
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Updating createListingIngestionHandler to use async**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -323,4 +323,6 @@
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
@@ -365,4 +367,27 @@
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..cec24a6da34c4cc6d7d7e48d78688a5fb2c42cbd
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..cec24a6da34c4cc6d7d7e48d78688a5fb2c42cbd
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Refining sanitizeLocation with GeocodingAddress**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -577,4 +577,11 @@
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying type safety and imports**
exec
bash -lc "sed -n '1,240p' apps/api/src/geocoding.ts" in /var/home/rick/Development/mega-directory succeeded in 40ms:
import type { Logger } from './logger';

export interface GeocodingAddress {
  addressLine1?: string;
  addressLine2?: string;
  city?: string;
  region?: string;
  postalCode?: string;
  country?: string;
}

export interface GeocodingConfig {
  geocodeMapsApiKey?: string;
  googleGeocodeApiKey?: string;
}

export interface GeocodeResult {
  latitude: number;
  longitude: number;
  provider: 'geocode-maps' | 'google-maps';
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..010ffcb18ad3b25b72c5dfe53dd33958c333b873
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Correcting logger optional chaining**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/geocoding.ts
@@ -107,3 +107,3 @@
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
@@ -139,3 +139,3 @@
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
@@ -167,3 +167,3 @@
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/api/src/geocoding.ts
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Verifying type integration and test coverage**

I’m carefully confirming that types align across the geocoding integration, that logger and config are safely accessed, and that location updates don’t mutate inputs incorrectly. I’m also ensuring the geocode provider fallbacks behave as expected and tests properly mock fetch calls. Next, I'll run the full test suite to verify everything compiles and works together smoothly.
exec
bash -lc 'npm run test' in /var/home/rick/Development/mega-directory/apps/api succeeded in 2.39s:

> mega-directory-api@0.1.0 test
> npm run build && node --test test/**/*.test.js


> mega-directory-api@0.1.0 build
> tsc -p tsconfig.json

TAP version 13
# Subtest: test/server.test.js
ok 1 - test/server.test.js
  ---
  duration_ms: 326.565835
  type: 'test'
  ...
1..1
# tests 1
# suites 0
# pass 1
# fail 0
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Updating plan statuses**
Plan update
  ✓ Add tests covering geocoding behavior and async handling for crawler ingestion.
  ✓ Implement geocoding integration with fallback support and config plumbing.
  ✓ Run API test suite and adjust as needed.
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Checking git status**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/mega-directory succeeded in 58ms:
## main...origin/main [ahead 6]
 M .env.example
?? .editorconfig
?? .vscode/
?? apps/
?? codex/LOGS/codex_run_2025-11-12_06-13-21.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log.done
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log.done
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log.done
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log.done
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log.done
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log.done
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log.done
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Summarizing changes with line references**
exec
bash -lc "nl -ba apps/api/src/geocoding.ts | sed -n '1,200p'" in /var/home/rick/Development/mega-directory succeeded in 41ms:
     1	import type { Logger } from './logger';
     2	
     3	export interface GeocodingAddress {
     4	  addressLine1?: string;
     5	  addressLine2?: string;
     6	  city?: string;
     7	  region?: string;
     8	  postalCode?: string;
     9	  country?: string;
    10	}
    11	
    12	export interface GeocodingConfig {
    13	  geocodeMapsApiKey?: string;
    14	  googleGeocodeApiKey?: string;
    15	}
    16	
    17	export interface GeocodeResult {
    18	  latitude: number;
    19	  longitude: number;
    20	  provider: 'geocode-maps' | 'google-maps';
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Gathering line numbers for key files**
exec
bash -lc "nl -ba apps/api/src/server.ts | sed -n '1,220p'" in /var/home/rick/Development/mega-directory succeeded in 41ms:
     1	import express, { type Express, type Request, type RequestHandler } from 'express';
     2	import jwt, { type JwtPayload } from 'jsonwebtoken';
     3	import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
     4	import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
     5	import { createLogger, createRequestLogger, type Logger } from './logger';
     6	
     7	const DEFAULT_PORT = DEFAULT_PORTS.api;
     8	const DEFAULT_LISTING_STATUS: ListingStatus = 'INACTIVE';
     9	const MAX_SLUG_LENGTH = 80;
    10	const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
    11	
    12	type ListingStatus = 'INACTIVE' | 'ACTIVE';
    13	
    14	type NullableString = string | null;
    15	
    16	type ListingLocation =
    17	  | (GeocodingAddress & {
    18	      latitude?: number;
    19	      longitude?: number;
    20	      geocodedBy?: string | null;
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Capturing ingestion handler definition**
exec
bash -lc "nl -ba apps/api/src/server.ts | sed -n '240,520p'" in /var/home/rick/Development/mega-directory succeeded in 45ms:
   240	function requireAdminAuth(config: ServerConfig): RequestHandler {
   241	  return (req, res, next) => {
   242	    const token = extractBearerToken(req);
   243	    if (!token) {
   244	      return res.status(401).json({ error: 'Admin token missing or invalid' });
   245	    }
   246	
   247	    try {
   248	      const payload = jwt.verify(token, config.adminJwtSecret, {
   249	        issuer: config.adminJwtIssuer,
   250	        audience: config.adminJwtAudience
   251	      });
   252	      req.admin = payload;
   253	      return next();
   254	    } catch (_err) {
   255	      return res.status(401).json({ error: 'Admin token missing or invalid' });
   256	    }
   257	  };
   258	}
   259	
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Locating sanitizeLocation code segment**
exec
bash -lc "nl -ba apps/api/src/server.ts | sed -n '520,760p'" in /var/home/rick/Development/mega-directory succeeded in 44ms:
   520	  return value
   521	    .toLowerCase()
   522	    .replace(/[^a-z0-9]+/g, '-')
   523	    .replace(/-{2,}/g, '-')
   524	    .replace(/^-+|-+$/g, '')
   525	    .slice(0, maxLength);
   526	}
   527	
   528	function isPlainObject(value: unknown): value is Record<string, any> {
   529	  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
   530	}
   531	
   532	function sanitizeNullableString(value: unknown): NullableString {
   533	  if (typeof value !== 'string') {
   534	    return null;
   535	  }
   536	  const trimmed = value.trim();
   537	  return trimmed.length > 0 ? trimmed : null;
   538	}
   539	
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Listing test file line numbers**
exec
bash -lc "nl -ba apps/api/test/server.test.js | sed -n '1,220p'" in /var/home/rick/Development/mega-directory succeeded in 47ms:
     1	const test = require('node:test');
     2	const assert = require('node:assert');
     3	const jwt = require('jsonwebtoken');
     4	const { createServer } = require('..');
     5	
     6	const baseConfig = Object.freeze({
     7	  adminJwtSecret: 'test-admin-secret',
     8	  adminJwtIssuer: 'mega-directory',
     9	  adminJwtAudience: 'admin',
    10	  adminLoginEmail: 'admin@example.com',
    11	  adminLoginPasscode: 'letmein',
    12	  crawlerBearerToken: 'crawler-token'
    13	});
    14	
    15	const nativeFetch = global.fetch;
    16	
    17	function createFetchMock(responses = []) {
    18	  const queue = responses.slice();
    19	  const calls = [];
    20	
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Extracting geocoding tests section**
exec
bash -lc "nl -ba apps/api/test/server.test.js | sed -n '260,560p'" in /var/home/rick/Development/mega-directory succeeded in 42ms:
   260	    createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
   261	    createResponse()
   262	  );
   263	
   264	  assert.strictEqual(pingRes.statusCode, 200);
   265	  assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
   266	});
   267	
   268	test('crawler ping rejects invalid bearer token', async () => {
   269	  const app = createServer(baseConfig);
   270	  const route = findRoute(app, 'post', '/v1/crawler/ping');
   271	  const res = await runRoute(
   272	    route,
   273	    createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
   274	    createResponse()
   275	  );
   276	
   277	  assert.strictEqual(res.statusCode, 401);
   278	  assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
   279	});
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Capturing fallback test portions**
exec
bash -lc "nl -ba apps/api/test/server.test.js | sed -n '560,760p'" in /var/home/rick/Development/mega-directory succeeded in 43ms:

file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Analyzing file output truncation**

I notice the output was cut off at 273 lines, which seems less than the actual file length of 480. It looks like the sed command requested lines beyond the file end, causing repeated lines or truncation. I'll rerun the command starting around line 330 to capture the missing portion and get a full view for fallback or testing.
exec
bash -lc "nl -ba apps/api/test/server.test.js | sed -n '330,460p'" in /var/home/rick/Development/mega-directory succeeded in 46ms:
   330	  assert.strictEqual(all[0].title, 'Acme Electric Co.');
   331	  assert.strictEqual(all[0].rawPayload.title, 'Acme Electric Co.');
   332	  assert.ok(Date.parse(all[0].ingestedAt));
   333	});
   334	
   335	test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
   336	  const mockFetch = createFetchMock([
   337	    {
   338	      body: [
   339	        {
   340	          lat: '40.7128',
   341	          lon: '-74.0060'
   342	        }
   343	      ]
   344	    }
   345	  ]);
   346	  const app = createServer({
   347	    ...baseConfig,
   348	    geocodeMapsApiKey: 'maps-key',
   349	    googleGeocodeApiKey: 'google-key'
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);


thinking
**Summarizing updates and next steps**

I'll create a friendly bullet list highlighting key code changes like the new geocoding module, async handler updates, fetch mocking in tests, and environment variable additions with file line references. I’ll mention running tests with `npm run test` and suggest next steps such as adding the required API keys to environment variables and verifying fallback behaviors. This should give a clear overview and guidance on what’s been done and what to do next.
codex
Added automatic geocoding during crawler ingestion with a geocode.maps.co → Google fallback and the tests to lock it down.

- Added `apps/api/src/geocoding.ts:1` with a reusable `geocodeListingLocation` helper that builds an address query, hits geocode.maps.co first, then transparently falls back to Google (with HTTP error handling, zero-result detection, and provider metadata).
- Extended the API config surface to carry `GEOCODEMAPS_API_KEY`/`GOOGLEMAPS_API_KEY`, expanded the listing location shape, and wired the ingestion handler to await geocoding before storing records (`apps/api/src/server.ts:16`, `apps/api/src/server.ts:63`, `apps/api/src/server.ts:323`). Sanitized locations now strip user-provided lat/lon while still capturing address fields (`apps/api/src/server.ts:574`).
- Reworked the test harness to support async handlers and mock `fetch`, then added coverage for the happy path, provider fallback, and failure scenarios so that lat/lon enrichment is verified end-to-end (`apps/api/test/server.test.js:15`, `apps/api/test/server.test.js:119`, `apps/api/test/server.test.js:335`).

Tests: `npm run test` (from `apps/api`).

Next steps:
1. Populate `GEOCODEMAPS_API_KEY` and `GOOGLEMAPS_API_KEY` in your env so the new config fields are available outside the test harness.
file update:
diff --git a/apps/api/src/geocoding.ts b/apps/api/src/geocoding.ts
index 093478f943e8ee7974c1ad3ad6fe3c65eba09514..975644dac0d973ca5b6dd8a53e45a20484352731
--- a/apps/api/src/geocoding.ts
+++ b/apps/api/src/geocoding.ts
@@ -105,7 +105,7 @@
 
     const payload = await response.json();
     if (!Array.isArray(payload) || payload.length === 0) {
-      logger?.debug?.({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
+      logger?.debug({ event: 'geocode.maps.zero_results' }, 'Geocode Maps returned no matches');
       return null;
     }
 
@@ -137,7 +137,7 @@
   logger?: Logger
 ): Promise<GeocodeResult | null> {
   if (!apiKey) {
-    logger?.debug?.({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
+    logger?.debug({ event: 'geocode.google.skip', reason: 'missing-api-key' }, 'Skipped Google geocoding due to missing key');
     return null;
   }
 
@@ -165,7 +165,7 @@
 
     const payload = await response.json();
     if (!payload || payload.status !== 'OK' || !Array.isArray(payload.results) || payload.results.length === 0) {
-      logger?.debug?.(
+      logger?.debug(
         {
           event: 'geocode.google.non_ok_status',
           provider: 'google-maps',
@@ -208,7 +208,7 @@
   return null;
 }
 
-async function safeReadBody(response: Response): Promise<string | undefined> {
+async function safeReadBody(response: { text(): Promise<string> }): Promise<string | undefined> {
   try {
     return await response.text();
   } catch (_err) {
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index dc143360508ccd64cbaaeb4a7d5aa767d69fd6a6..ad1746791d43ad699bb8bdb71cae214e83a483f7
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,6 +1,7 @@
 import express, { type Express, type Request, type RequestHandler } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
+import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
 import { createLogger, createRequestLogger, type Logger } from './logger';
 
 const DEFAULT_PORT = DEFAULT_PORTS.api;
@@ -13,14 +14,12 @@
 type NullableString = string | null;
 
 type ListingLocation =
-  | {
-      addressLine1?: string;
-      addressLine2?: string;
-      city?: string;
-      region?: string;
-      postalCode?: string;
-      country?: string;
-    }
+  | (GeocodingAddress & {
+      latitude?: number;
+      longitude?: number;
+      geocodedBy?: string | null;
+      geocodedAt?: string | null;
+    })
   | null;
 
 interface NormalizedListing {
@@ -70,6 +69,8 @@
   adminLoginEmail: string;
   adminLoginPasscode: string;
   adminTokenTtlSeconds: number;
+  geocodeMapsApiKey: string;
+  googleGeocodeApiKey: string;
 }
 
 interface CreateServerOptions extends Partial<ServerConfig> {
@@ -125,7 +126,9 @@
     adminTokenTtlSeconds:
       typeof parsedAdminTokenTtl === 'number' && Number.isFinite(parsedAdminTokenTtl) && parsedAdminTokenTtl > 0
         ? parsedAdminTokenTtl
-        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS
+        : DEFAULT_ADMIN_TOKEN_TTL_SECONDS,
+    geocodeMapsApiKey: overrides.geocodeMapsApiKey ?? process.env.GEOCODEMAPS_API_KEY ?? '',
+    googleGeocodeApiKey: overrides.googleGeocodeApiKey ?? process.env.GOOGLEMAPS_API_KEY ?? ''
   };
 
   const missing: string[] = [];
@@ -318,8 +321,10 @@
 }
 
 function createListingIngestionHandler(app: Express): RequestHandler {
-  return (req, res) => {
-    const logger = getAppLocals(app).logger;
+  return async (req, res) => {
+    const locals = getAppLocals(app);
+    const logger = locals.logger;
+    const config = locals.config;
     const payloads = normalizeListingBatch(req.body);
     if (!payloads) {
       logger.warn(
@@ -360,8 +365,31 @@
       return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
     }
 
-    const store = getAppLocals(app).ingestionStore;
-    const savedRecords = validEntries.map(({ index, value }) =>
+    const geocodeConfig = {
+      geocodeMapsApiKey: config.geocodeMapsApiKey,
+      googleGeocodeApiKey: config.googleGeocodeApiKey
+    };
+
+    const enrichedEntries = await Promise.all(
+      validEntries.map(async ({ index, value }) => {
+        if (value.location) {
+          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
+          if (coords) {
+            value.location = {
+              ...value.location,
+              latitude: coords.latitude,
+              longitude: coords.longitude,
+              geocodedBy: coords.provider,
+              geocodedAt: new Date().toISOString()
+            };
+          }
+        }
+        return { index, value };
+      })
+    );
+
+    const store = locals.ingestionStore;
+    const savedRecords = enrichedEntries.map(({ index, value }) =>
       store.insert(value, payloads[index])
     );
     const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
@@ -547,8 +575,15 @@
   if (!isPlainObject(value)) {
     return null;
   }
-  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
-  const location: Record<string, string> = {};
+  const fields: Array<keyof GeocodingAddress> = [
+    'addressLine1',
+    'addressLine2',
+    'city',
+    'region',
+    'postalCode',
+    'country'
+  ];
+  const location: Partial<GeocodingAddress> = {};
   fields.forEach((field) => {
     const sanitized = sanitizeNullableString((value as Record<string, unknown>)[field]);
     if (sanitized) {
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index 56b643c361125a9d8094f6b1357f48ea92ddda01..c5e69a6baadeed506e8fd0f6c35449d150e2fd91
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -12,6 +12,40 @@
   crawlerBearerToken: 'crawler-token'
 });
 
+const nativeFetch = global.fetch;
+
+function createFetchMock(responses = []) {
+  const queue = responses.slice();
+  const calls = [];
+
+  global.fetch = async (input, init = {}) => {
+    calls.push({ input, init });
+    if (queue.length === 0) {
+      throw new Error('Unexpected fetch call');
+    }
+    const next = queue.shift();
+    if (next.error) {
+      throw next.error;
+    }
+    const ok = next.ok !== undefined ? next.ok : true;
+    const status = next.status ?? (ok ? 200 : 500);
+    const body = next.body ?? null;
+    return {
+      ok,
+      status,
+      json: async () => body,
+      text: async () => (typeof body === 'string' ? body : JSON.stringify(body))
+    };
+  };
+
+  return {
+    calls,
+    restore() {
+      global.fetch = nativeFetch;
+    }
+  };
+}
+
 function findRoute(app, method, path) {
   const stack = (app._router && app._router.stack) || (app.router && app.router.stack) || [];
   const methodName = method.toLowerCase();
@@ -49,6 +83,17 @@
   };
 }
 
+function buildLocation(overrides = {}) {
+  return {
+    addressLine1: '123 Broadway',
+    city: 'New York',
+    region: 'NY',
+    postalCode: '10007',
+    country: 'USA',
+    ...overrides
+  };
+}
+
 function createResponse() {
   return {
     statusCode: 200,
@@ -71,7 +116,7 @@
   };
 }
 
-function runRoute(route, req, res) {
+async function runRoute(route, req, res) {
   if (!route) {
     throw new Error('Route not found');
   }
@@ -81,7 +126,10 @@
     const next = () => {
       nextCalled = true;
     };
-    layer.handle(req, res, next);
+    const result = layer.handle(req, res, next);
+    if (result && typeof result.then === 'function') {
+      await result;
+    }
     if (!nextCalled || res.finished) {
       break;
     }
@@ -110,10 +158,10 @@
   return logger;
 }
 
-test('health endpoint reports monitoring metadata', () => {
+test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.strictEqual(res.body.status, 'ok');
@@ -122,16 +170,16 @@
   assert.ok(res.body.startedAt);
 });
 
-test('admin ping rejects missing token', () => {
+test('admin ping rejects missing token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
-  const res = runRoute(route, createRequest(), createResponse());
+  const res = await runRoute(route, createRequest(), createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Admin token missing or invalid');
 });
 
-test('admin ping accepts valid JWT', () => {
+test('admin ping accepts valid JWT', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'get', '/v1/admin/ping');
   const token = jwt.sign(
@@ -143,17 +191,17 @@
   const req = createRequest({
     headers: { Authorization: `Bearer ${token}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'admin-ok' });
   assert.strictEqual(req.admin.role, 'admin');
 });
 
-test('admin auth route rejects missing credentials', () => {
+test('admin auth route rejects missing credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', body: {} }),
     createResponse()
@@ -166,10 +214,10 @@
   assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
 });
 
-test('admin auth route rejects invalid credentials', () => {
+test('admin auth route rejects invalid credentials', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/admin/auth');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({
       method: 'POST',
@@ -182,10 +230,10 @@
   assert.strictEqual(res.body.error, 'Invalid admin credentials');
 });
 
-test('admin auth issues JWTs that unlock protected routes', () => {
+test('admin auth issues JWTs that unlock protected routes', async () => {
   const app = createServer(baseConfig);
   const authRoute = findRoute(app, 'post', '/v1/admin/auth');
-  const loginRes = runRoute(
+  const loginRes = await runRoute(
     authRoute,
     createRequest({
       method: 'POST',
@@ -207,7 +255,7 @@
   assert.strictEqual(decoded.sub, baseConfig.adminLoginEmail.toLowerCase());
 
   const pingRoute = findRoute(app, 'get', '/v1/admin/ping');
-  const pingRes = runRoute(
+  const pingRes = await runRoute(
     pingRoute,
     createRequest({ headers: { Authorization: `Bearer ${loginRes.body.token}` } }),
     createResponse()
@@ -217,10 +265,10 @@
   assert.deepStrictEqual(pingRes.body, { status: 'admin-ok' });
 });
 
-test('crawler ping rejects invalid bearer token', () => {
+test('crawler ping rejects invalid bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
-  const res = runRoute(
+  const res = await runRoute(
     route,
     createRequest({ method: 'POST', headers: { Authorization: 'Bearer wrong-token' } }),
     createResponse()
@@ -230,33 +278,33 @@
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler ping accepts matching bearer token', () => {
+test('crawler ping accepts matching bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/ping');
   const req = createRequest({
     method: 'POST',
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` }
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 200);
   assert.deepStrictEqual(res.body, { status: 'crawler-ok' });
 });
 
-test('crawler listing ingestion rejects missing bearer token', () => {
+test('crawler listing ingestion rejects missing bearer token', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
     method: 'POST',
     body: buildListingPayload()
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 401);
   assert.strictEqual(res.body.error, 'Crawler token missing or invalid');
 });
 
-test('crawler listing ingestion stores sanitized listings as inactive', () => {
+test('crawler listing ingestion stores sanitized listings as inactive', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const req = createRequest({
@@ -264,7 +312,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: buildListingPayload({ slug: 'ACME Electric!!', summary: 'Trusted' })
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 1);
@@ -284,7 +332,121 @@
   assert.ok(Date.parse(all[0].ingestedAt));
 });
 
-test('crawler listing ingestion accepts batches and reports metadata', () => {
+test('crawler listing ingestion geocodes addresses via geocode maps', async () => {
+  const mockFetch = createFetchMock([
+    {
+      body: [
+        {
+          lat: '40.7128',
+          lon: '-74.0060'
+        }
+      ]
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation() })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 1);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location, 'expected location to be stored');
+    assert.strictEqual(record.location.latitude, 40.7128);
+    assert.strictEqual(record.location.longitude, -74.006);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion falls back to google geocode when primary fails', async () => {
+  const mockFetch = createFetchMock([
+    { body: [] },
+    {
+      body: {
+        status: 'OK',
+        results: [
+          {
+            geometry: {
+              location: { lat: 47.6062, lng: -122.3321 }
+            }
+          }
+        ]
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Seattle', region: 'WA' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
+    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
+    const [record] = app.locals.ingestionStore.all();
+    assert.strictEqual(record.location.latitude, 47.6062);
+    assert.strictEqual(record.location.longitude, -122.3321);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion keeps processing when geocoding fails', async () => {
+  const mockFetch = createFetchMock([
+    { error: new Error('network down') },
+    {
+      body: {
+        status: 'ZERO_RESULTS',
+        results: []
+      }
+    }
+  ]);
+  const app = createServer({
+    ...baseConfig,
+    geocodeMapsApiKey: 'maps-key',
+    googleGeocodeApiKey: 'google-key'
+  });
+  const route = findRoute(app, 'post', '/v1/crawler/listings');
+  const req = createRequest({
+    method: 'POST',
+    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
+    body: buildListingPayload({ location: buildLocation({ city: 'Austin', region: 'TX' }) })
+  });
+
+  try {
+    const res = await runRoute(route, req, createResponse());
+    assert.strictEqual(res.statusCode, 202);
+    assert.strictEqual(mockFetch.calls.length, 2);
+    const [record] = app.locals.ingestionStore.all();
+    assert.ok(record.location);
+    assert.strictEqual(record.location.latitude, undefined);
+    assert.strictEqual(record.location.longitude, undefined);
+  } finally {
+    mockFetch.restore();
+  }
+});
+
+test('crawler listing ingestion accepts batches and reports metadata', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -298,7 +460,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 202);
   assert.strictEqual(res.body.ingestedCount, 2);
@@ -313,7 +475,7 @@
   assert.strictEqual(records[1].categorySlug, 'photographers');
 });
 
-test('crawler listing ingestion logs batch summary', () => {
+test('crawler listing ingestion logs batch summary', async () => {
   const logger = createStubLogger();
   const app = createServer({ ...baseConfig, logger });
   const route = findRoute(app, 'post', '/v1/crawler/listings');
@@ -323,7 +485,7 @@
     body: buildListingPayload({ slug: null })
   });
 
-  runRoute(route, req, createResponse());
+  await runRoute(route, req, createResponse());
 
   const infoLog = logger.calls.find((entry) => entry.level === 'info');
   assert.ok(infoLog, 'expected ingestion handler to log summary');
@@ -333,7 +495,7 @@
   assert.deepStrictEqual(metadata.categories, ['electricians']);
 });
 
-test('crawler listing ingestion validates payload shape and reports errors', () => {
+test('crawler listing ingestion validates payload shape and reports errors', async () => {
   const app = createServer(baseConfig);
   const route = findRoute(app, 'post', '/v1/crawler/listings');
   const payload = {
@@ -347,7 +509,7 @@
     headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
     body: payload
   });
-  const res = runRoute(route, req, createResponse());
+  const res = await runRoute(route, req, createResponse());
 
   assert.strictEqual(res.statusCode, 400);
   assert.strictEqual(res.body.error, 'Invalid listing payload');
@@ -359,7 +521,7 @@
   assert.strictEqual(app.locals.ingestionStore.all().length, 0);
 });
 
-test('createServer enforces required configuration', () => {
+test('createServer enforces required configuration', async () => {
   assert.throws(() => {
     createServer({ crawlerBearerToken: 'only-crawler' });
   }, /Missing required config value/);

tokens used
124,605
Added automatic geocoding during crawler ingestion with a geocode.maps.co → Google fallback and the tests to lock it down.

- Added `apps/api/src/geocoding.ts:1` with a reusable `geocodeListingLocation` helper that builds an address query, hits geocode.maps.co first, then transparently falls back to Google (with HTTP error handling, zero-result detection, and provider metadata).
- Extended the API config surface to carry `GEOCODEMAPS_API_KEY`/`GOOGLEMAPS_API_KEY`, expanded the listing location shape, and wired the ingestion handler to await geocoding before storing records (`apps/api/src/server.ts:16`, `apps/api/src/server.ts:63`, `apps/api/src/server.ts:323`). Sanitized locations now strip user-provided lat/lon while still capturing address fields (`apps/api/src/server.ts:574`).
- Reworked the test harness to support async handlers and mock `fetch`, then added coverage for the happy path, provider fallback, and failure scenarios so that lat/lon enrichment is verified end-to-end (`apps/api/test/server.test.js:15`, `apps/api/test/server.test.js:119`, `apps/api/test/server.test.js:335`).

Tests: `npm run test` (from `apps/api`).

Next steps:
1. Populate `GEOCODEMAPS_API_KEY` and `GOOGLEMAPS_API_KEY` in your env so the new config fields are available outside the test harness.
