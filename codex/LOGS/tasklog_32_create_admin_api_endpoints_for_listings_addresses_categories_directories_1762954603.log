OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a7848-6db2-7b30-ad31-e69f331403ca
--------
user
Implement the functionality described in codex/TASKS/32_create_admin_api_endpoints_for_listings_addresses_categories_directories.yaml, then verify with any available tests.
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX

thinking
**Reviewing task instructions and planning**
exec
bash -lc ls in /var/home/rick/Development/mega-directory succeeded in 40ms:
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
env.json
Makefile
package.json
packages
README.md
scripts
tests
tsconfig.json

thinking
**Inspecting codex/TASKS file**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/mega-directory succeeded in 41ms:
00_prepare_repository.yaml
01_initialize_astro_frontend.yaml
02_setup_api_server_with_express_and_jwt_auth.yaml
03_design_postgresql_schema.yaml
04_implement_listing_ingestion_api_endpoint.yaml
05_admin_auth_route_and_middleware.yaml
06_frontend_directory_page_rendering.yaml
07_frontend_subcategory_ui_and_layout.yaml
08_setup_featured_listings_logic.yaml
09_add_category_meta_and_seo_controls.yaml
10_scaffold_python_crawler_agent.yaml
11_llm_field_generation_via_jinja2.yaml
12_post_listings_from_crawler_to_api_server.yaml
13_create_json_crawler_configuration_schema.yaml
14_scaffold_admin_ui_application.yaml
15_admin_ui:_listing_review_table.yaml
16_admin_ui:_category_location_approval.yaml
17_admin_ui:_seo_field_editor.yaml
18_deploy_web_+_api_to_railway.yaml
19_setup_logging,_healthchecks_and_monitoring.yaml

thinking
**Recalling task instructions**
exec
bash -lc 'cat codex/TASKS/32_create_admin_api_endpoints_for_listings_addresses_categories_directories.yaml' in /var/home/rick/Development/mega-directory succeeded in 38ms:
id: 32
filename: 32_create_admin_api_endpoints_for_listings_addresses_categories_directories.yaml
title: Create Admin API Endpoints for Listings, Addresses, Categories, Directories
description: >
- Implement secure CRUD endpoints for listings, addresses, categories, and directory pages.
- Ensure proper validation, authentication, and error handling.
-  Support creation with nested data structures.
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
dependencies: []

thinking
**Inspecting project structure**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/mega-directory succeeded in 38ms:
{
  "name": "mega-directory",
  "private": true,
  "version": "0.1.0",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "test": "npm run test:root && npm run test:workspaces",
    "test:root": "node --test tests/**/*.test.js",
    "test:workspaces": "npm run test --workspaces --if-present"
  }
}

thinking
**Locating API server and planning tests**
exec
bash -lc 'ls apps' in /var/home/rick/Development/mega-directory succeeded in 40ms:
admin
api
crawler
web

thinking
**Inspecting apps/api directory**
exec
bash -lc 'ls apps/api' in /var/home/rick/Development/mega-directory succeeded in 51ms:
dist
Dockerfile
node_modules
package.json
package-lock.json
src
test
tsconfig.json
types

thinking
**Inspecting apps/api package**
exec
bash -lc 'cat apps/api/package.json' in /var/home/rick/Development/mega-directory succeeded in 39ms:
{
  "name": "mega-directory-api",
  "private": true,
  "version": "0.1.0",
  "type": "commonjs",
  "main": "dist/server.js",
  "types": "dist/server.d.ts",
  "scripts": {
    "dev": "npm run build && node dist/server.js",
    "dev:watch": "tsc -p tsconfig.json --watch",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "test": "npm run build && node --test test/**/*.test.js"
  },
  "dependencies": {
    "@mega-directory/config": "file:../../packages/shared-config",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {

thinking
**Checking for TypeScript files**
exec
bash -lc 'ls apps/api/src' in /var/home/rick/Development/mega-directory succeeded in 43ms:
geocoding.ts
logger.ts
server.ts

thinking
**Opening server file**
exec
bash -lc "sed -n '1,200p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 56ms:
import express, { type Express, type Request, type RequestHandler } from 'express';
import jwt, { type JwtPayload } from 'jsonwebtoken';
import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
import { createLogger, createRequestLogger, type Logger } from './logger';

const DEFAULT_PORT = DEFAULT_PORTS.api;
const DEFAULT_LISTING_STATUS: ListingStatus = 'INACTIVE';
const MAX_SLUG_LENGTH = 80;
const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;

type ListingStatus = 'INACTIVE' | 'ACTIVE';

type NullableString = string | null;

type ListingLocation =
  | (GeocodingAddress & {
      latitude?: number;
      longitude?: number;
      geocodedBy?: string | null;
exec
bash -lc "sed -n '200,400p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 40ms:
    createListingIngestionHandler(app)
  );

  return app;
}

export function startServer() {
  const app = createServer();
  const { port } = getAppLocals(app).config;
  app.listen(port, () => {
    getAppLocals(app).logger.info(
      { event: 'api.start', port, environment: process.env.NODE_ENV || 'development' },
      `API server running at http://localhost:${port}`
    );
  });
}

if (require.main === module) {
  startServer();
}
exec
bash -lc "sed -n '400,800p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 40ms:
        categories
      },
      'Accepted crawler listings batch'
    );

    return res.status(202).json({
      ingestedCount: savedRecords.length,
      ingested: savedRecords.map(({ id, title, slug, status, categorySlug, ingestedAt }) => ({
        id,
        title,
        slug,
        status,
        categorySlug,
        ingestedAt
      }))
    });
  };
}

function normalizeListingBatch(payload: unknown): unknown[] | null {

thinking
**Checking data models for admin APIs**
exec
bash -lc 'rg -n "directory" -n' in /var/home/rick/Development/mega-directory succeeded in 90ms:
package.json:2:  "name": "mega-directory",
packages/shared-config/README.md:1:# @mega-directory/config
packages/shared-config/README.md:6:const { PROJECT_NAME, DEFAULT_PORTS } = require('@mega-directory/config');
packages/shared-config/package.json:2:  "name": "@mega-directory/config",
apps/crawler/dev_runner.py:89:                "subdomain": "demo.megadirectory.local",
apps/crawler/dev_runner.py:106:    logger = logging.getLogger("mega_directory.dev_crawler")
apps/crawler/dev_runner.py:118:        description="Replay sample directory HTML into the local API so the dev stack has data."
apps/crawler/config/targets.schema.json:3:  "$id": "https://mega-directory.dev/schemas/crawler-targets.json",
apps/crawler/crawler.py:636:    logger = logging.getLogger("mega_directory.crawler")
apps/admin/package-lock.json:2:  "name": "mega-directory-admin",
apps/admin/package-lock.json:8:      "name": "mega-directory-admin",
apps/admin/test/directoryPageService.test.js:4:const directoryStore = require('../data/directoryPages');
apps/admin/test/directoryPageService.test.js:5:const directoryOptions = require('../data/directoryPageOptions');
apps/admin/test/directoryPageService.test.js:9:} = require('../services/directoryPageService');
apps/admin/test/directoryPageService.test.js:11:const originalStore = deepClone(directoryStore);
apps/admin/test/directoryPageService.test.js:14:  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
apps/admin/test/directoryPageService.test.js:20:  const initialLength = directoryStore.length;
apps/admin/test/directoryPageService.test.js:26:    subdirectory: '',
apps/admin/test/directoryPageService.test.js:35:    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
apps/admin/test/directoryPageService.test.js:37:  assert.strictEqual(directoryStore.length, initialLength);

thinking
**Searching for listing-related code**
exec
bash -lc 'rg -n "listing" apps/api/src/server.ts' in /var/home/rick/Development/mega-directory succeeded in 41ms:
47:  insert(listing: NormalizedListing, rawPayload: unknown): ListingRecord;
198:    '/v1/crawler/listings',
331:        { event: 'listings.ingest.invalid', reason: 'bad-shape' },
332:        'Invalid listing payload received'
336:        .json({ error: 'Invalid listing payload', details: ['Request body must be an object or array'] });
341:        .json({ error: 'Invalid listing payload', details: ['At least one listing must be provided'] });
359:          event: 'listings.ingest.invalid',
363:        'Rejected crawler listings batch due to validation errors'
365:      return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
398:        event: 'listings.ingested',
402:      'Accepted crawler listings batch'
423:  if (isPlainObject(payload) && Array.isArray(payload.listings)) {
424:    return payload.listings.slice();
435:    return { valid: false, errors: ['Each listing must be an object'] };
487:  const listings: ListingRecord[] = [];
489:    insert(listing, rawPayload) {
492:        title: listing.title,
493:        slug: listing.slug,
494:        categorySlug: listing.categorySlug,
496:        websiteUrl: listing.websiteUrl ?? null,

thinking
**Exploring data sources for admin endpoints**
exec
bash -lc 'ls db' in /var/home/rick/Development/mega-directory succeeded in 40ms:
geography
migrations
schema.prisma
scripts
seed.ts

thinking
**Inspecting admin app and data**
exec
bash -lc 'ls apps/admin' in /var/home/rick/Development/mega-directory succeeded in 39ms:
data
index.js
node_modules
package.json
package-lock.json
public
routes
services
test
views

thinking
**Checking data directories**
exec
bash -lc 'ls apps/admin/data' in /var/home/rick/Development/mega-directory succeeded in 39ms:
categoryLocationDiscoveries.js
categoryLocations.js
directoryPageOptions.js
directoryPages.js
listings.js
seoEntries.js

thinking
**Searching for data array usage**
exec
bash -lc 'rg -n "directoryPages" -n' in /var/home/rick/Development/mega-directory succeeded in 48ms:
apps/admin/test/directoryPageService.test.js:4:const directoryStore = require('../data/directoryPages');
apps/admin/services/directoryPageService.js:1:const directoryPages = require('../data/directoryPages');
apps/admin/services/directoryPageService.js:11:  return directoryPages.map((page) => ({
apps/admin/services/directoryPageService.js:44:  directoryPages.push(storedRecord);
apps/admin/services/directoryPageService.js:61:    const record = directoryPages.find((entry) => entry.id === payload.id);
apps/admin/services/directoryPageService.js:285:  return !directoryPages.some((entry) => {
apps/admin/index.js:7:const directoryPagesRouter = require('./routes/directoryPages');
apps/admin/index.js:27:app.use('/directory-pages', directoryPagesRouter);
codex/LOGS/tasklog_32_create_admin_api_endpoints_for_listings_addresses_categories_directories_1762954603.log:244:apps/admin/test/directoryPageService.test.js:4:const directoryStore = require('../data/directoryPages');
codex/LOGS/tasklog_32_create_admin_api_endpoints_for_listings_addresses_categories_directories_1762954603.log:311:directoryPages.js
codex/LOGS/tasklog_32_create_admin_api_endpoints_for_listings_addresses_categories_directories_1762954603.log:318:bash -lc 'rg -n "directoryPages" -n' in /var/home/rick/Development/mega-directory
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:69:apps/admin/services/directoryPageService.js:11:  return directoryPages.map((page) => ({
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:489:apps/admin/data/directoryPages.js:8:    locationAgnostic: false,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:490:apps/admin/data/directoryPages.js:29:    locationAgnostic: false,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:495:apps/admin/routes/directoryPages.js:89:      locationAgnostic: entry.locationAgnostic,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:496:apps/admin/routes/directoryPages.js:133:    locationAgnostic: parseCheckbox(payload.locationAgnostic),
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:503:const directoryPages = require('../data/directoryPages');
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:513:  return directoryPages.map((page) => ({
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:527:bash -lc "sed -n '1,200p' apps/admin/data/directoryPages.js" in /var/home/rick/Development/mega-directory succeeded in 46ms:
codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log:409:apps/admin/data/directoryPages.js:6:    categoryId: 'cat_electricians',

thinking
**Reviewing test directory**
exec
bash -lc 'ls apps/api/test' in /var/home/rick/Development/mega-directory succeeded in 40ms:
server.test.js

thinking
**Reviewing test requirements**
exec
bash -lc "sed -n '1,200p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 42ms:
const test = require('node:test');
const assert = require('node:assert');
const jwt = require('jsonwebtoken');
const { createServer } = require('..');

const baseConfig = Object.freeze({
  adminJwtSecret: 'test-admin-secret',
  adminJwtIssuer: 'mega-directory',
  adminJwtAudience: 'admin',
  adminLoginEmail: 'admin@example.com',
  adminLoginPasscode: 'letmein',
  crawlerBearerToken: 'crawler-token'
});

const nativeFetch = global.fetch;

function createFetchMock(responses = []) {
  const queue = responses.slice();
  const calls = [];


thinking
**Continuing test exploration**
exec
bash -lc "sed -n '200,400p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 42ms:

test('admin auth route rejects missing credentials', async () => {
  const app = createServer(baseConfig);
  const route = findRoute(app, 'post', '/v1/admin/auth');
  const res = await runRoute(
    route,
    createRequest({ method: 'POST', body: {} }),
    createResponse()
  );

  assert.strictEqual(res.statusCode, 400);
  assert.strictEqual(res.body.error, 'Invalid admin credentials');
  assert.ok(Array.isArray(res.body.details));
  assert.ok(res.body.details.some((msg) => msg.includes('email')));
  assert.ok(res.body.details.some((msg) => msg.includes('passcode')));
});

test('admin auth route rejects invalid credentials', async () => {
  const app = createServer(baseConfig);
  const route = findRoute(app, 'post', '/v1/admin/auth');
exec
bash -lc "sed -n '400,800p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 40ms:
  try {
    const res = await runRoute(route, req, createResponse());
    assert.strictEqual(res.statusCode, 202);
    assert.strictEqual(mockFetch.calls.length, 2);
    assert.ok(String(mockFetch.calls[0].input).includes('geocode.maps.co'));
    assert.ok(String(mockFetch.calls[1].input).includes('maps.googleapis.com'));
    const [record] = app.locals.ingestionStore.all();
    assert.strictEqual(record.location.latitude, 47.6062);
    assert.strictEqual(record.location.longitude, -122.3321);
  } finally {
    mockFetch.restore();
  }
});

test('crawler listing ingestion keeps processing when geocoding fails', async () => {
  const mockFetch = createFetchMock([
    { error: new Error('network down') },
    {
      body: {
        status: 'ZERO_RESULTS',

thinking
**Planning admin endpoints and TDD approach**

I’m focusing on adding tests first for new admin API endpoints like listings, addresses, categories, and directories, as the instructions emphasize TDD. I want to review Task 32 and related spec files to understand the secure CRUD functionality and data models before designing tests and then implementing the code.
exec
bash -lc 'cat codex/TASKS/codex_phase_1b_2.yaml' in /var/home/rick/Development/mega-directory succeeded in 39ms:
project: mega-directory
version: 1.0
phases:
  - phase: 1
    description: Core system buildout — listings pipeline, directory structure, admin tools, crawler, API, and frontend delivery

    components:
      api_server:
        language: TypeScript
        framework: Node/Express
        deployment: Railway
        endpoints:
          - listings: [GET, POST, PUT, DELETE]
          - addresses: [GET, POST, PUT, DELETE]
          - categories: [GET, POST, PUT, DELETE]
          - directory_pages: [GET, POST, PUT, DELETE]
          - directory_metadata: [GET, PUT]
        notes:
          - Postal, city, state/province, and country tables are loaded from external datasets.
          - Listings reference postal_code_id or city_id depending on geography.

thinking
**Preparing to implement admin API endpoints**
exec
bash -lc 'rg -n "categories" -n apps/api/src -n' in /var/home/rick/Development/mega-directory succeeded in 43ms:
apps/api/src/server.ts:395:    const categories = Array.from(new Set(savedRecords.map((record) => record.categorySlug)));
apps/api/src/server.ts:400:        categories

thinking
**Exploring data sources and types**
exec
bash -lc 'ls apps/api/types' in /var/home/rick/Development/mega-directory succeeded in 40ms:
express
jsonwebtoken

thinking
**Exploring type definitions and data models**
exec
bash -lc 'ls packages' in /var/home/rick/Development/mega-directory succeeded in 46ms:
shared-config

thinking
**Checking test setup and data structure**
exec
bash -lc "sed -n '1,200p' apps/admin/data/listings.js" in /var/home/rick/Development/mega-directory succeeded in 39ms:
module.exports = [
  {
    id: 'lst_nova_electric',
    businessName: 'Nova Electric Co.',
    category: 'Electricians',
    location: 'Brooklyn, NY',
    website: 'https://novaelectric.example.com',
    phone: '(347) 555-0112',
    summary: '24/7 emergency electricians covering every borough with rapid dispatch teams.',
    notes: 'Crawler ingestion flagged missing license number.',
    score: 82,
    status: 'pending',
    source: 'Crawler Feed A',
    submittedAt: '2024-05-22T09:30:00-04:00',
    lastUpdated: '2024-05-22T09:30:00-04:00',
  },
  {
    id: 'lst_green_canopy',
    businessName: 'Green Canopy Tree Care',
    category: 'Arborists',

thinking
**Checking admin app routes**
exec
bash -lc "sed -n '1,200p' apps/admin/index.js" in /var/home/rick/Development/mega-directory succeeded in 40ms:
const path = require('path');
const express = require('express');

const listingsRouter = require('./routes/listings');
const seoRouter = require('./routes/seo');
const categoryLocationsRouter = require('./routes/categoryLocations');
const directoryPagesRouter = require('./routes/directoryPages');

const app = express();
const port = process.env.PORT || 4000;

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.locals.appName = 'Mega Directory Admin';

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.get('/', (req, res) => {

thinking
**Investigating data storage for admin API**
exec
bash -lc "sed -n '1,200p' db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 41ms:
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function ensureDemoGeography() {
  const unitedStates = await prisma.country.upsert({
    where: { id: 233 },
    update: {
      name: 'United States',
      iso2: 'US',
      iso3: 'USA',
      numericCode: '840',
      phoneCode: '+1',
      capital: 'Washington D.C.',
      currency: 'USD',
      currencyName: 'United States dollar',
      currencySymbol: '$',
      region: 'Americas',
      subregion: 'Northern America',
      timezones: [
exec
bash -lc "sed -n '200,400p' db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 40ms:
      placeName: 'San Francisco',
      countryId: unitedStates.id,
      countryCode: 'US',
      stateId: californiaState.id,
      stateCode: 'CA',
      stateName: 'California',
      cityId: sfCity.id,
      latitude: 37.7898,
      longitude: -122.3942,
      accuracy: 1
    }
  });

  return {
    country: unitedStates,
    states: {
      ny: newYorkState,
      ca: californiaState
    },
    cities: {

thinking
**Reviewing database schema alignment**
exec
bash -lc "sed -n '1,200p' db/schema.prisma" in /var/home/rick/Development/mega-directory succeeded in 40ms:
generator client {
  provider = "prisma-client-js"
}



datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ListingStatus {
  PENDING
  APPROVED
  REJECTED
  INACTIVE
}

enum DirectoryStatus {
  DRAFT

thinking
**Examining API server and test coverage**
exec
bash -lc "sed -n '1,200p' codex/LOGS/tasklog_32_create_admin_api_endpoints_for_listings_addresses_categories_directories_1762954603.log" in /var/home/rick/Development/mega-directory succeeded in 40ms:
OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a7848-6db2-7b30-ad31-e69f331403ca
--------
user
Implement the functionality described in codex/TASKS/32_create_admin_api_endpoints_for_listings_addresses_categories_directories.yaml, then verify with any available tests.
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:

thinking
**Examining additional logs**
exec
bash -lc "sed -n '200,400p' codex/LOGS/tasklog_32_create_admin_api_endpoints_for_listings_addresses_categories_directories_1762954603.log" in /var/home/rick/Development/mega-directory succeeded in 42ms:
  });
}

if (require.main === module) {
  startServer();
}
exec
bash -lc "sed -n '400,800p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 40ms:
        categories
      },
      'Accepted crawler listings batch'
    );

    return res.status(202).json({
      ingestedCount: savedRecords.length,
      ingested: savedRecords.map(({ id, title, slug, status, categorySlug, ingestedAt }) => ({
        id,
        title,
        slug,
        status,

thinking
**Preparing to implement admin API endpoints**
exec
bash -lc 'ls tests' in /var/home/rick/Development/mega-directory succeeded in 40ms:
dev_bootstrap_test.sh
directory_pages_schema.test.js
listings_table_enhancements.test.js

thinking
**Preparing data structures for new API endpoints**
exec
bash -lc "sed -n '1,200p' apps/admin/data/directoryPages.js" in /var/home/rick/Development/mega-directory succeeded in 41ms:
module.exports = [
  {
    id: 'dir_electricians_nyc',
    title: 'Top Electricians in New York City',
    slug: 'nyc-electricians',
    categoryId: 'cat_electricians',
    locationId: 'loc_new_york_ny',
    locationAgnostic: false,
    subdomain: 'nyc-electricians',
    subdirectory: 'nyc/electricians',
    heroTitle: 'Trusted NYC Electricians',
    heroSubtitle: 'Hire vetted pros across all five boroughs',
    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
    metaTitle: 'Best Electricians in NYC | Mega Directory',
    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
    metaKeywords: 'electricians,nyc,licensed,emergency',
    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
    status: 'ACTIVE',
    isActive: true,
    createdAt: '2024-05-10T14:20:00-04:00',

thinking
**Checking related data structures**
exec
bash -lc "sed -n '1,200p' apps/admin/data/categoryLocations.js" in /var/home/rick/Development/mega-directory succeeded in 40ms:
module.exports = [
  {
    id: 'dir_electricians_nyc',
    category: 'Electricians',
    location: 'New York, NY',
    slug: 'nyc/electricians',
    listingsCount: 24,
    source: 'Manual seed',
    approvedAt: '2024-05-20T11:15:00-04:00',
    status: 'active'
  },
  {
    id: 'dir_plumbers_atlanta',
    category: 'Plumbers',
    location: 'Atlanta, GA',
    slug: 'atlanta-ga/plumbers',
    listingsCount: 17,
    source: 'Crawler Run 412',
    approvedAt: '2024-05-19T15:45:00-04:00',
    status: 'active'

thinking
**Designing admin RESTful API endpoints**
exec
bash -lc 'rg -n "admin api" -n' in /var/home/rick/Development/mega-directory succeeded in 46ms:
codex/LOGS/tasklog_32_create_admin_api_endpoints_for_listings_addresses_categories_directories_1762954603.log:698:bash -lc 'rg -n "admin api" -n' in /var/home/rick/Development/mega-directory

thinking
**Checking docs directory**
exec
bash -lc 'ls docs' in /var/home/rick/Development/mega-directory succeeded in 40ms:
AGENTS.md
codex_tasks_bundle.zip
codex_tasks_detailed_final.zip
deployment
development_phase_1b_final.pdf
development_phase_1b.md
development_phase_1b_tasks.pdf
monitoring.md

thinking
**Checking development phase document**
exec
bash -lc 'rg -n "admin" docs/development_phase_1b.md' in /var/home/rick/Development/mega-directory succeeded in 40ms:
9:Rather than automatically generating directories from categories and locations, which could get messy if we try to have the system create all the permutations, furthermore, there will be significant SEO infomation that must be provided when creating a single directory page. So, we'll need a table to represent the individual directory pages. This way we can create directories that perhaps present more than one category or more than one postal code or city when these groupings represent very small amounts of listings or for whatever reason it makes sense to group or not group these together. The directory page can have its own title to concatenate with the site name to generate the content for the <title> tag and meta title, it can have an editable field for meta keywords, a field where the admin can specify the specific subdomain and the subdirectory used to represent the directory (based on the site configuration either the subdomain will 301 redirect to the subdirectory or the subdirectory to the subdomain, either way it should be possible for the admin to supply independent values for each of these), further meta tag values should include the description, og:image, etc. While the main site configuration should provide default values for these, it is important that it be possible to override them on individual directories.
54:I was thinking things over and I think it might be a good idea, maybe as a phase 2, and not until we have everything else working, but I would like to allow for the creation of user accounts. This would allow some interesting functionality that could encourage users to share links to our directories generating significant organic traffic. I envision a user creation system similar to reddit where upon using a function of the site requiring a login, the site should automatically generate an account stub, offering the user a unique token and automatically generated username they can store and use to restore their session the next time they visit the site. Along with the presentation of the token, the user should also be given the option to optionally supply their own username, email address, and password. Users who supply only an email will be assigned the generated username, if they supply a username that username will be assigned and they will be able to login at a later date by entering either their email address or their username, this will bring them to a form where they can enter a code which will be sent to their email address at each login. Once logged in, these users will be able to create a password from the admin panel at any time in the future. Users who supply a password will be able to login using their email or username / password pair on their next visit. I think this workflow overcomes many of the psychological barriers to joining websites since there are so many different ways to end up with an account. None requiring all of the steps be completed at once like traditional website registration.
98:### Should geolocation be triggered automatically after a listing with address is saved, or should it be manual/admin-triggered?
152:Great — I’ll generate a full Codex task set (around 20 tasks) based on the complete updated functionality we’ve outlined, including all aspects from directory pages and geographic structuring to crawler design, admin review flow, and phased-in user accounts.

thinking
**Reviewing initial documentation segment**
exec
bash -lc "sed -n '1,200p' docs/development_phase_1b.md" in /var/home/rick/Development/mega-directory succeeded in 40ms:
# Development Phase 1 part B

The initial 20 codex tasks have been completed, and this has provided a solid base for the project. However, the project still falls short of a fully functioning application with all of the necessary moving parts. I'm sure this is because I failed to flesh out all of the details regarding the various workflows as I was particulary focused on the architecture. No problem, because this architecture is exactly what will make all of the remaining added functionality possible. 

We need to plan out some further development additions and refinements. It appears the api is missing a number of operations, but it seems the important base functionality is there so it shouldn't be a huge problem. I wanted to rethink some of the ways things work. Let's first of all think about the structure of the data. 

## Directory Pages

Rather than automatically generating directories from categories and locations, which could get messy if we try to have the system create all the permutations, furthermore, there will be significant SEO infomation that must be provided when creating a single directory page. So, we'll need a table to represent the individual directory pages. This way we can create directories that perhaps present more than one category or more than one postal code or city when these groupings represent very small amounts of listings or for whatever reason it makes sense to group or not group these together. The directory page can have its own title to concatenate with the site name to generate the content for the <title> tag and meta title, it can have an editable field for meta keywords, a field where the admin can specify the specific subdomain and the subdirectory used to represent the directory (based on the site configuration either the subdomain will 301 redirect to the subdirectory or the subdirectory to the subdomain, either way it should be possible for the admin to supply independent values for each of these), further meta tag values should include the description, og:image, etc. While the main site configuration should provide default values for these, it is important that it be possible to override them on individual directories.

It should also be a configuration option of the directory page whether the directory page should be location agnostic or not. If the directory page is NOT location agnostic, it should be relatively easy to provide a map widget displaying pins for each of the listings on the page. The user interface for this type of page could also include a pin icon at the end of the listing title that when clicked will cause the map widget to center on that listing. 

## Listing Locations and other Geographic Data

### Listing and physical_address tables

While we will be collecting a bunch of listings which are associated with various categories and locations. For some listings it may actually make sense to associate them with more than one category. It may even make sense to associate some listings with multiple addresses, but addresses should be associated only with a single listing (1234 some st. suite 1 and 1234 some st. suite 2 are separate addresses) So the *physical_address* table should have a foreign key on the *listing* table while listings and categories should be related via a join table.


### Country -> State/Province -> City -> Postal Data Structure

thinking
**Designing RESTful admin endpoints and data stores**

I'm working out a plan to build CRUD RESTful endpoints for listings, addresses, categories, and directory pages, using in-memory data stores since no DB is specified. I need to define resource fields, support nested creations like listings with addresses and categories, enforce admin auth, validate payloads, and create tests that check authorization and functionality. To keep code manageable, I’m considering modularizing the store logic, and I’m about to create a multi-step plan for implementing and verifying these admin features.
Plan update
  → Add test coverage for admin CRUD endpoints covering listings, nested addresses, categories, and directories.
  • Implement admin data stores, validation helpers, and Express routes to satisfy new tests.
  • Run relevant test suites and perform any necessary fixes.



thinking
**Designing comprehensive admin tests**

I’m mapping out detailed test scenarios to cover all admin CRUD endpoints with auth, payload validation, nested relations, slug uniqueness, and data seeding, ensuring consistency between stores for categories, directories, listings, and addresses before implementing.
thinking
**Planning admin routes and robust handlers**

I’m organizing implementation details for admin stores, route handlers, validations, and authorization—covering CRUD logic with consistent data shape, nested relations, unique slug checks, partial updates, and error handling to ensure a thorough and maintainable API.
thinking
**Drafting detailed admin API integration tests**

I’m composing comprehensive tests covering listings with nested addresses and category validation, directories with metadata updates, and delicate response handling for delete operations, making sure routes respond correctly and data relations stay consistent.
exec
bash -lc /bin/ls in /var/home/rick/Development/mega-directory succeeded in 41ms:
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
env.json
Makefile
package.json
packages
README.md
scripts
tests
tsconfig.json

thinking
**Preparing to edit test file**

thinking
**Resolving patch application issues**
exec
bash -lc 'rg -n "function runRoute" -n apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory succeeded in 56ms:
119:async function runRoute(route, req, res) {

thinking
**Inspecting runRoute code segment**
exec
bash -lc "sed -n '100,200p' apps/api/test/server.test.js" in /var/home/rick/Development/mega-directory succeeded in 42ms:
    headers: {},
    body: null,
    finished: false,
    status(code) {
      this.statusCode = code;
      return this;
    },
    json(payload) {
      this.body = payload;
      this.finished = true;
      return this;
    },
    set(field, value) {
      this.headers[field.toLowerCase()] = value;
      return this;
    }
  };
}

async function runRoute(route, req, res) {

thinking
**Preparing to insert helper function**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -160,2 +160,13 @@
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..c55e44d15c10ec202a32bf02b7fb8dd0023d4257
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..c55e44d15c10ec202a32bf02b7fb8dd0023d4257
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');


thinking
**Preparing to append tests**
exec
bash -lc 'tail -n 40 apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory succeeded in 44ms:
  assert.strictEqual(metadata.event, 'listings.ingested');
  assert.strictEqual(metadata.ingestedCount, 1);
  assert.deepStrictEqual(metadata.categories, ['electricians']);
});

test('crawler listing ingestion validates payload shape and reports errors', async () => {
  const app = createServer(baseConfig);
  const route = findRoute(app, 'post', '/v1/crawler/listings');
  const payload = {
    listings: [
      buildListingPayload({ title: '  ', categorySlug: 'electricians' }),
      { title: 'Missing category' }
    ]
  };
  const req = createRequest({
    method: 'POST',
    headers: { Authorization: `Bearer ${baseConfig.crawlerBearerToken}` },
    body: payload
  });
  const res = await runRoute(route, req, createResponse());
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..c55e44d15c10ec202a32bf02b7fb8dd0023d4257
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');


thinking
**Adding new tests with apply_patch**
file update
M /var/home/rick/Development/mega-directory/apps/api/test/server.test.js
@@ -543 +543,234 @@
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M apps/api/test/server.test.js
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Planning test execution to confirm failures**

I'm thinking about running `npm test` now to confirm the new tests fail as expected before implementing the features, following TDD principles. This will help ensure the tests are properly triggering failures due to missing functionality.
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory exited 1 in 3.93s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 157.733718
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 155.329716
  type: 'test'
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Analyzing test failures and planning updates**
Plan update
  ✓ Add test coverage for admin CRUD endpoints covering listings, nested addresses, categories, and directories.
  → Implement admin data stores, validation helpers, and Express routes to satisfy new tests.
  • Run relevant test suites and perform any necessary fixes.
file update:
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});




thinking
**Planning detailed admin store and API implementation**

This plan breaks down extending types, creating helpers, seeding data, and building thorough CRUD handlers for categories, listings, addresses, and directories with careful validation, sanitization, auth middleware reuse, and nested data support. I'll implement strong TypeScript typing and route setup to fit these new admin features comprehensively.
thinking
**Outlining validations, route setup, and type augmentations for admin API**

I'm preparing detailed plans for address validation, ID normalization, extended type definitions, and streamlined admin route registrations with shared auth middleware. This includes rigorous payload checks, enhancing AppLocals, and organizing route handlers modularly to keep server.ts maintainable and fully typed.
thinking
**Detailing address handling, route specifics, and update strategy**

I’m mapping out address replacements with primary enforcement, precise field validation tracking, and route behaviors for addresses and directories. Also, I plan how to apply extensive type and handler additions incrementally using patches for easier management and smooth TypeScript integration.
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -11,3 +11,5 @@
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
@@ -50,2 +52,80 @@
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..fba378878eab1a041af9da8067c4e886cbd5627f
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..fba378878eab1a041af9da8067c4e886cbd5627f
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Updating AppLocals interface**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -168,2 +168,3 @@
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ae7fce824522caaaeef92db8eead713db3e1248f
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ae7fce824522caaaeef92db8eead713db3e1248f
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Updating server locals with adminStore**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -249,2 +249,3 @@
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..0e3f173ee3e7d1b3a153f87dfef4ce1d02ac7e7e
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,6 +247,7 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..0e3f173ee3e7d1b3a153f87dfef4ce1d02ac7e7e
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,6 +247,7 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Inserting authentication middleware and updating routes**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -256,2 +256,5 @@
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
@@ -270,3 +273,3 @@
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
@@ -274,3 +277,3 @@
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
@@ -278,7 +281,5 @@
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9e3fb26fe6ff8f1e41b8fa0fc81bc8dbc9a909c0
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9e3fb26fe6ff8f1e41b8fa0fc81bc8dbc9a909c0
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Planning admin store and routes implementation**
exec
bash -lc "sed -n '440,620p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 43ms:
      logger.warn(
        {
          event: 'listings.ingest.invalid',
          reason: 'validation-failed',
          failures: invalidEntries.length
        },
        'Rejected crawler listings batch due to validation errors'
      );
      return res.status(400).json({ error: 'Invalid listing payload', details: invalidEntries });
    }

    const geocodeConfig = {
      geocodeMapsApiKey: config.geocodeMapsApiKey,
      googleGeocodeApiKey: config.googleGeocodeApiKey
    };

    const enrichedEntries = await Promise.all(
      validEntries.map(async ({ index, value }) => {
        if (value.location) {
          const coords = await geocodeListingLocation(value.location, geocodeConfig, logger);
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9e3fb26fe6ff8f1e41b8fa0fc81bc8dbc9a909c0
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});



thinking
**Designing comprehensive admin store and routes**
thinking
**Preparing admin store and route registration functions**

I'm drafting the createAdminStore function with fully populated sample data, ensuring linked IDs and timestamps are consistent. Next, I'm outlining the registerAdminRoutes function to attach all admin route groups neatly, planning to insert this large carefully crafted block via an apply_patch after createListingStore to keep the code organized and manageable.
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -598,2 +598,1222 @@
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean; allowPartial?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..8c0292225df4fdb7151991cf640843d72f724a15
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean; allowPartial?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..8c0292225df4fdb7151991cf640843d72f724a15
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean; allowPartial?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Reviewing TypeScript optional chaining and unused options**
exec
bash -lc 'cat apps/api/tsconfig.json' in /var/home/rick/Development/mega-directory succeeded in 40ms:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "tsBuildInfoFile": "dist/.tsbuildinfo",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "typeRoots": [
      "./types",
      "node_modules/@types",
      "../web/node_modules/@types"
    ]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["dist", "node_modules", "test"]
}
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..8c0292225df4fdb7151991cf640843d72f724a15
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean; allowPartial?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Checking root TypeScript configuration**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/mega-directory succeeded in 39ms:
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true
  }
}
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..8c0292225df4fdb7151991cf640843d72f724a15
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean; allowPartial?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Cleaning up validateAddressObject options**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1537,3 +1537,3 @@
   payload: unknown,
-  options: { requireDetail?: boolean; allowPartial?: boolean } = {}
+  options: { requireDetail?: boolean } = {}
 ): AddressValidationResult {
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..08e69cfc4a32f4c89095094dfc33e58f327cfb7c
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..08e69cfc4a32f4c89095094dfc33e58f327cfb7c
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { allowPartial: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Updating call site with new options**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1021,3 +1021,3 @@
     }
-    const validation = validateAddressObject(req.body, { allowPartial: true });
+    const validation = validateAddressObject(req.body, { requireDetail: false });
     if (!validation.valid) {
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..1b40f5ee8885599ddaede79c29739db7df1caa6a
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..1b40f5ee8885599ddaede79c29739db7df1caa6a
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +271,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +596,1226 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Aligning address input types**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1695,2 +1695,19 @@
 
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
 function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9c24155a55a653b25c2c5f0d78d842963dd0169d
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,20 +271,18 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
 
+  registerAdminRoutes(app, adminAuth);
+
   return app;
 }
 
@@ -513,6 +596,1243 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9c24155a55a653b25c2c5f0d78d842963dd0169d
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,20 +271,18 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
 
+  registerAdminRoutes(app, adminAuth);
+
   return app;
 }
 
@@ -513,6 +596,1243 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const address = createAddressRecord(store, listing.id, validation.value);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Updating POST handler to use helper**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1000,3 +1000,4 @@
     }
-    const address = createAddressRecord(store, listing.id, validation.value);
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
     listing.addressIds.push(address.id);
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..6b5d067e903c9562c3dec17ae50a092713f3a934
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,20 +271,18 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
 
+  registerAdminRoutes(app, adminAuth);
+
   return app;
 }
 
@@ -513,6 +596,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..6b5d067e903c9562c3dec17ae50a092713f3a934
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,20 +271,18 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
 
+  registerAdminRoutes(app, adminAuth);
+
   return app;
 }
 
@@ -513,6 +596,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Verifying TypeScript address handling**
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory exited 2 in 3.41s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 147.947833
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 144.923468
  type: 'test'
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..6b5d067e903c9562c3dec17ae50a092713f3a934
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,20 +271,18 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
 
+  registerAdminRoutes(app, adminAuth);
+
   return app;
 }
 
@@ -513,6 +596,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Investigating missing HTTP methods on Express app type**
exec
bash -lc "nl -ba apps/api/src/server.ts | sed -n '720,780p'" in /var/home/rick/Development/mega-directory succeeded in 43ms:
   720	  });
   721	
   722	  app.post('/v1/admin/categories', adminAuth, (req, res) => {
   723	    const validation = validateCategoryPayload(req.body, 'create');
   724	    if (!validation.valid) {
   725	      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
   726	    }
   727	    const store = getAppLocals(app).adminStore;
   728	    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
   729	      return res
   730	        .status(400)
   731	        .json({ error: 'Validation failed', details: ['slug already exists'] });
   732	    }
   733	    const now = new Date().toISOString();
   734	    const record: CategoryRecord = {
   735	      id: store.nextCategoryId++,
   736	      name: validation.value.name!,
   737	      slug: validation.value.slug!,
   738	      description: validation.value.description ?? null,
   739	      metaTitle: validation.value.metaTitle ?? null,
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..6b5d067e903c9562c3dec17ae50a092713f3a934
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -9,7 +9,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +50,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +166,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +247,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,20 +271,18 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
 
+  registerAdminRoutes(app, adminAuth);
+
   return app;
 }
 
@@ -513,6 +596,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Adjusting Express type imports and usage**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1,2 +1,7 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Application,
+  type Express,
+  type Request,
+  type RequestHandler
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
@@ -695,3 +700,3 @@
 
-function registerAdminRoutes(app: Express, adminAuth: RequestHandler) {
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
   registerAdminCategoryRoutes(app, adminAuth);
@@ -702,3 +707,3 @@
 
-function registerAdminCategoryRoutes(app: Express, adminAuth: RequestHandler) {
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
   app.get('/v1/admin/categories', adminAuth, (_req, res) => {
@@ -820,3 +825,3 @@
 
-function registerAdminListingRoutes(app: Express, adminAuth: RequestHandler) {
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
   app.get('/v1/admin/listings', adminAuth, (_req, res) => {
@@ -966,3 +971,3 @@
 
-function registerAdminAddressRoutes(app: Express, adminAuth: RequestHandler) {
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
   app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
@@ -1092,3 +1097,3 @@
 
-function registerAdminDirectoryRoutes(app: Express, adminAuth: RequestHandler) {
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
   app.get('/v1/admin/directories', adminAuth, (_req, res) => {
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ed3379a576a0d00c0e771b682d2ef7418342800d
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,9 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Application,
+  type Express,
+  type Request,
+  type RequestHandler
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +14,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +55,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +171,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +252,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +276,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +601,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ed3379a576a0d00c0e771b682d2ef7418342800d
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,9 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Application,
+  type Express,
+  type Request,
+  type RequestHandler
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +14,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +55,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +171,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +252,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +276,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +601,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Verifying imports and running tests**
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory exited 2 in 3.41s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 148.31307
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 146.554363
  type: 'test'
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ed3379a576a0d00c0e771b682d2ef7418342800d
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,9 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Application,
+  type Express,
+  type Request,
+  type RequestHandler
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +14,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +55,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +171,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +252,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +276,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +601,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Resolving TypeScript import and typing issues**

I’m fixing errors by importing `Application` from `'express-serve-static-core'` instead of `'express'` and adding `Response` to imports from `'express'`. Then I plan to annotate each new route handler’s `req` and `res` parameters explicitly with proper types to satisfy strict TypeScript settings, carefully updating each handler for admin categories, listings, addresses, and directories routes.
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1,7 +1,8 @@
 import express, {
-  type Application,
   type Express,
   type Request,
-  type RequestHandler
+  type RequestHandler,
+  type Response
 } from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..6d47ab86526a2058c57af1400b136ffe9b1f4c27
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..6d47ab86526a2058c57af1400b136ffe9b1f4c27
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Annotating route handler parameters**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -709,3 +709,3 @@
 function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
-  app.get('/v1/admin/categories', adminAuth, (_req, res) => {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
     const store = getAppLocals(app).adminStore;
@@ -714,3 +714,3 @@
 
-  app.get('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
     const categoryId = parseIdParam(req.params?.categoryId);
@@ -727,3 +727,3 @@
 
-  app.post('/v1/admin/categories', adminAuth, (req, res) => {
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
     const validation = validateCategoryPayload(req.body, 'create');
@@ -754,3 +754,3 @@
 
-  app.put('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
     const categoryId = parseIdParam(req.params?.categoryId);
@@ -798,3 +798,3 @@
 
-  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req, res) => {
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
     const categoryId = parseIdParam(req.params?.categoryId);
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..b5dbd29fe8aa10ee5dd1a18e565d6acaefb2d342
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..b5dbd29fe8aa10ee5dd1a18e565d6acaefb2d342
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Annotating routes block**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -827,3 +827,3 @@
 function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
-  app.get('/v1/admin/listings', adminAuth, (_req, res) => {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
     const store = getAppLocals(app).adminStore;
@@ -833,3 +833,3 @@
 
-  app.get('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
     const listingId = parseIdParam(req.params?.listingId);
@@ -846,3 +846,3 @@
 
-  app.post('/v1/admin/listings', adminAuth, (req, res) => {
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
     const validation = validateAdminListingPayload(req.body, 'create');
@@ -889,3 +889,3 @@
 
-  app.put('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
     const listingId = parseIdParam(req.params?.listingId);
@@ -956,3 +956,3 @@
 
-  app.delete('/v1/admin/listings/:listingId', adminAuth, (req, res) => {
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
     const listingId = parseIdParam(req.params?.listingId);
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9b4635b0b149d3c9a7f39833ada87ecc505fc387
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9b4635b0b149d3c9a7f39833ada87ecc505fc387
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Annotating address routes**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -973,3 +973,3 @@
 function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
-  app.get('/v1/admin/addresses', adminAuth, (_req, res) => {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
     const store = getAppLocals(app).adminStore;
@@ -978,3 +978,3 @@
 
-  app.get('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
     const addressId = parseIdParam(req.params?.addressId);
@@ -991,3 +991,3 @@
 
-  app.post('/v1/admin/addresses', adminAuth, (req, res) => {
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
     const body = isPlainObject(req.body) ? req.body : {};
@@ -1018,3 +1018,3 @@
 
-  app.put('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
     const addressId = parseIdParam(req.params?.addressId);
@@ -1077,3 +1077,3 @@
 
-  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req, res) => {
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
     const addressId = parseIdParam(req.params?.addressId);
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9eaf742b2cad07f9b58a8392446231f298ac1956
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..9eaf742b2cad07f9b58a8392446231f298ac1956
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Annotating directory routes**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1099,3 +1099,3 @@
 function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
-  app.get('/v1/admin/directories', adminAuth, (_req, res) => {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
     const store = getAppLocals(app).adminStore;
@@ -1104,3 +1104,3 @@
 
-  app.get('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
     const directoryId = parseIdParam(req.params?.directoryId);
@@ -1117,3 +1117,3 @@
 
-  app.post('/v1/admin/directories', adminAuth, (req, res) => {
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
     const validation = validateDirectoryPayload(req.body, 'create');
@@ -1161,3 +1161,3 @@
 
-  app.put('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
     const directoryId = parseIdParam(req.params?.directoryId);
@@ -1240,3 +1240,3 @@
 
-  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req, res) => {
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
     const directoryId = parseIdParam(req.params?.directoryId);
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..0bbb0f16de16d07ca5f3ffb7b2ca2efeb2cdf71e
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..0bbb0f16de16d07ca5f3ffb7b2ca2efeb2cdf71e
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Verifying type imports and rerunning tests**
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory exited 2 in 3.41s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 146.38513
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 143.56247
  type: 'test'
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..0bbb0f16de16d07ca5f3ffb7b2ca2efeb2cdf71e
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response
+} from 'express';
+import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Switching to Router type from express**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -4,5 +4,5 @@
   type RequestHandler,
-  type Response
+  type Response,
+  type Router
 } from 'express';
-import type { Application } from 'express-serve-static-core';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
@@ -701,3 +701,3 @@
 
-function registerAdminRoutes(app: Application, adminAuth: RequestHandler) {
+function registerAdminRoutes(app: Router, adminAuth: RequestHandler) {
   registerAdminCategoryRoutes(app, adminAuth);
@@ -708,3 +708,3 @@
 
-function registerAdminCategoryRoutes(app: Application, adminAuth: RequestHandler) {
+function registerAdminCategoryRoutes(app: Router, adminAuth: RequestHandler) {
   app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
@@ -826,3 +826,3 @@
 
-function registerAdminListingRoutes(app: Application, adminAuth: RequestHandler) {
+function registerAdminListingRoutes(app: Router, adminAuth: RequestHandler) {
   app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
@@ -972,3 +972,3 @@
 
-function registerAdminAddressRoutes(app: Application, adminAuth: RequestHandler) {
+function registerAdminAddressRoutes(app: Router, adminAuth: RequestHandler) {
   app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
@@ -1098,3 +1098,3 @@
 
-function registerAdminDirectoryRoutes(app: Application, adminAuth: RequestHandler) {
+function registerAdminDirectoryRoutes(app: Router, adminAuth: RequestHandler) {
   app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..3fd2df705ac6b8e4ea3bcb5065ceff1e04f43e04
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response,
+  type Router
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Router, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..3fd2df705ac6b8e4ea3bcb5065ceff1e04f43e04
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response,
+  type Router
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Router, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Running tests again**
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory exited 2 in 3.44s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 149.433063
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 146.836157
  type: 'test'
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..3fd2df705ac6b8e4ea3bcb5065ceff1e04f43e04
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,10 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, {
+  type Express,
+  type Request,
+  type RequestHandler,
+  type Response,
+  type Router
+} from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +15,9 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +56,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +172,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +253,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +277,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +602,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: Router, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: Router, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Resolving Express type import issues**
file update
M /var/home/rick/Development/mega-directory/apps/api/src/server.ts
@@ -1,8 +1,2 @@
-import express, {
-  type Express,
-  type Request,
-  type RequestHandler,
-  type Response,
-  type Router
-} from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
@@ -17,2 +11,4 @@
 
+type ExpressApp = ReturnType<typeof express>;
+
 type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
@@ -701,3 +697,3 @@
 
-function registerAdminRoutes(app: Router, adminAuth: RequestHandler) {
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
   registerAdminCategoryRoutes(app, adminAuth);
@@ -708,3 +704,3 @@
 
-function registerAdminCategoryRoutes(app: Router, adminAuth: RequestHandler) {
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
   app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
@@ -826,3 +822,3 @@
 
-function registerAdminListingRoutes(app: Router, adminAuth: RequestHandler) {
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
   app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
@@ -972,3 +968,3 @@
 
-function registerAdminAddressRoutes(app: Router, adminAuth: RequestHandler) {
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
   app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
@@ -1098,3 +1094,3 @@
 
-function registerAdminDirectoryRoutes(app: Router, adminAuth: RequestHandler) {
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
   app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/api/src/server.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Verifying type accessibility and rerunning tests**
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory exited 2 in 3.42s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 148.864953
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 145.504896
  type: 'test'
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Investigating Express type definitions**
exec
bash -lc 'rg -n "interface Express" -n apps/api/node_modules/@types/express/index.d.ts' in /var/home/rick/Development/mega-directory exited 2 in 43ms:
rg: apps/api/node_modules/@types/express/index.d.ts: IO error for operation on apps/api/node_modules/@types/express/index.d.ts: No such file or directory (os error 2)
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Checking node_modules installation**
exec
bash -lc 'ls apps/api/node_modules' in /var/home/rick/Development/mega-directory succeeded in 40ms:
accepts
array-flatten
body-parser
buffer-equal-constant-time
bytes
call-bind-apply-helpers
call-bound
content-disposition
content-type
cookie
cookie-signature
debug
depd
destroy
dunder-proto
ecdsa-sig-formatter
ee-first
encodeurl
escape-html
es-define-property
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Checking for express types file**
exec
bash -lc 'rg -n "interface Express" apps/api/node_modules/@types/express/index.d.ts' in /var/home/rick/Development/mega-directory exited 2 in 42ms:
rg: apps/api/node_modules/@types/express/index.d.ts: IO error for operation on apps/api/node_modules/@types/express/index.d.ts: No such file or directory (os error 2)
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Checking for type definition files**
exec
bash -lc 'ls apps/api/node_modules/@types' in /var/home/rick/Development/mega-directory succeeded in 40ms:
debug
estree
fontkit
hast
mdast
ms
nlcst
node
unist
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Inspecting express type declarations**
exec
bash -lc "sed -n '1,80p' apps/api/node_modules/express/index.d.ts" in /var/home/rick/Development/mega-directory exited 2 in 43ms:
sed: can't read apps/api/node_modules/express/index.d.ts: No such file or directory
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Checking for TypeScript definitions in Express module**
exec
bash -lc 'ls apps/api/node_modules/express' in /var/home/rick/Development/mega-directory succeeded in 41ms:
History.md
index.js
lib
LICENSE
package.json
Readme.md
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Analyzing TypeScript express types resolution**
exec
bash -lc 'ls node_modules/@types' in /var/home/rick/Development/mega-directory exited 2 in 42ms:
ls: cannot access 'node_modules/@types': No such file or directory
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Analyzing type definitions in monorepo**
exec
bash -lc 'ls -a' in /var/home/rick/Development/mega-directory succeeded in 41ms:
.
..
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
.editorconfig
.env
.env.example
env.json
.git
.gitignore
Makefile
package.json
packages
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Investigating TypeScript type resolution**
exec
bash -lc 'ls apps/api/types' in /var/home/rick/Development/mega-directory succeeded in 51ms:
express
jsonwebtoken
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Inspecting custom type definitions**
exec
bash -lc 'ls apps/api/types/express' in /var/home/rick/Development/mega-directory succeeded in 47ms:
index.d.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});

exec
bash -lc "sed -n '1,200p' apps/api/types/express/index.d.ts" in /var/home/rick/Development/mega-directory succeeded in 46ms:
declare module 'express' {
  export interface Request {
    [key: string]: any;
    method: string;
    body?: any;
    headers?: Record<string, string | undefined>;
    get(name: string): string | undefined;
    header(name: string): string | undefined;
    originalUrl?: string;
    url?: string;
  }

  export interface Response {
    statusCode: number;
    status(code: number): this;
    json(body: any): this;
    set(field: string, value: string): this;
    on(event: string, handler: (...args: any[]) => void): this;
  }

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});


thinking
**Extending custom Express types**
file update
M /var/home/rick/Development/mega-directory/apps/api/types/express/index.d.ts
@@ -29,2 +29,4 @@
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M apps/api/types/express/index.d.ts
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 

file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Rerunning tests**
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory succeeded in 4.34s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 168.933083
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 170.642056
  type: 'test'
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Updating plan statuses after tests**
Plan update
  ✓ Add test coverage for admin CRUD endpoints covering listings, nested addresses, categories, and directories.
  ✓ Implement admin data stores, validation helpers, and Express routes to satisfy new tests.
  ✓ Run relevant test suites and perform any necessary fixes.
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Preparing final response**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/mega-directory succeeded in 47ms:
## main...origin/main [ahead 6]
 M .env.example
?? .editorconfig
?? .vscode/
?? apps/
?? codex/LOGS/codex_run_2025-11-12_06-13-21.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log.done
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log.done
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log.done
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log.done
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log.done
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log.done
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log.done
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Preparing detailed summary with file references**
exec
bash -lc 'rg -n "registerAdminRoutes" -n apps/api/src/server.ts' in /var/home/rick/Development/mega-directory succeeded in 51ms:
286:  registerAdminRoutes(app, adminAuth);
698:function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Preparing references for code changes**
exec
bash -lc 'rg -n "admin categories support" apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory succeeded in 48ms:
554:test('admin categories support CRUD with slug normalization', async () => {
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Searching for related test lines**
exec
bash -lc 'rg -n "admin listings support" apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory succeeded in 53ms:
621:test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Searching for admin directories test line**
exec
bash -lc 'rg -n "admin directories support" apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory succeeded in 46ms:
718:test('admin directories support creation and updates with category validation', async () => {
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Searching for admin categories endpoints**
exec
bash -lc 'rg -n "admin categories endpoints" apps/api/test/server.test.js' in /var/home/rick/Development/mega-directory succeeded in 44ms:
545:test('admin categories endpoints enforce auth', async () => {
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Preparing note on types file changes**
exec
bash -lc "nl -ba apps/api/types/express/index.d.ts | sed -n '1,80p'" in /var/home/rick/Development/mega-directory succeeded in 46ms:
     1	declare module 'express' {
     2	  export interface Request {
     3	    [key: string]: any;
     4	    method: string;
     5	    body?: any;
     6	    headers?: Record<string, string | undefined>;
     7	    get(name: string): string | undefined;
     8	    header(name: string): string | undefined;
     9	    originalUrl?: string;
    10	    url?: string;
    11	  }
    12	
    13	  export interface Response {
    14	    statusCode: number;
    15	    status(code: number): this;
    16	    json(body: any): this;
    17	    set(field: string, value: string): this;
    18	    on(event: string, handler: (...args: any[]) => void): this;
    19	  }
    20	
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Locating server file references**
exec
bash -lc 'rg -n "function createAdminStore" apps/api/src/server.ts' in /var/home/rick/Development/mega-directory succeeded in 46ms:
601:function createAdminStore(): AdminStore {
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 


thinking
**Summarizing code updates**

I'll detail the addition of the admin data store and endpoints with line references in `apps/api/src/server.ts`, updates to validations including nested addresses, changes to express types, and new tests with their locations. I'll note that tests ran successfully with `npm test` and suggest next steps like connecting to the persistence layer or integrating the admin UI.
codex
**Updates**
- Introduced an in-memory admin data store plus category/listing/address/directory CRUD routes with validation, slug normalization, category checks, nested address creation, and serialization for responses (`apps/api/src/server.ts:601`, `apps/api/src/server.ts:698`).
- Added comprehensive admin API tests covering auth enforcement, category CRUD, nested listing creation, and directory lifecycle to lock behavior before implementation (`apps/api/test/server.test.js:545`, `apps/api/test/server.test.js:554`, `apps/api/test/server.test.js:621`, `apps/api/test/server.test.js:718`).
- Extended the local Express type shim so our custom typings understand `put`/`delete`, keeping TypeScript happy without pulling extra packages (`apps/api/types/express/index.d.ts:1`).

**Tests**
- `npm test` (runs root tests plus every workspace, including `apps/api` build + test)
file update:
diff --git a/apps/api/src/server.ts b/apps/api/src/server.ts
index ad1746791d43ad699bb8bdb71cae214e83a483f7..ec7ba25665c5ecf6cd48e8793c3062b68eb84cbe
--- a/apps/api/src/server.ts
+++ b/apps/api/src/server.ts
@@ -1,4 +1,4 @@
-import express, { type Express, type Request, type RequestHandler } from 'express';
+import express, { type Express, type Request, type RequestHandler, type Response } from 'express';
 import jwt, { type JwtPayload } from 'jsonwebtoken';
 import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
 import { geocodeListingLocation, type GeocodingAddress } from './geocoding';
@@ -9,7 +9,11 @@
 const MAX_SLUG_LENGTH = 80;
 const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;
 
-type ListingStatus = 'INACTIVE' | 'ACTIVE';
+type ExpressApp = ReturnType<typeof express>;
+
+type ListingStatus = 'INACTIVE' | 'ACTIVE' | 'PENDING' | 'APPROVED' | 'REJECTED';
+
+type DirectoryStatus = 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
 
 type NullableString = string | null;
 
@@ -48,6 +52,84 @@
   all(): ListingRecord[];
 }
 
+interface AdminListingRecord {
+  id: number;
+  title: string;
+  slug: string;
+  status: ListingStatus;
+  summary: NullableString;
+  websiteUrl: NullableString;
+  sourceUrl: NullableString;
+  contactEmail: NullableString;
+  notes: NullableString;
+  sourceName: NullableString;
+  categoryIds: number[];
+  addressIds: number[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface ListingAddressRecord {
+  id: number;
+  listingId: number;
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface CategoryRecord {
+  id: number;
+  name: string;
+  slug: string;
+  description: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface DirectoryRecord {
+  id: number;
+  title: string;
+  slug: string;
+  subdomain: NullableString;
+  subdirectory: NullableString;
+  heroTitle: NullableString;
+  heroSubtitle: NullableString;
+  introMarkdown: NullableString;
+  metaTitle: NullableString;
+  metaDescription: NullableString;
+  metaKeywords: NullableString;
+  ogImageUrl: NullableString;
+  status: DirectoryStatus;
+  locationAgnostic: boolean;
+  categoryIds: number[];
+  locationIds: string[];
+  createdAt: string;
+  updatedAt: string;
+}
+
+interface AdminStore {
+  categories: CategoryRecord[];
+  directories: DirectoryRecord[];
+  listings: AdminListingRecord[];
+  addresses: ListingAddressRecord[];
+  nextCategoryId: number;
+  nextDirectoryId: number;
+  nextListingId: number;
+  nextAddressId: number;
+}
+
 interface ListingValidationSuccess {
   valid: true;
   value: NormalizedListing;
@@ -86,6 +168,7 @@
 interface AppLocals {
   config: ServerConfig;
   ingestionStore: ListingStore;
+  adminStore: AdminStore;
   logger: Logger;
   health: HealthState;
 }
@@ -166,12 +249,16 @@
 
   locals.config = config;
   locals.ingestionStore = createListingStore();
+  locals.adminStore = createAdminStore();
   locals.logger = logger;
   locals.health = { startedAt: new Date() };
 
   app.use(createRequestLogger(logger));
   app.use(express.json());
 
+  const adminAuth = requireAdminAuth(config);
+  const crawlerAuth = requireCrawlerToken(config);
+
   app.get('/health', (_req, res) => {
     const now = new Date();
     locals.health.lastCheck = now;
@@ -186,19 +273,17 @@
 
   app.post('/v1/admin/auth', createAdminAuthHandler(config));
 
-  app.get('/v1/admin/ping', requireAdminAuth(config), (_req, res) => {
+  app.get('/v1/admin/ping', adminAuth, (_req, res) => {
     res.json({ status: 'admin-ok' });
   });
 
-  app.post('/v1/crawler/ping', requireCrawlerToken(config), (_req, res) => {
+  app.post('/v1/crawler/ping', crawlerAuth, (_req, res) => {
     res.json({ status: 'crawler-ok' });
   });
 
-  app.post(
-    '/v1/crawler/listings',
-    requireCrawlerToken(config),
-    createListingIngestionHandler(app)
-  );
+  app.post('/v1/crawler/listings', crawlerAuth, createListingIngestionHandler(app));
+
+  registerAdminRoutes(app, adminAuth);
 
   return app;
 }
@@ -513,6 +598,1244 @@
   };
 }
 
+function createAdminStore(): AdminStore {
+  const now = () => new Date().toISOString();
+  const categories: CategoryRecord[] = [
+    {
+      id: 1,
+      name: 'Electricians',
+      slug: 'electricians',
+      description: 'Licensed electricians and electrical contractors.',
+      metaTitle: 'Electricians Directory',
+      metaDescription: 'Find trusted electricians for residential and commercial projects.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    },
+    {
+      id: 2,
+      name: 'Plumbers',
+      slug: 'plumbers',
+      description: 'Residential and commercial plumbing specialists.',
+      metaTitle: 'Plumbers Directory',
+      metaDescription: 'Top-rated plumbers for installs, repairs, and maintenance.',
+      isActive: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const directories: DirectoryRecord[] = [
+    {
+      id: 1,
+      title: 'NYC Electricians',
+      slug: 'nyc-electricians',
+      subdomain: 'nyc-electricians',
+      subdirectory: 'nyc/electricians',
+      heroTitle: 'Trusted NYC Electricians',
+      heroSubtitle: 'Emergency crews across every borough',
+      introMarkdown: 'Compare **licensed electricians** ready for EV chargers and emergency calls.',
+      metaTitle: 'Best Electricians in NYC | Mega Directory',
+      metaDescription: 'Hand-reviewed electricians serving Manhattan, Brooklyn, Queens, Bronx, and Staten Island.',
+      metaKeywords: 'electricians,nyc,licensed,emergency',
+      ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+      status: 'ACTIVE',
+      locationAgnostic: false,
+      categoryIds: [categories[0].id],
+      locationIds: ['loc_new_york_ny'],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const listings: AdminListingRecord[] = [
+    {
+      id: 1,
+      title: 'Nova Electric Co.',
+      slug: 'nova-electric-co',
+      status: 'PENDING',
+      summary: '24/7 emergency electricians covering NYC.',
+      websiteUrl: 'https://novaelectric.example.com',
+      sourceUrl: null,
+      contactEmail: 'contact@novaelectric.example.com',
+      notes: null,
+      sourceName: 'seed',
+      categoryIds: [categories[0].id],
+      addressIds: [],
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  const addresses: ListingAddressRecord[] = [
+    {
+      id: 1,
+      listingId: listings[0].id,
+      label: 'HQ',
+      addressLine1: '123 5th Ave',
+      addressLine2: null,
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10010',
+      country: 'US',
+      latitude: null,
+      longitude: null,
+      isPrimary: true,
+      createdAt: now(),
+      updatedAt: now()
+    }
+  ];
+  listings[0].addressIds.push(addresses[0].id);
+  return {
+    categories,
+    directories,
+    listings,
+    addresses,
+    nextCategoryId: categories.length + 1,
+    nextDirectoryId: directories.length + 1,
+    nextListingId: listings.length + 1,
+    nextAddressId: addresses.length + 1
+  };
+}
+
+function registerAdminRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  registerAdminCategoryRoutes(app, adminAuth);
+  registerAdminListingRoutes(app, adminAuth);
+  registerAdminAddressRoutes(app, adminAuth);
+  registerAdminDirectoryRoutes(app, adminAuth);
+}
+
+function registerAdminCategoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/categories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.categories.slice() });
+  });
+
+  app.get('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/categories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateCategoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.categories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const now = new Date().toISOString();
+    const record: CategoryRecord = {
+      id: store.nextCategoryId++,
+      name: validation.value.name!,
+      slug: validation.value.slug!,
+      description: validation.value.description ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      isActive: validation.value.isActive ?? true,
+      createdAt: now,
+      updatedAt: now
+    };
+    store.categories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.categories.find((entry) => entry.id === categoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    const validation = validateCategoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.categories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.name !== undefined) {
+      record.name = validation.value.name;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.description !== undefined) {
+      record.description = validation.value.description;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.isActive !== undefined) {
+      record.isActive = validation.value.isActive;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/categories/:categoryId', adminAuth, (req: Request, res: Response) => {
+    const categoryId = parseIdParam(req.params?.categoryId);
+    if (!categoryId) {
+      return res.status(400).json({ error: 'Invalid category id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.categories.findIndex((entry) => entry.id === categoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Category not found' });
+    }
+    store.categories.splice(index, 1);
+    const timestamp = new Date().toISOString();
+    store.listings.forEach((listing) => {
+      if (listing.categoryIds.includes(categoryId)) {
+        listing.categoryIds = listing.categoryIds.filter((id) => id !== categoryId);
+        listing.updatedAt = timestamp;
+      }
+    });
+    store.directories.forEach((directory) => {
+      if (directory.categoryIds.includes(categoryId)) {
+        directory.categoryIds = directory.categoryIds.filter((id) => id !== categoryId);
+        directory.updatedAt = timestamp;
+      }
+    });
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminListingRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/listings', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    const data = store.listings.map((listing) => serializeListing(store, listing));
+    res.json({ data });
+  });
+
+  app.get('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.post('/v1/admin/listings', adminAuth, (req: Request, res: Response) => {
+    const validation = validateAdminListingPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.listings.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const listing: AdminListingRecord = {
+      id: store.nextListingId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      status: validation.value.status ?? 'PENDING',
+      summary: validation.value.summary ?? null,
+      websiteUrl: validation.value.websiteUrl ?? null,
+      sourceUrl: validation.value.sourceUrl ?? null,
+      contactEmail: validation.value.contactEmail ?? null,
+      notes: validation.value.notes ?? null,
+      sourceName: validation.value.sourceName ?? null,
+      categoryIds: validation.value.categoryIds ?? [],
+      addressIds: [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.listings.push(listing);
+    if (validation.value.addresses && validation.value.addresses.length > 0) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    return res.status(201).json({ data: serializeListing(store, listing) });
+  });
+
+  app.put('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAdminListingPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.listings.some((entry) => entry.slug === validation.value.slug && entry.id !== listing.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      listing.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      listing.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      listing.slug = validation.value.slug;
+    }
+    if (validation.value.status) {
+      listing.status = validation.value.status;
+    }
+    if (validation.value.summary !== undefined) {
+      listing.summary = validation.value.summary;
+    }
+    if (validation.value.websiteUrl !== undefined) {
+      listing.websiteUrl = validation.value.websiteUrl;
+    }
+    if (validation.value.sourceUrl !== undefined) {
+      listing.sourceUrl = validation.value.sourceUrl;
+    }
+    if (validation.value.contactEmail !== undefined) {
+      listing.contactEmail = validation.value.contactEmail;
+    }
+    if (validation.value.notes !== undefined) {
+      listing.notes = validation.value.notes;
+    }
+    if (validation.value.sourceName !== undefined) {
+      listing.sourceName = validation.value.sourceName;
+    }
+    if (validation.value.addresses !== undefined) {
+      replaceListingAddresses(store, listing, validation.value.addresses);
+    }
+    listing.updatedAt = new Date().toISOString();
+    return res.json({ data: serializeListing(store, listing) });
+  });
+
+  app.delete('/v1/admin/listings/:listingId', adminAuth, (req: Request, res: Response) => {
+    const listingId = parseIdParam(req.params?.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Invalid listing id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.listings.findIndex((entry) => entry.id === listingId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    store.listings.splice(index, 1);
+    store.addresses = store.addresses.filter((address) => address.listingId !== listingId);
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminAddressRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/addresses', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.addresses.slice() });
+  });
+
+  app.get('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.addresses.find((entry) => entry.id === addressId);
+    if (!record) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/addresses', adminAuth, (req: Request, res: Response) => {
+    const body = isPlainObject(req.body) ? req.body : {};
+    const listingId = parseIdParam(body.listingId);
+    if (!listingId) {
+      return res.status(400).json({ error: 'Validation failed', details: ['listingId is required'] });
+    }
+    const store = getAppLocals(app).adminStore;
+    const listing = store.listings.find((entry) => entry.id === listingId);
+    if (!listing) {
+      return res.status(404).json({ error: 'Listing not found' });
+    }
+    const validation = validateAddressObject(body, { requireDetail: true });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const normalized = normalizeAddressForRecord(validation.value);
+    const address = createAddressRecord(store, listing.id, normalized);
+    listing.addressIds.push(address.id);
+    listing.updatedAt = new Date().toISOString();
+    if (address.isPrimary) {
+      setPrimaryAddress(store, listing.id, address.id);
+    } else {
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(201).json({ data: address });
+  });
+
+  app.put('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const address = store.addresses.find((entry) => entry.id === addressId);
+    if (!address) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const validation = validateAddressObject(req.body, { requireDetail: false });
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (validation.value.label !== undefined) {
+      address.label = validation.value.label;
+    }
+    if (validation.value.addressLine1 !== undefined) {
+      address.addressLine1 = validation.value.addressLine1;
+    }
+    if (validation.value.addressLine2 !== undefined) {
+      address.addressLine2 = validation.value.addressLine2;
+    }
+    if (validation.value.city !== undefined) {
+      address.city = validation.value.city;
+    }
+    if (validation.value.region !== undefined) {
+      address.region = validation.value.region;
+    }
+    if (validation.value.postalCode !== undefined) {
+      address.postalCode = validation.value.postalCode;
+    }
+    if (validation.value.country !== undefined) {
+      address.country = validation.value.country ?? 'US';
+    }
+    if (validation.value.latitude !== undefined) {
+      address.latitude = validation.value.latitude;
+    }
+    if (validation.value.longitude !== undefined) {
+      address.longitude = validation.value.longitude;
+    }
+    if (validation.value.isPrimary !== undefined) {
+      if (validation.value.isPrimary) {
+        setPrimaryAddress(store, address.listingId, address.id);
+      } else {
+        address.isPrimary = false;
+        ensurePrimaryAddress(store, address.listingId);
+      }
+    }
+    if (!hasAddressDetails(address)) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: ['Address must include at least one location field']
+      });
+    }
+    address.updatedAt = new Date().toISOString();
+    return res.json({ data: address });
+  });
+
+  app.delete('/v1/admin/addresses/:addressId', adminAuth, (req: Request, res: Response) => {
+    const addressId = parseIdParam(req.params?.addressId);
+    if (!addressId) {
+      return res.status(400).json({ error: 'Invalid address id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.addresses.findIndex((entry) => entry.id === addressId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Address not found' });
+    }
+    const [removed] = store.addresses.splice(index, 1);
+    const listing = store.listings.find((entry) => entry.id === removed.listingId);
+    if (listing) {
+      listing.addressIds = listing.addressIds.filter((id) => id !== removed.id);
+      listing.updatedAt = new Date().toISOString();
+      ensurePrimaryAddress(store, listing.id);
+    }
+    return res.status(204).json({});
+  });
+}
+
+function registerAdminDirectoryRoutes(app: ExpressApp, adminAuth: RequestHandler) {
+  app.get('/v1/admin/directories', adminAuth, (_req: Request, res: Response) => {
+    const store = getAppLocals(app).adminStore;
+    res.json({ data: store.directories.slice() });
+  });
+
+  app.get('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    return res.json({ data: record });
+  });
+
+  app.post('/v1/admin/directories', adminAuth, (req: Request, res: Response) => {
+    const validation = validateDirectoryPayload(req.body, 'create');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    const store = getAppLocals(app).adminStore;
+    if (store.directories.some((entry) => entry.slug === validation.value.slug)) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    const categoryCheck = ensureCategoryIdsExist(
+      store,
+      validation.value.categoryIds ?? [],
+      'categoryIds'
+    );
+    if (!categoryCheck.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+    }
+    const now = new Date().toISOString();
+    const record: DirectoryRecord = {
+      id: store.nextDirectoryId++,
+      title: validation.value.title!,
+      slug: validation.value.slug!,
+      subdomain: validation.value.subdomain ?? null,
+      subdirectory: validation.value.subdirectory ?? null,
+      heroTitle: validation.value.heroTitle ?? null,
+      heroSubtitle: validation.value.heroSubtitle ?? null,
+      introMarkdown: validation.value.introMarkdown ?? null,
+      metaTitle: validation.value.metaTitle ?? null,
+      metaDescription: validation.value.metaDescription ?? null,
+      metaKeywords: validation.value.metaKeywords ?? null,
+      ogImageUrl: validation.value.ogImageUrl ?? null,
+      status: validation.value.status ?? 'DRAFT',
+      locationAgnostic: validation.value.locationAgnostic ?? false,
+      categoryIds: validation.value.categoryIds ?? [],
+      locationIds: validation.value.locationIds ?? [],
+      createdAt: now,
+      updatedAt: now
+    };
+    store.directories.push(record);
+    return res.status(201).json({ data: record });
+  });
+
+  app.put('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const record = store.directories.find((entry) => entry.id === directoryId);
+    if (!record) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    const validation = validateDirectoryPayload(req.body, 'update');
+    if (!validation.valid) {
+      return res.status(400).json({ error: 'Validation failed', details: validation.errors });
+    }
+    if (
+      validation.value.slug &&
+      store.directories.some((entry) => entry.slug === validation.value.slug && entry.id !== record.id)
+    ) {
+      return res
+        .status(400)
+        .json({ error: 'Validation failed', details: ['slug already exists'] });
+    }
+    if (validation.value.categoryIds !== undefined) {
+      const categoryCheck = ensureCategoryIdsExist(
+        store,
+        validation.value.categoryIds,
+        'categoryIds'
+      );
+      if (!categoryCheck.valid) {
+        return res.status(400).json({ error: 'Validation failed', details: categoryCheck.errors });
+      }
+      record.categoryIds = validation.value.categoryIds;
+    }
+    if (validation.value.title !== undefined) {
+      record.title = validation.value.title;
+    }
+    if (validation.value.slug) {
+      record.slug = validation.value.slug;
+    }
+    if (validation.value.subdomain !== undefined) {
+      record.subdomain = validation.value.subdomain;
+    }
+    if (validation.value.subdirectory !== undefined) {
+      record.subdirectory = validation.value.subdirectory;
+    }
+    if (validation.value.heroTitle !== undefined) {
+      record.heroTitle = validation.value.heroTitle;
+    }
+    if (validation.value.heroSubtitle !== undefined) {
+      record.heroSubtitle = validation.value.heroSubtitle;
+    }
+    if (validation.value.introMarkdown !== undefined) {
+      record.introMarkdown = validation.value.introMarkdown;
+    }
+    if (validation.value.metaTitle !== undefined) {
+      record.metaTitle = validation.value.metaTitle;
+    }
+    if (validation.value.metaDescription !== undefined) {
+      record.metaDescription = validation.value.metaDescription;
+    }
+    if (validation.value.metaKeywords !== undefined) {
+      record.metaKeywords = validation.value.metaKeywords;
+    }
+    if (validation.value.ogImageUrl !== undefined) {
+      record.ogImageUrl = validation.value.ogImageUrl;
+    }
+    if (validation.value.status) {
+      record.status = validation.value.status;
+    }
+    if (validation.value.locationAgnostic !== undefined) {
+      record.locationAgnostic = validation.value.locationAgnostic;
+    }
+    if (validation.value.locationIds !== undefined) {
+      record.locationIds = validation.value.locationIds;
+    }
+    record.updatedAt = new Date().toISOString();
+    return res.json({ data: record });
+  });
+
+  app.delete('/v1/admin/directories/:directoryId', adminAuth, (req: Request, res: Response) => {
+    const directoryId = parseIdParam(req.params?.directoryId);
+    if (!directoryId) {
+      return res.status(400).json({ error: 'Invalid directory id' });
+    }
+    const store = getAppLocals(app).adminStore;
+    const index = store.directories.findIndex((entry) => entry.id === directoryId);
+    if (index === -1) {
+      return res.status(404).json({ error: 'Directory not found' });
+    }
+    store.directories.splice(index, 1);
+    return res.status(204).json({});
+  });
+}
+
+function serializeListing(store: AdminStore, record: AdminListingRecord) {
+  const addresses = record.addressIds
+    .map((addressId) => store.addresses.find((addr) => addr.id === addressId))
+    .filter((addr): addr is ListingAddressRecord => Boolean(addr));
+  return {
+    ...record,
+    addresses
+  };
+}
+
+type CategoryPayloadMode = 'create' | 'update';
+
+interface CategoryPayloadSuccess {
+  valid: true;
+  value: {
+    name?: string;
+    slug?: string;
+    description?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    isActive?: boolean;
+  };
+}
+
+interface CategoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type CategoryPayloadResult = CategoryPayloadSuccess | CategoryPayloadFailure;
+
+function validateCategoryPayload(payload: unknown, mode: CategoryPayloadMode): CategoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const name = sanitizeNullableString(payload.name);
+  if (mode === 'create' && !name) {
+    errors.push('name is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? name;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const description = sanitizeNullableString(payload.description);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const isActive =
+    payload.isActive === undefined
+      ? undefined
+      : Boolean(payload.isActive);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      name: name ?? undefined,
+      slug: slug ?? undefined,
+      description,
+      metaTitle,
+      metaDescription,
+      isActive
+    }
+  };
+}
+
+type ListingPayloadMode = 'create' | 'update';
+
+interface ListingPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    status?: ListingStatus;
+    summary?: NullableString;
+    websiteUrl?: NullableString;
+    sourceUrl?: NullableString;
+    contactEmail?: NullableString;
+    notes?: NullableString;
+    sourceName?: NullableString;
+    categoryIds?: number[];
+    addresses?: NormalizedAddressInput[];
+  };
+}
+
+interface ListingPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type ListingPayloadResult = ListingPayloadSuccess | ListingPayloadFailure;
+
+interface NormalizedAddressInput {
+  label: NullableString;
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+  latitude: number | null;
+  longitude: number | null;
+  isPrimary: boolean;
+}
+
+function validateAdminListingPayload(payload: unknown, mode: ListingPayloadMode): ListingPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const status = sanitizeListingStatus(payload.status) ?? (mode === 'create' ? 'PENDING' : undefined);
+  if (mode === 'create' && !status) {
+    errors.push('status is required');
+  }
+  const websiteUrl = optionalUrl(payload.websiteUrl, 'websiteUrl', errors);
+  const sourceUrl = optionalUrl(payload.sourceUrl, 'sourceUrl', errors);
+  const contactEmail = optionalEmail(payload.contactEmail, 'contactEmail', errors);
+  const summary = sanitizeNullableString(payload.summary);
+  const notes = sanitizeNullableString(payload.notes);
+  const sourceName = sanitizeNullableString(payload.sourceName);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  if (mode === 'create' && (!categoryIds || categoryIds.length === 0)) {
+    errors.push('At least one category id is required');
+  }
+  const addresses = normalizeAddressList(payload.addresses, errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      status,
+      summary,
+      websiteUrl,
+      sourceUrl,
+      contactEmail,
+      notes,
+      sourceName,
+      categoryIds,
+      addresses
+    }
+  };
+}
+
+type DirectoryPayloadMode = 'create' | 'update';
+
+interface DirectoryPayloadSuccess {
+  valid: true;
+  value: {
+    title?: string;
+    slug?: string;
+    subdomain?: NullableString;
+    subdirectory?: NullableString;
+    heroTitle?: NullableString;
+    heroSubtitle?: NullableString;
+    introMarkdown?: NullableString;
+    metaTitle?: NullableString;
+    metaDescription?: NullableString;
+    metaKeywords?: NullableString;
+    ogImageUrl?: NullableString;
+    status?: DirectoryStatus;
+    locationAgnostic?: boolean;
+    categoryIds?: number[];
+    locationIds?: string[];
+  };
+}
+
+interface DirectoryPayloadFailure {
+  valid: false;
+  errors: string[];
+}
+
+type DirectoryPayloadResult = DirectoryPayloadSuccess | DirectoryPayloadFailure;
+
+function validateDirectoryPayload(payload: unknown, mode: DirectoryPayloadMode): DirectoryPayloadResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Payload must be an object'] };
+  }
+  const title = sanitizeNullableString(payload.title);
+  if (mode === 'create' && !title) {
+    errors.push('title is required');
+  }
+  const slugSource = sanitizeNullableString(payload.slug) ?? title;
+  const slug = slugSource ? slugify(slugSource) : null;
+  if (mode === 'create' && !slug) {
+    errors.push('slug is required');
+  } else if (slugSource && !slug) {
+    errors.push('slug is invalid');
+  }
+  const subdomain = sanitizeNullableString(payload.subdomain);
+  const subdirectory = sanitizeNullableString(payload.subdirectory);
+  if (mode === 'create' && !subdirectory) {
+    errors.push('subdirectory is required');
+  }
+  const heroTitle = sanitizeNullableString(payload.heroTitle);
+  const heroSubtitle = sanitizeNullableString(payload.heroSubtitle);
+  const introMarkdown = sanitizeNullableString(payload.introMarkdown);
+  const metaTitle = sanitizeNullableString(payload.metaTitle);
+  const metaDescription = sanitizeNullableString(payload.metaDescription);
+  const metaKeywords = sanitizeNullableString(payload.metaKeywords);
+  const ogImageUrl = optionalUrl(payload.ogImageUrl, 'ogImageUrl', errors);
+  const locationAgnostic =
+    payload.locationAgnostic === undefined ? undefined : Boolean(payload.locationAgnostic);
+  const status = sanitizeDirectoryStatus(payload.status) ?? (mode === 'create' ? 'DRAFT' : undefined);
+  const categoryIds =
+    payload.categoryIds === undefined
+      ? undefined
+      : normalizeIdArray(payload.categoryIds, 'categoryIds', errors);
+  const locationIds =
+    payload.locationIds === undefined
+      ? undefined
+      : normalizeStringArray(payload.locationIds, 'locationIds', errors);
+
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+
+  return {
+    valid: true,
+    value: {
+      title: title ?? undefined,
+      slug: slug ?? undefined,
+      subdomain,
+      subdirectory,
+      heroTitle,
+      heroSubtitle,
+      introMarkdown,
+      metaTitle,
+      metaDescription,
+      metaKeywords,
+      ogImageUrl,
+      status,
+      locationAgnostic,
+      categoryIds,
+      locationIds
+    }
+  };
+}
+
+interface AddressValidationSuccess {
+  valid: true;
+  value: {
+    label?: NullableString;
+    addressLine1?: NullableString;
+    addressLine2?: NullableString;
+    city?: NullableString;
+    region?: NullableString;
+    postalCode?: NullableString;
+    country?: NullableString;
+    latitude?: number | null;
+    longitude?: number | null;
+    isPrimary?: boolean;
+  };
+}
+
+interface AddressValidationFailure {
+  valid: false;
+  errors: string[];
+}
+
+type AddressValidationResult = AddressValidationSuccess | AddressValidationFailure;
+
+function validateAddressObject(
+  payload: unknown,
+  options: { requireDetail?: boolean } = {}
+): AddressValidationResult {
+  const errors: string[] = [];
+  if (!isPlainObject(payload)) {
+    return { valid: false, errors: ['Address payload must be an object'] };
+  }
+  const value: AddressValidationSuccess['value'] = {};
+  if ('label' in payload) {
+    value.label = sanitizeNullableString(payload.label);
+  }
+  if ('addressLine1' in payload) {
+    value.addressLine1 = sanitizeNullableString(payload.addressLine1);
+  }
+  if ('addressLine2' in payload) {
+    value.addressLine2 = sanitizeNullableString(payload.addressLine2);
+  }
+  if ('city' in payload) {
+    value.city = sanitizeNullableString(payload.city);
+  }
+  if ('region' in payload) {
+    value.region = sanitizeNullableString(payload.region);
+  }
+  if ('postalCode' in payload) {
+    value.postalCode = sanitizeNullableString(payload.postalCode);
+  }
+  if ('country' in payload) {
+    value.country = sanitizeNullableString(payload.country);
+  }
+  if ('latitude' in payload) {
+    value.latitude = parseOptionalNumber(payload.latitude, 'latitude', errors);
+  }
+  if ('longitude' in payload) {
+    value.longitude = parseOptionalNumber(payload.longitude, 'longitude', errors);
+  }
+  if ('isPrimary' in payload) {
+    value.isPrimary = Boolean(payload.isPrimary);
+  }
+  const hasDetails = hasAddressDetails({
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null
+  });
+  if (options.requireDetail && !hasDetails) {
+    errors.push('Address must include at least one location field');
+  }
+  if (errors.length > 0) {
+    return { valid: false, errors };
+  }
+  return { valid: true, value };
+}
+
+function normalizeAddressList(value: unknown, errors: string[]): NormalizedAddressInput[] | undefined {
+  if (value === undefined) {
+    return undefined;
+  }
+  if (!Array.isArray(value)) {
+    errors.push('addresses must be an array');
+    return undefined;
+  }
+  const normalized: NormalizedAddressInput[] = [];
+  value.forEach((entry, index) => {
+    const validation = validateAddressObject(entry, { requireDetail: true });
+    if (!validation.valid) {
+      validation.errors.forEach((msg) => errors.push(`addresses[${index}]: ${msg}`));
+      return;
+    }
+    const address: NormalizedAddressInput = {
+      label: validation.value.label ?? null,
+      addressLine1: validation.value.addressLine1 ?? null,
+      addressLine2: validation.value.addressLine2 ?? null,
+      city: validation.value.city ?? null,
+      region: validation.value.region ?? null,
+      postalCode: validation.value.postalCode ?? null,
+      country: validation.value.country ?? null,
+      latitude:
+        validation.value.latitude === undefined ? null : validation.value.latitude ?? null,
+      longitude:
+        validation.value.longitude === undefined ? null : validation.value.longitude ?? null,
+      isPrimary: validation.value.isPrimary ?? false
+    };
+    normalized.push(address);
+  });
+  return normalized;
+}
+
+function ensureCategoryIdsExist(
+  store: AdminStore,
+  ids: number[],
+  fieldName: string
+): { valid: boolean; errors?: string[] } {
+  const missing = ids.filter((id) => !store.categories.some((category) => category.id === id));
+  if (missing.length > 0) {
+    return {
+      valid: false,
+      errors: [`${fieldName} contains invalid category ids: ${missing.join(', ')}`]
+    };
+  }
+  return { valid: true };
+}
+
+function replaceListingAddresses(
+  store: AdminStore,
+  listing: AdminListingRecord,
+  addresses: NormalizedAddressInput[]
+) {
+  store.addresses = store.addresses.filter((address) => address.listingId !== listing.id);
+  listing.addressIds = [];
+  if (addresses.length === 0) {
+    return;
+  }
+  const normalized = enforcePrimaryAddress(addresses);
+  normalized.forEach((entry) => {
+    const created = createAddressRecord(store, listing.id, entry);
+    listing.addressIds.push(created.id);
+  });
+  ensurePrimaryAddress(store, listing.id);
+}
+
+function enforcePrimaryAddress(addresses: NormalizedAddressInput[]) {
+  const hasPrimary = addresses.some((address) => address.isPrimary);
+  if (hasPrimary) {
+    return addresses.map((address) => ({ ...address }));
+  }
+  return addresses.map((address, index) => ({
+    ...address,
+    isPrimary: index === 0
+  }));
+}
+
+function createAddressRecord(
+  store: AdminStore,
+  listingId: number,
+  address: NormalizedAddressInput
+): ListingAddressRecord {
+  const now = new Date().toISOString();
+  const record: ListingAddressRecord = {
+    id: store.nextAddressId++,
+    listingId,
+    label: address.label ?? null,
+    addressLine1: address.addressLine1 ?? null,
+    addressLine2: address.addressLine2 ?? null,
+    city: address.city ?? null,
+    region: address.region ?? null,
+    postalCode: address.postalCode ?? null,
+    country: address.country ?? 'US',
+    latitude: address.latitude ?? null,
+    longitude: address.longitude ?? null,
+    isPrimary: address.isPrimary,
+    createdAt: now,
+    updatedAt: now
+  };
+  store.addresses.push(record);
+  return record;
+}
+
+function normalizeAddressForRecord(
+  value: AddressValidationSuccess['value']
+): NormalizedAddressInput {
+  return {
+    label: value.label ?? null,
+    addressLine1: value.addressLine1 ?? null,
+    addressLine2: value.addressLine2 ?? null,
+    city: value.city ?? null,
+    region: value.region ?? null,
+    postalCode: value.postalCode ?? null,
+    country: value.country ?? null,
+    latitude: value.latitude === undefined ? null : value.latitude ?? null,
+    longitude: value.longitude === undefined ? null : value.longitude ?? null,
+    isPrimary: value.isPrimary ?? false
+  };
+}
+
+function setPrimaryAddress(store: AdminStore, listingId: number, addressId: number) {
+  store.addresses.forEach((address) => {
+    if (address.listingId === listingId) {
+      const isPrimary = address.id === addressId;
+      if (address.isPrimary !== isPrimary) {
+        address.isPrimary = isPrimary;
+        address.updatedAt = new Date().toISOString();
+      }
+    }
+  });
+}
+
+function ensurePrimaryAddress(store: AdminStore, listingId: number) {
+  const listingAddresses = store.addresses.filter((address) => address.listingId === listingId);
+  if (listingAddresses.length === 0) {
+    return;
+  }
+  const currentPrimary = listingAddresses.find((address) => address.isPrimary);
+  if (!currentPrimary) {
+    listingAddresses[0].isPrimary = true;
+    listingAddresses[0].updatedAt = new Date().toISOString();
+  }
+}
+
+function sanitizeListingStatus(value: unknown): ListingStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['INACTIVE', 'ACTIVE', 'PENDING', 'APPROVED', 'REJECTED'].includes(upper)
+    ? (upper as ListingStatus)
+    : null;
+}
+
+function sanitizeDirectoryStatus(value: unknown): DirectoryStatus | null {
+  if (typeof value !== 'string') {
+    return null;
+  }
+  const upper = value.toUpperCase();
+  return ['DRAFT', 'ACTIVE', 'ARCHIVED'].includes(upper) ? (upper as DirectoryStatus) : null;
+}
+
+function normalizeIdArray(value: unknown, fieldName: string, errors: string[]): number[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const ids: number[] = [];
+  value.forEach((entry, index) => {
+    const parsed = parseIdParam(entry);
+    if (!parsed) {
+      errors.push(`${fieldName}[${index}] must be a positive integer`);
+      return;
+    }
+    if (!ids.includes(parsed)) {
+      ids.push(parsed);
+    }
+  });
+  return ids;
+}
+
+function normalizeStringArray(value: unknown, fieldName: string, errors: string[]): string[] {
+  if (!Array.isArray(value)) {
+    errors.push(`${fieldName} must be an array`);
+    return [];
+  }
+  const seen = new Set<string>();
+  value.forEach((entry, index) => {
+    const normalized = sanitizeNullableString(entry);
+    if (!normalized) {
+      errors.push(`${fieldName}[${index}] must be a non-empty string`);
+      return;
+    }
+    if (!seen.has(normalized)) {
+      seen.add(normalized);
+    }
+  });
+  return Array.from(seen);
+}
+
+function parseOptionalNumber(value: unknown, fieldName: string, errors: string[]): number | null {
+  if (value === undefined || value === null || value === '') {
+    return null;
+  }
+  const parsed = typeof value === 'number' ? value : Number.parseFloat(String(value));
+  if (!Number.isFinite(parsed)) {
+    errors.push(`${fieldName} must be a valid number`);
+    return null;
+  }
+  return parsed;
+}
+
+function parseIdParam(value: unknown): number | null {
+  if (typeof value === 'number' && Number.isInteger(value) && value > 0) {
+    return value;
+  }
+  if (typeof value === 'string') {
+    const parsed = Number.parseInt(value, 10);
+    if (Number.isInteger(parsed) && parsed > 0) {
+      return parsed;
+    }
+  }
+  return null;
+}
+
+function hasAddressDetails(address: {
+  addressLine1: NullableString;
+  addressLine2: NullableString;
+  city: NullableString;
+  region: NullableString;
+  postalCode: NullableString;
+  country: NullableString;
+}) {
+  return Boolean(
+    address.addressLine1 ||
+      address.addressLine2 ||
+      address.city ||
+      address.region ||
+      address.postalCode ||
+      address.country
+  );
+}
+
 function slugify(value: string, maxLength = MAX_SLUG_LENGTH) {
   if (typeof value !== 'string') {
     return '';
diff --git a/apps/api/test/server.test.js b/apps/api/test/server.test.js
index c5e69a6baadeed506e8fd0f6c35449d150e2fd91..26a54a0aadd8dbdb3abc42f94702b9d8b43c6f8d
--- a/apps/api/test/server.test.js
+++ b/apps/api/test/server.test.js
@@ -158,6 +158,17 @@
   return logger;
 }
 
+function createAdminToken(config = baseConfig, overrides = {}) {
+  const secret = overrides.adminJwtSecret ?? config.adminJwtSecret;
+  const issuer = overrides.adminJwtIssuer ?? config.adminJwtIssuer;
+  const audience = overrides.adminJwtAudience ?? config.adminJwtAudience;
+  return jwt.sign(
+    { role: 'admin', sub: (config.adminLoginEmail || '').toLowerCase() || 'admin' },
+    secret,
+    { issuer, audience, expiresIn: '10m' }
+  );
+}
+
 test('health endpoint reports monitoring metadata', async () => {
   const app = createServer({ ...baseConfig, logger: createStubLogger() });
   const route = findRoute(app, 'get', '/health');
@@ -530,3 +541,236 @@
     createServer({ adminJwtSecret: 'only-admin' });
   }, /Missing required config value/);
 });
+
+test('admin categories endpoints enforce auth', async () => {
+  const app = createServer(baseConfig);
+  const route = findRoute(app, 'get', '/v1/admin/categories');
+  const res = await runRoute(route, createRequest(), createResponse());
+
+  assert.strictEqual(res.statusCode, 401);
+  assert.strictEqual(res.body.error, 'Admin token missing or invalid');
+});
+
+test('admin categories support CRUD with slug normalization', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const listRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const listRes = await runRoute(
+    listRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(Array.isArray(listRes.body.data));
+  assert.ok(listRes.body.data.length >= 2);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/categories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: { name: '  Solar Pros  ', description: 'Certified solar partners' }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'solar-pros');
+  assert.strictEqual(createRes.body.data.name, 'Solar Pros');
+  const createdId = createRes.body.data.id;
+
+  const detailRoute = findRoute(app, 'get', '/v1/admin/categories/:categoryId');
+  const detailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  detailReq.params = { categoryId: String(createdId) };
+  const detailRes = await runRoute(detailRoute, detailReq, createResponse());
+  assert.strictEqual(detailRes.statusCode, 200);
+  assert.strictEqual(detailRes.body.data.id, createdId);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/categories/:categoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { metaTitle: 'Updated Title', slug: 'solar-pros-custom' }
+  });
+  updateReq.params = { categoryId: String(createdId) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.metaTitle, 'Updated Title');
+  assert.strictEqual(updateRes.body.data.slug, 'solar-pros-custom');
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/categories/:categoryId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { categoryId: String(createdId) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const afterDeleteDetailReq = createRequest({ headers: { Authorization: `Bearer ${token}` } });
+  afterDeleteDetailReq.params = { categoryId: String(createdId) };
+  const afterDeleteDetailRes = await runRoute(
+    detailRoute,
+    afterDeleteDetailReq,
+    createResponse()
+  );
+  assert.strictEqual(afterDeleteDetailRes.statusCode, 404);
+});
+
+test('admin listings support nested addresses and propagate to addresses endpoints', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [firstCategory, secondCategory] = categoriesRes.body.data;
+  assert.ok(firstCategory);
+  assert.ok(secondCategory);
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/listings');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Atlas Electric',
+        summary: '24/7 electricians',
+        websiteUrl: 'https://atlas.example.com',
+        contactEmail: 'info@atlas.example.com',
+        status: 'PENDING',
+        categoryIds: [firstCategory.id],
+        addresses: [
+          {
+            label: 'HQ',
+            addressLine1: '123 5th Ave',
+            city: 'New York',
+            region: 'NY',
+            postalCode: '10010',
+            country: 'US',
+            isPrimary: true
+          },
+          {
+            label: 'Shop',
+            addressLine1: '456 Atlantic Ave',
+            city: 'Brooklyn',
+            region: 'NY',
+            postalCode: '11201',
+            country: 'US'
+          }
+        ]
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'atlas-electric');
+  assert.strictEqual(createRes.body.data.categoryIds[0], firstCategory.id);
+  assert.strictEqual(createRes.body.data.addresses.length, 2);
+  assert.ok(createRes.body.data.addresses.every((addr) => addr.listingId === createRes.body.data.id));
+
+  const addressesRoute = findRoute(app, 'get', '/v1/admin/addresses');
+  const addressesRes = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const linkedAddresses = addressesRes.body.data.filter(
+    (entry) => entry.listingId === createRes.body.data.id
+  );
+  assert.strictEqual(linkedAddresses.length, 2);
+  assert.ok(linkedAddresses.some((entry) => entry.isPrimary));
+
+  const updateListingRoute = findRoute(app, 'put', '/v1/admin/listings/:listingId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: { status: 'APPROVED', categoryIds: [firstCategory.id, secondCategory.id] }
+  });
+  updateReq.params = { listingId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateListingRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.body.data.status, 'APPROVED');
+  assert.strictEqual(updateRes.body.data.categoryIds.length, 2);
+
+  const deleteRoute = findRoute(app, 'delete', '/v1/admin/listings/:listingId');
+  const deleteReq = createRequest({
+    method: 'DELETE',
+    headers: { Authorization: `Bearer ${token}` }
+  });
+  deleteReq.params = { listingId: String(createRes.body.data.id) };
+  const deleteRes = await runRoute(deleteRoute, deleteReq, createResponse());
+  assert.strictEqual(deleteRes.statusCode, 204);
+
+  const addressesAfterDelete = await runRoute(
+    addressesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  assert.ok(!addressesAfterDelete.body.data.some((addr) => addr.listingId === createRes.body.data.id));
+});
+
+test('admin directories support creation and updates with category validation', async () => {
+  const app = createServer(baseConfig);
+  const token = createAdminToken(baseConfig);
+
+  const categoriesRoute = findRoute(app, 'get', '/v1/admin/categories');
+  const categoriesRes = await runRoute(
+    categoriesRoute,
+    createRequest({ headers: { Authorization: `Bearer ${token}` } }),
+    createResponse()
+  );
+  const [primaryCategory] = categoriesRes.body.data;
+  assert.ok(primaryCategory, 'expected seeded categories');
+
+  const createRoute = findRoute(app, 'post', '/v1/admin/directories');
+  const createRes = await runRoute(
+    createRoute,
+    createRequest({
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` },
+      body: {
+        title: 'Remote Support Pros',
+        locationAgnostic: true,
+        subdomain: 'support',
+        subdirectory: 'global/support',
+        heroTitle: 'Remote Support',
+        heroSubtitle: 'Top distributed teams',
+        introMarkdown: '**Remote-first** partners',
+        metaTitle: 'Remote Support Pros',
+        metaDescription: 'Trusted remote teams',
+        categoryIds: [primaryCategory.id],
+        locationIds: ['global']
+      }
+    }),
+    createResponse()
+  );
+
+  assert.strictEqual(createRes.statusCode, 201);
+  assert.strictEqual(createRes.body.data.slug, 'remote-support-pros');
+  assert.deepStrictEqual(createRes.body.data.categoryIds, [primaryCategory.id]);
+  assert.deepStrictEqual(createRes.body.data.locationIds, ['global']);
+
+  const updateRoute = findRoute(app, 'put', '/v1/admin/directories/:directoryId');
+  const updateReq = createRequest({
+    method: 'PUT',
+    headers: { Authorization: `Bearer ${token}` },
+    body: {
+      status: 'ACTIVE',
+      metaDescription: 'Expanded coverage',
+      categoryIds: [],
+      locationIds: ['north-america', 'global']
+    }
+  });
+  updateReq.params = { directoryId: String(createRes.body.data.id) };
+  const updateRes = await runRoute(updateRoute, updateReq, createResponse());
+  assert.strictEqual(updateRes.statusCode, 200);
+  assert.strictEqual(updateRes.body.data.status, 'ACTIVE');
+  assert.deepStrictEqual(updateRes.body.data.locationIds, ['north-america', 'global']);
+  assert.deepStrictEqual(updateRes.body.data.categoryIds, []);
+});
diff --git a/apps/api/types/express/index.d.ts b/apps/api/types/express/index.d.ts
index 7abb17738b0d077daf6d611c3da496ba9e28debc..de9c9e9ccc7e2f2a15902d61b11368fe1bbf69d1
--- a/apps/api/types/express/index.d.ts
+++ b/apps/api/types/express/index.d.ts
@@ -27,6 +27,8 @@
     use(path: string, ...handlers: RequestHandler[]): this;
     get(path: string, ...handlers: RequestHandler[]): this;
     post(path: string, ...handlers: RequestHandler[]): this;
+    put(path: string, ...handlers: RequestHandler[]): this;
+    delete(path: string, ...handlers: RequestHandler[]): this;
     listen(port: number, callback?: () => void): { close(): void };
   }
 

tokens used
281,244
**Updates**
- Introduced an in-memory admin data store plus category/listing/address/directory CRUD routes with validation, slug normalization, category checks, nested address creation, and serialization for responses (`apps/api/src/server.ts:601`, `apps/api/src/server.ts:698`).
- Added comprehensive admin API tests covering auth enforcement, category CRUD, nested listing creation, and directory lifecycle to lock behavior before implementation (`apps/api/test/server.test.js:545`, `apps/api/test/server.test.js:554`, `apps/api/test/server.test.js:621`, `apps/api/test/server.test.js:718`).
- Extended the local Express type shim so our custom typings understand `put`/`delete`, keeping TypeScript happy without pulling extra packages (`apps/api/types/express/index.d.ts:1`).

**Tests**
- `npm test` (runs root tests plus every workspace, including `apps/api` build + test)
