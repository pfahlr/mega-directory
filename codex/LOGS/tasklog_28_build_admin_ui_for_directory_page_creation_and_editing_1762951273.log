OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a7815-9b21-7a32-a923-7a79d47bdeed
--------
user
Implement the functionality described in codex/TASKS/28_build_admin_ui_for_directory_page_creation_and_editing.yaml, then verify with any available tests.
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX

thinking
**Checking for test instructions**
exec
bash -lc ls in /var/home/rick/Development/mega-directory succeeded in 40ms:
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
env.json
Makefile
package.json
packages
README.md
scripts
tests
tsconfig.json

thinking
**Inspecting admin UI task file**
exec
bash -lc 'cat codex/TASKS/28_build_admin_ui_for_directory_page_creation_and_editing.yaml' in /var/home/rick/Development/mega-directory succeeded in 40ms:
id: 28
filename: 28_build_admin_ui_for_directory_page_creation_and_editing.yaml
title: Build Admin UI for Directory Page Creation and Editing
description: >
- Develop a form-based admin interface to manage directory pages.
- Include fields for category/location linking, subdomain/subdirectory config, and all metadata fields.
- Support validation and save/deactivate toggles.
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
dependencies: []

thinking
**Preparing to explore admin interface**
exec
bash -lc 'ls apps' in /var/home/rick/Development/mega-directory succeeded in 41ms:
admin
api
crawler
web

thinking
**Reviewing admin structure**
exec
bash -lc 'ls apps/admin' in /var/home/rick/Development/mega-directory succeeded in 43ms:
data
index.js
node_modules
package.json
package-lock.json
public
routes
services
test
views

thinking
**Checking for Express usage**
exec
bash -lc 'cat apps/admin/package.json' in /var/home/rick/Development/mega-directory succeeded in 40ms:
{
  "name": "mega-directory-admin",
  "private": true,
  "version": "0.1.0",
  "main": "index.js",
  "scripts": {
    "dev": "node index.js",
    "start": "node index.js",
    "test": "node --test"
  },
  "dependencies": {
    "ejs": "^3.1.10",
    "express": "^4.19.2"
  }
}

thinking
**Checking existing routes**
exec
bash -lc 'ls apps/admin/routes' in /var/home/rick/Development/mega-directory succeeded in 40ms:
categoryLocations.js
listings.js
seo.js

thinking
**Checking need for directory page routes**
exec
bash -lc 'ls apps/admin/views' in /var/home/rick/Development/mega-directory succeeded in 41ms:
category-locations
errors
listings
partials
seo

thinking
**Examining route patterns for new view**
exec
bash -lc "sed -n '1,200p' apps/admin/routes/listings.js" in /var/home/rick/Development/mega-directory succeeded in 45ms:
const express = require('express');
const { getListings, updateListings } = require('../services/listingsService');

const router = express.Router();

router.get('/', (req, res) => {
  const page = parsePage(req.query.page);
  const result = getListings({ page });

  res.render('listings/index', {
    title: 'Listing Review',
    listings: result.records,
    savedCount: parseCount(req.query.saved),
    pagination: buildPagination(result)
  });
});

router.post('/', async (req, res, next) => {
  try {
    const updates = normalizePayload(req.body.listings);

thinking
**Searching for service definitions**
exec
bash -lc "sed -n '1,200p' apps/admin/services/listingsService.js" in /var/home/rick/Development/mega-directory succeeded in 41ms:
const listings = require('../data/listings');
const apiClient = require('./apiClient');

const ALLOWED_STATUSES = new Set(['pending', 'approved', 'deactivated']);
const DEFAULT_PER_PAGE = 50;
const MAX_PER_PAGE = 200;

function getListings({ page = 1, perPage = DEFAULT_PER_PAGE } = {}) {
  const normalizedPerPage = normalizePerPage(perPage);
  const total = listings.length;
  const totalPages = Math.max(1, Math.ceil(Math.max(total, 1) / normalizedPerPage));
  const normalizedPage = normalizePage(page, totalPages);
  const startIndex = total === 0 ? 0 : (normalizedPage - 1) * normalizedPerPage;
  const endIndex = total === 0 ? 0 : Math.min(startIndex + normalizedPerPage, total);

  return {
    records: total === 0 ? [] : listings.slice(startIndex, endIndex),
    total,
    page: normalizedPage,
    perPage: normalizedPerPage,

thinking
**Preparing to add new route and service**
exec
bash -lc 'ls apps/admin/data' in /var/home/rick/Development/mega-directory succeeded in 40ms:
categoryLocationDiscoveries.js
categoryLocations.js
listings.js
seoEntries.js

thinking
**Searching for directory data**
exec
bash -lc 'rg -n "directory" -n' in /var/home/rick/Development/mega-directory succeeded in 295ms:
package.json:2:  "name": "mega-directory",
packages/shared-config/README.md:1:# @mega-directory/config
packages/shared-config/README.md:6:const { PROJECT_NAME, DEFAULT_PORTS } = require('@mega-directory/config');
packages/shared-config/package.json:2:  "name": "@mega-directory/config",
apps/crawler/dev_runner.py:89:                "subdomain": "demo.megadirectory.local",
apps/crawler/dev_runner.py:106:    logger = logging.getLogger("mega_directory.dev_crawler")
apps/crawler/dev_runner.py:118:        description="Replay sample directory HTML into the local API so the dev stack has data."
apps/crawler/config/targets.schema.json:3:  "$id": "https://mega-directory.dev/schemas/crawler-targets.json",
apps/crawler/crawler.py:636:    logger = logging.getLogger("mega_directory.crawler")
apps/admin/package-lock.json:2:  "name": "mega-directory-admin",
apps/admin/package-lock.json:8:      "name": "mega-directory-admin",
tests/directory_pages_schema.test.js:30:test('directory_pages table exposes required metadata columns in snake_case', () => {
tests/directory_pages_schema.test.js:32:  const tableBlock = extractTableBlock(schema, 'directory_pages');
tests/directory_pages_schema.test.js:36:    { name: 'subdirectory', pattern: 'TEXT\\s+NOT\\s+NULL' },
apps/admin/package.json:2:  "name": "mega-directory-admin",
apps/admin/views/category-locations/index.ejs:7:      <p class="muted">Review crawler discoveries, then promote qualified combinations into the directory database.</p>
scripts/dev-bootstrap.sh:107:DATABASE_URL_VALUE="${DATABASE_URL:-postgresql://postgres:password@localhost:5432/mega_directory}"
AGENTS.md:55:Deliver ultra-fast directory pages optimized for SEO and accessibility.
codex.yaml:16:    path: codex/TASKS/06_frontend_directory_page_rendering.yaml
docker-compose.yml:11:      DATABASE_URL: postgresql://postgres:password@db:5432/mega_directory

thinking
**Reviewing admin UI requirements and tests**
exec
bash -lc 'ls apps/admin/test' in /var/home/rick/Development/mega-directory succeeded in 41ms:
categoryLocationService.test.js
listingsService.test.js
seoService.test.js

thinking
**Preparing to write tests for new service**
exec
bash -lc "sed -n '1,200p' apps/admin/test/seoService.test.js" in /var/home/rick/Development/mega-directory succeeded in 43ms:
const test = require('node:test');
const assert = require('node:assert/strict');

const seoStore = require('../data/seoEntries');
const { updateSeoEntries } = require('../services/seoService');

const originalStore = deepClone(seoStore);

function resetStore() {
  seoStore.splice(0, seoStore.length, ...deepClone(originalStore));
}

test('updateSeoEntries skips unchanged payloads but updates real edits', () => {
  resetStore();

  const target = seoStore[0];
  const originalTitle = target.metaTitle;
  const originalDescription = target.metaDescription;
  const originalTimestamp = target.lastUpdated;


thinking
**Preparing to add tests and routes**
exec
bash -lc "sed -n '1,200p' apps/admin/views/seo/index.ejs" in /var/home/rick/Development/mega-directory succeeded in 49ms:
<%- include('../partials/page-start', { title: 'SEO Field Editor', active: 'seo' }) %>
<section class="panel stack gap-md">
  <header class="panel-header">
    <div>
      <p class="eyebrow">SEO Toolkit</p>
      <h2>Category + location metadata</h2>
      <p class="muted">Refresh page titles and meta descriptions before publishing new directory pages.</p>
    </div>
    <div class="badge">Records <strong><%= totalEntries %></strong></div>
  </header>

  <% if (typeof savedCount === 'number') { %>
    <div class="alert success">Updated <strong><%= savedCount %></strong> SEO entr<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
  <% } %>

  <% if (!categories.length && !categoryLocations.length) { %>
    <p class="empty-state">No SEO fields available yet.</p>
  <% } else { %>
    <form method="POST" action="/seo" class="stack gap-lg">
      <% if (categories.length) { %>

thinking
**Preparing to design directory UI**
exec
bash -lc "sed -n '1,200p' apps/admin/index.js" in /var/home/rick/Development/mega-directory succeeded in 40ms:
const path = require('path');
const express = require('express');

const listingsRouter = require('./routes/listings');
const seoRouter = require('./routes/seo');
const categoryLocationsRouter = require('./routes/categoryLocations');

const app = express();
const port = process.env.PORT || 4000;

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.locals.appName = 'Mega Directory Admin';

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.get('/', (req, res) => {
  res.redirect('/listings');

thinking
**Planning directory page feature**
exec
bash -lc 'rg -ni "directory page" -n' in /var/home/rick/Development/mega-directory succeeded in 50ms:
AGENTS.md:55:Deliver ultra-fast directory pages optimized for SEO and accessibility.
docs/development_phase_1b.md:7:## Directory Pages
docs/development_phase_1b.md:9:Rather than automatically generating directories from categories and locations, which could get messy if we try to have the system create all the permutations, furthermore, there will be significant SEO infomation that must be provided when creating a single directory page. So, we'll need a table to represent the individual directory pages. This way we can create directories that perhaps present more than one category or more than one postal code or city when these groupings represent very small amounts of listings or for whatever reason it makes sense to group or not group these together. The directory page can have its own title to concatenate with the site name to generate the content for the <title> tag and meta title, it can have an editable field for meta keywords, a field where the admin can specify the specific subdomain and the subdirectory used to represent the directory (based on the site configuration either the subdomain will 301 redirect to the subdirectory or the subdirectory to the subdomain, either way it should be possible for the admin to supply independent values for each of these), further meta tag values should include the description, og:image, etc. While the main site configuration should provide default values for these, it is important that it be possible to override them on individual directories.
docs/development_phase_1b.md:11:It should also be a configuration option of the directory page whether the directory page should be location agnostic or not. If the directory page is NOT location agnostic, it should be relatively easy to provide a map widget displaying pins for each of the listings on the page. The user interface for this type of page could also include a pin icon at the end of the listing title that when clicked will cause the map widget to center on that listing. 
docs/development_phase_1b.md:40:We shouldn't need api endpoints to add/edit/delete values for the postal code, city, state/province, or country tables since these will be populated and stay fixed in the long term. But we will need add edit and delete functions for all of the following entities: listings, physical_addresses, categories, directory pages
docs/development_phase_1b.md:78:## Directory Pages: Should a directory page be able to display listings across multiple unrelated categories (e.g. "Jobs" and "Real Estate" together)?
docs/development_phase_1b.md:82:## Should directory pages be manually created only, or should the crawler ever propose new directory pages for review?
docs/development_phase_1b.md:127:## Subdomain vs Subdirectory: The spec allows both a subdomain and a subdirectory for a directory page. Clarify the desired behavior (e.g. should one always redirect to the other?). Implementation could simply enforce a canonical structure, but decide whether the primary path is the subdomain or the directory URL.
docs/development_phase_1b.md:136:## Multiple Addresses: If a listing has multiple addresses, should all be displayed on the listing detail page, and should the listing appear under each relevant location-based directory page? (Likely yes.) Plan how to handle multiple map pins for one listing if needed.
docs/development_phase_1b.md:152:Great — I’ll generate a full Codex task set (around 20 tasks) based on the complete updated functionality we’ve outlined, including all aspects from directory pages and geographic structuring to crawler design, admin review flow, and phased-in user accounts.
docs/AGENTS.md:55:Deliver ultra-fast directory pages optimized for SEO and accessibility.
apps/admin/views/seo/index.ejs:7:      <p class="muted">Refresh page titles and meta descriptions before publishing new directory pages.</p>
codex/TASKS/25a_initialize_astro_frontend_with_base_layouts.yaml:9:- Create routing system for directory pages (by slug/subdomain)
codex/TASKS/08_setup_featured_listings_logic.yaml:4:  on directory pages.
codex/TASKS/06_frontend_directory_page_rendering.yaml:2:title: Frontend Directory Page Rendering
codex/TASKS/06_frontend_directory_page_rendering.yaml:3:description: Generate directory pages using SSR in Astro, grouped by category/location.
codex/TASKS/codex_phase_1b_2.yaml:53:          - directory page creation/editing
codex/TASKS/25_define_directory_page_model_and_metadata_fields.yaml:9:    - Create routing system for directory pages (by slug/subdomain)
codex/TASKS/27_implement_directory_pages_table_and_metadata_fields.yaml:3:title: Implement Directory Pages Table and Metadata Fields
codex/TASKS/39_render_canonical_meta_tags_from_directory_configuration.yaml:5:- Ensure that title, meta description, keywords, and Open Graph metadata are correctly injected into directory pages built with astro SSR

thinking
**Opening documentation**
exec
bash -lc "sed -n '1,220p' docs/development_phase_1b.md" in /var/home/rick/Development/mega-directory succeeded in 41ms:
# Development Phase 1 part B

The initial 20 codex tasks have been completed, and this has provided a solid base for the project. However, the project still falls short of a fully functioning application with all of the necessary moving parts. I'm sure this is because I failed to flesh out all of the details regarding the various workflows as I was particulary focused on the architecture. No problem, because this architecture is exactly what will make all of the remaining added functionality possible. 

We need to plan out some further development additions and refinements. It appears the api is missing a number of operations, but it seems the important base functionality is there so it shouldn't be a huge problem. I wanted to rethink some of the ways things work. Let's first of all think about the structure of the data. 

## Directory Pages

Rather than automatically generating directories from categories and locations, which could get messy if we try to have the system create all the permutations, furthermore, there will be significant SEO infomation that must be provided when creating a single directory page. So, we'll need a table to represent the individual directory pages. This way we can create directories that perhaps present more than one category or more than one postal code or city when these groupings represent very small amounts of listings or for whatever reason it makes sense to group or not group these together. The directory page can have its own title to concatenate with the site name to generate the content for the <title> tag and meta title, it can have an editable field for meta keywords, a field where the admin can specify the specific subdomain and the subdirectory used to represent the directory (based on the site configuration either the subdomain will 301 redirect to the subdirectory or the subdirectory to the subdomain, either way it should be possible for the admin to supply independent values for each of these), further meta tag values should include the description, og:image, etc. While the main site configuration should provide default values for these, it is important that it be possible to override them on individual directories.

It should also be a configuration option of the directory page whether the directory page should be location agnostic or not. If the directory page is NOT location agnostic, it should be relatively easy to provide a map widget displaying pins for each of the listings on the page. The user interface for this type of page could also include a pin icon at the end of the listing title that when clicked will cause the map widget to center on that listing. 

## Listing Locations and other Geographic Data

### Listing and physical_address tables

While we will be collecting a bunch of listings which are associated with various categories and locations. For some listings it may actually make sense to associate them with more than one category. It may even make sense to associate some listings with multiple addresses, but addresses should be associated only with a single listing (1234 some st. suite 1 and 1234 some st. suite 2 are separate addresses) So the *physical_address* table should have a foreign key on the *listing* table while listings and categories should be related via a join table.


### Country -> State/Province -> City -> Postal Data Structure

thinking
**Searching for directory_pages references**
exec
bash -lc 'rg -n "directory_pages" -n' in /var/home/rick/Development/mega-directory succeeded in 52ms:
tests/directory_pages_schema.test.js:30:test('directory_pages table exposes required metadata columns in snake_case', () => {
tests/directory_pages_schema.test.js:32:  const tableBlock = extractTableBlock(schema, 'directory_pages');
db/schema.prisma:242:  @@map("directory_pages")
db/migrations/001_core_schema.sql:55:CREATE TABLE "directory_pages" (
db/migrations/001_core_schema.sql:77:  CONSTRAINT "directory_pages_categoryId_locationId_key" UNIQUE ("categoryId", "locationId"),
db/migrations/001_core_schema.sql:78:  CONSTRAINT "directory_pages_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE,
db/migrations/001_core_schema.sql:79:  CONSTRAINT "directory_pages_locationId_fkey" FOREIGN KEY ("locationId") REFERENCES "Location"("id") ON DELETE SET NULL ON UPDATE CASCADE
db/migrations/001_core_schema.sql:142:  CONSTRAINT "Listing_directoryId_fkey" FOREIGN KEY ("directoryId") REFERENCES "directory_pages"("id") ON DELETE SET NULL ON UPDATE CASCADE,
db/migrations/001_core_schema.sql:171:  CONSTRAINT "FeaturedSlot_directoryId_fkey" FOREIGN KEY ("directoryId") REFERENCES "directory_pages"("id") ON DELETE CASCADE ON UPDATE CASCADE,
codex/TASKS/work_list:5:27_implement_directory_pages_table_and_metadata_fields.yaml
codex/TASKS/work_list:9:31_build_map_widget_for_directory_pages_with_location-aware_listings.yaml
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:196:tests/directory_pages_schema.test.js:30:test('directory_pages table exposes required metadata columns in snake_case', () => {
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:197:tests/directory_pages_schema.test.js:32:  const tableBlock = extractTableBlock(schema, 'directory_pages');
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:198:tests/directory_pages_schema.test.js:36:    { name: 'subdirectory', pattern: 'TEXT\\s+NOT\\s+NULL' },
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:311:codex/TASKS/27_implement_directory_pages_table_and_metadata_fields.yaml:3:title: Implement Directory Pages Table and Metadata Fields
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:340:**Searching for directory_pages references**
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:342:bash -lc 'rg -n "directory_pages" -n' in /var/home/rick/Development/mega-directory
codex/TASKS/CODEX_TODO_PHASE1B.md:3:- [ ] 026_create_directory_pages_table_and_related_metadata
codex/TASKS/codex_phase_1b_2.yaml:16:          - directory_pages: [GET, POST, PUT, DELETE]
codex/TASKS/codex_phase_1b_2.yaml:30:          - directory_pages:

thinking
**Reviewing logs and data schemas**
exec
bash -lc "sed -n '1,200p' tests/directory_pages_schema.test.js" in /var/home/rick/Development/mega-directory succeeded in 41ms:
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const test = require('node:test');

function loadCoreSchema() {
  const schemaPath = path.resolve(__dirname, '..', 'db', 'migrations', '001_core_schema.sql');
  return fs.readFileSync(schemaPath, 'utf8');
}

function extractTableBlock(sql, tableName) {
  const tableRegex = new RegExp(
    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
    'i'
  );
  const match = sql.match(tableRegex);
  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
  return match[1];
}


thinking
**Inspecting database migrations for schema details**
exec
bash -lc "sed -n '55,130p' db/migrations/001_core_schema.sql" in /var/home/rick/Development/mega-directory succeeded in 41ms:
CREATE TABLE "directory_pages" (
  "id" SERIAL PRIMARY KEY,
  "title" TEXT NOT NULL,
  "slug" TEXT NOT NULL UNIQUE,
  "subdomain" TEXT NOT NULL UNIQUE,
  "subdirectory" TEXT NOT NULL UNIQUE,
  "hostname" TEXT,
  "heroTitle" TEXT,
  "heroSubtitle" TEXT,
  "introMarkdown" TEXT,
  "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
  "featuredLimit" INTEGER NOT NULL DEFAULT 3,
  "meta_title" TEXT,
  "meta_description" TEXT,
  "meta_keywords" TEXT,
  "og_image_url" TEXT,
  "location_agnostic" BOOLEAN NOT NULL DEFAULT FALSE,
  "isActive" BOOLEAN NOT NULL DEFAULT FALSE,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

thinking
**Searching for DirectoryStatus**
exec
bash -lc 'rg -n "DirectoryStatus" -n' in /var/home/rick/Development/mega-directory succeeded in 57ms:
db/schema.prisma:19:enum DirectoryStatus {
db/schema.prisma:223:  status          DirectoryStatus @default(DRAFT)
db/migrations/001_core_schema.sql:5:CREATE TYPE "DirectoryStatus" AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
db/migrations/001_core_schema.sql:65:  "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_03_design_postgresql_schema_1762852701.log:76:CREATE TYPE "DirectoryStatus" AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
codex/LOGS/tasklog_03_design_postgresql_schema_1762852701.log:113:enum DirectoryStatus {
codex/LOGS/tasklog_03_design_postgresql_schema_1762852701.log:530:     5	CREATE TYPE "DirectoryStatus" AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
codex/LOGS/tasklog_03_design_postgresql_schema_1762852701.log:567:    17	enum DirectoryStatus {
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:403:  "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:415:**Searching for DirectoryStatus**
codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log:417:bash -lc 'rg -n "DirectoryStatus" -n' in /var/home/rick/Development/mega-directory
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:131:enum DirectoryStatus {
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:160:CREATE TYPE "DirectoryStatus" AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1085:  "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1284:   "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1373:   "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1483:   "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1504:   status          DirectoryStatus @default(DRAFT)
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1593:   "status" "DirectoryStatus" NOT NULL DEFAULT 'DRAFT',
codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log:1614:   status          DirectoryStatus @default(DRAFT)

thinking
**Organizing multi-step implementation plan**

I’m sketching a plan for building an admin UI to create and edit directory pages, starting with writing tests before code as per TDD guidelines. I’ll need to explore existing category and location data files to understand what fields and validations the form-based interface must handle, then plan to implement the service, route, view, and corresponding tests step-by-step.
exec
bash -lc "sed -n '1,200p' apps/admin/data/categoryLocations.js" in /var/home/rick/Development/mega-directory succeeded in 48ms:
module.exports = [
  {
    id: 'dir_electricians_nyc',
    category: 'Electricians',
    location: 'New York, NY',
    slug: 'nyc/electricians',
    listingsCount: 24,
    source: 'Manual seed',
    approvedAt: '2024-05-20T11:15:00-04:00',
    status: 'active'
  },
  {
    id: 'dir_plumbers_atlanta',
    category: 'Plumbers',
    location: 'Atlanta, GA',
    slug: 'atlanta-ga/plumbers',
    listingsCount: 17,
    source: 'Crawler Run 412',
    approvedAt: '2024-05-19T15:45:00-04:00',
    status: 'active'

thinking
**Inspecting navigation partials**
exec
bash -lc "sed -n '1,200p' apps/admin/views/partials/page-start.ejs" in /var/home/rick/Development/mega-directory succeeded in 57ms:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title><%= title ? `${title} | ${appName}` : appName %></title>
  <link rel="stylesheet" href="/css/admin.css" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <div>
        <p class="eyebrow">Internal</p>
        <h1><%= appName %></h1>
      </div>
      <nav class="site-nav">
        <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
        <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
        <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
      </nav>

thinking
**Preparing to add directory page navigation**
exec
bash -lc "sed -n '1,200p' apps/admin/services/categoryLocationsService.js" in /var/home/rick/Development/mega-directory exited 2 in 43ms:
sed: can't read apps/admin/services/categoryLocationsService.js: No such file or directory

thinking
**Checking services directory**
exec
bash -lc 'ls apps/admin/services' in /var/home/rick/Development/mega-directory succeeded in 48ms:
apiClient.js
categoryLocationService.js
listingsService.js
seoService.js

thinking
**Opening cat service**
exec
bash -lc "sed -n '1,200p' apps/admin/services/categoryLocationService.js" in /var/home/rick/Development/mega-directory succeeded in 42ms:
const approvedLocations = require('../data/categoryLocations');
const pendingLocations = require('../data/categoryLocationDiscoveries');

function getPendingCategoryLocations() {
  return pendingLocations.slice();
}

function getApprovedCategoryLocations() {
  return approvedLocations.slice();
}

function approveCategoryLocations(candidates = []) {
  if (!Array.isArray(candidates) || candidates.length === 0) {
    return { added: 0 };
  }

  const approvals = candidates.filter((candidate) => candidate?.id && candidate.approve);
  if (approvals.length === 0) {
    return { added: 0 };
  }

thinking
**Inspecting sample data structure**
exec
bash -lc "sed -n '1,200p' apps/admin/data/categoryLocationDiscoveries.js" in /var/home/rick/Development/mega-directory succeeded in 45ms:
module.exports = [
  {
    id: 'disc_electricians_chicago',
    category: 'Electricians',
    location: 'Chicago, IL',
    slug: 'chicago-il/electricians',
    discoveredAt: '2024-05-23T09:15:00-05:00',
    source: 'Crawler Run 428',
    listingsCount: 22,
    sampleListings: ['Windy City Electric', 'Loop Line Wiring', 'Lakeview Power Pros'],
    notes: 'Met auto-publish threshold with 18 verified listings in the past 7 days.'
  },
  {
    id: 'disc_plumbers_denver',
    category: 'Plumbers',
    location: 'Denver, CO',
    slug: 'denver-co/plumbers',
    discoveredAt: '2024-05-22T08:55:00-06:00',
    source: 'Crawler Run 429',
    listingsCount: 14,

thinking
**Reviewing styles for directory pages**
exec
bash -lc "sed -n '1,200p' apps/admin/public/css/admin.css" in /var/home/rick/Development/mega-directory succeeded in 41ms:
:root {
  --bg-body: #f5f6fb;
  --bg-panel: #ffffff;
  --bg-header: #0f172a;
  --text-body: #111827;
  --text-muted: #6b7280;
  --border-color: #e5e7eb;
  --accent: #2563eb;
  --accent-dark: #1d4ed8;
  --success-bg: #ecfdf5;
  --success-text: #047857;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;

thinking
**Continuing CSS development**
exec
bash -lc "sed -n '200,400p' apps/admin/public/css/admin.css" in /var/home/rick/Development/mega-directory succeeded in 42ms:
.field-control {
  width: 100%;
  margin-top: 0.25rem;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 0.55rem 0.75rem;
  font-size: 1rem;
  font-family: inherit;
}

.field-control:focus {
  outline: 2px solid rgba(37, 99, 235, 0.4);
  outline-offset: 2px;
}

.notes-field textarea {
  min-height: 110px;
}

.summary {

thinking
**Exploring category data and UI styles**
exec
bash -lc "sed -n '1,200p' apps/admin/services/apiClient.js" in /var/home/rick/Development/mega-directory succeeded in 41ms:
const ADMIN_LISTINGS_ENDPOINT = '/v1/admin/listings/review';

async function submitListingUpdates(updates = []) {
  if (!Array.isArray(updates) || updates.length === 0) {
    return { delivered: 0 };
  }

  const baseUrl = process.env.ADMIN_API_BASE_URL || process.env.API_BASE_URL || null;
  const token = process.env.ADMIN_API_TOKEN || null;

  if (!baseUrl || !token) {
    return {
      delivered: 0,
      skipped: updates.length,
      reason: 'Admin API base URL or token is not configured'
    };
  }

  if (typeof fetch !== 'function') {
    return {

thinking
**Planning local UI data service**
exec
bash -lc 'rg -l "category" apps/admin/data' in /var/home/rick/Development/mega-directory succeeded in 46ms:
apps/admin/data/categoryLocationDiscoveries.js
apps/admin/data/categoryLocations.js
apps/admin/data/seoEntries.js
apps/admin/data/listings.js

thinking
**Checking category data presence**
exec
bash -lc "sed -n '1,200p' apps/admin/data/seoEntries.js" in /var/home/rick/Development/mega-directory succeeded in 46ms:
module.exports = [
  {
    id: 'seo_electricians',
    type: 'category',
    category: 'Electricians',
    location: null,
    slug: 'electricians',
    metaTitle: 'Electricians Near You | Mega Directory',
    metaDescription: 'Compare licensed electricians for emergency calls, panel upgrades, EV charger installs, and more.',
    lastUpdated: '2024-05-18T12:00:00-04:00',
  },
  {
    id: 'seo_plumbers',
    type: 'category',
    category: 'Plumbers',
    location: null,
    slug: 'plumbers',
    metaTitle: 'Trusted Plumbers | Mega Directory',
    metaDescription: 'Browse vetted plumbers for leaks, re-pipes, maintenance plans, and emergency dispatch in your city.',
    lastUpdated: '2024-05-17T17:45:00-04:00',

thinking
**Preparing data file for directory pages**
exec
bash -lc "sed -n '1,200p' apps/admin/views/category-locations/index.ejs" in /var/home/rick/Development/mega-directory succeeded in 43ms:
<%- include('../partials/page-start', { title: 'Category & Location Approvals', active: 'category-locations' }) %>
<section class="panel stack gap-md">
  <header class="panel-header">
    <div>
      <p class="eyebrow">Directories</p>
      <h2>Approve new category + location pairs</h2>
      <p class="muted">Review crawler discoveries, then promote qualified combinations into the directory database.</p>
    </div>
    <div class="badge">Pending <strong><%= pending.length %></strong></div>
  </header>

  <p class="muted">Currently tracking <strong><%= totalApproved %></strong> approved directories.</p>

  <% if (typeof addedCount === 'number' && addedCount > 0) { %>
    <div class="alert success">Approved <strong><%= addedCount %></strong> new director<%= addedCount === 1 ? 'y' : 'ies' %>.</div>
  <% } %>

  <% if (!pending.length) { %>
    <p class="empty-state">No new discoveries need approval right now.</p>
  <% } else { %>

thinking
**Planning new view implementation with TDD**

I’m outlining a multi-step plan to build a new view following TDD: start by understanding requirements and data, then write failing tests for the new service, implement service logic, create the route and view with CSS updates, and finally run all relevant tests—likely via `npm test` at root or in the admin app—to verify everything works as expected. I'll check test strategies used in `apps/admin/test` to align with current practices.
exec
bash -lc 'cat package.json' in /var/home/rick/Development/mega-directory succeeded in 42ms:
{
  "name": "mega-directory",
  "private": true,
  "version": "0.1.0",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "test": "npm run test:root && npm run test:workspaces",
    "test:root": "node --test tests/**/*.test.js",
    "test:workspaces": "npm run test --workspaces --if-present"
  }
}

thinking
**Outlining test-driven development plan**

I’m considering running root tests with `npm test` to verify everything, even though it might be heavy. I want to create a clear multi-step TDD plan—from reviewing requirements and writing failing tests, to implementing code and verifying with tests again—and then update the plan accordingly.
Plan update
  → Review task requirements and current admin code to outline UI/data needs
  • Add failing tests covering directory page validation and persistence logic
  • Implement directory page data store and service to satisfy tests
  • Build Express route, EJS view, and styles for the directory page management UI
  • Run relevant automated tests to verify changes

thinking
**Confirming step completion**
Plan update
  ✓ Review task requirements and current admin code to outline UI/data needs
  → Add failing tests covering directory page validation and persistence logic
  • Implement directory page data store and service to satisfy tests
  • Build Express route, EJS view, and styles for the directory page management UI
  • Run relevant automated tests to verify changes

thinking
**Outlining service API and test stubs**
exec
bash -lc 'cat codex/TASKS/25_define_directory_page_model_and_metadata_fields.yaml' in /var/home/rick/Development/mega-directory succeeded in 41ms:
id: 25
filename: 25_initialize_astro_frontend_with_base_layouts.yaml
title: Initialize Astro Frontend with Base Layouts
description: >
Set up the main Astro-powered frontend application:
    - Install and configure Astro with TypeScript, Tailwind CSS, and necessary integrations
    - Create base layout for pages, with head tags and site-wide styling
    - Implement global header and footer components
    - Create routing system for directory pages (by slug/subdomain)
    - Support both subdomain and subdirectory routing for directory URLs
    - Prepare slots for SEO meta tag injection (meta title, description, og image, etc)
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
dependencies: [24]

thinking
**Checking task file relevance**
exec
bash -lc 'cat codex/TASKS/27_implement_directory_pages_table_and_metadata_fields.yaml' in /var/home/rick/Development/mega-directory succeeded in 44ms:
id: 27
filename: 27_implement_directory_pages_table_and_metadata_fields.yaml
title: Implement Directory Pages Table and Metadata Fields
description: >
- Create the directory_pages table to support manually managed directories with custom SEO metadata.
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
Include fields: title, meta_keywords, meta_description, og_image_url, subdomain, subdirectory, location_agnostic (bool).
dependencies: []

thinking
**Reviewing metadata requirements**
exec
bash -lc "sed -n '1,220p' codex/TASKS/codex_phase_1b_2.yaml" in /var/home/rick/Development/mega-directory succeeded in 44ms:
project: mega-directory
version: 1.0
phases:
  - phase: 1
    description: Core system buildout — listings pipeline, directory structure, admin tools, crawler, API, and frontend delivery

    components:
      api_server:
        language: TypeScript
        framework: Node/Express
        deployment: Railway
        endpoints:
          - listings: [GET, POST, PUT, DELETE]
          - addresses: [GET, POST, PUT, DELETE]
          - categories: [GET, POST, PUT, DELETE]
          - directory_pages: [GET, POST, PUT, DELETE]
          - directory_metadata: [GET, PUT]
        notes:
          - Postal, city, state/province, and country tables are loaded from external datasets.
          - Listings reference postal_code_id or city_id depending on geography.

thinking
**Analyzing admin UI requirements and data schema**
exec
bash -lc "sed -n '1,200p' codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log" in /var/home/rick/Development/mega-directory succeeded in 44ms:
OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a7815-9b21-7a32-a923-7a79d47bdeed
--------
user
Implement the functionality described in codex/TASKS/28_build_admin_ui_for_directory_page_creation_and_editing.yaml, then verify with any available tests.
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:

thinking
**Continuing to review logs for design insights**
exec
bash -lc "sed -n '200,400p' codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log" in /var/home/rick/Development/mega-directory succeeded in 42ms:
apps/admin/views/category-locations/index.ejs:7:      <p class="muted">Review crawler discoveries, then promote qualified combinations into the directory database.</p>
scripts/dev-bootstrap.sh:107:DATABASE_URL_VALUE="${DATABASE_URL:-postgresql://postgres:password@localhost:5432/mega_directory}"
AGENTS.md:55:Deliver ultra-fast directory pages optimized for SEO and accessibility.
codex.yaml:16:    path: codex/TASKS/06_frontend_directory_page_rendering.yaml
docker-compose.yml:11:      DATABASE_URL: postgresql://postgres:password@db:5432/mega_directory

thinking
**Reviewing admin UI requirements and tests**
exec
bash -lc 'ls apps/admin/test' in /var/home/rick/Development/mega-directory succeeded in 41ms:
categoryLocationService.test.js
listingsService.test.js
seoService.test.js

thinking
**Preparing to write tests for new service**
exec
bash -lc "sed -n '1,200p' apps/admin/test/seoService.test.js" in /var/home/rick/Development/mega-directory succeeded in 43ms:
const test = require('node:test');
const assert = require('node:assert/strict');

thinking
**Reviewing truncated logs**
exec
bash -lc 'tail -n 200 codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log' in /var/home/rick/Development/mega-directory succeeded in 46ms:
**Checking category data presence**
exec
bash -lc "sed -n '1,200p' apps/admin/data/seoEntries.js" in /var/home/rick/Development/mega-directory succeeded in 46ms:
module.exports = [
  {
    id: 'seo_electricians',
    type: 'category',
    category: 'Electricians',
    location: null,
    slug: 'electricians',
    metaTitle: 'Electricians Near You | Mega Directory',
    metaDescription: 'Compare licensed electricians for emergency calls, panel upgrades, EV charger installs, and more.',
    lastUpdated: '2024-05-18T12:00:00-04:00',
  },
  {
    id: 'seo_plumbers',
    type: 'category',
    category: 'Plumbers',
    location: null,
    slug: 'plumbers',

thinking
**Planning service and tests creation**

I'm outlining the new directoryPageService with functions for listing, creating, updating, and toggling activation of directory pages, alongside corresponding test and data files. I'll follow TDD by writing tests that reference modules and data files to be created, accepting initial failures due to missing code. I'm also considering how to structure server routes and data sets, while planning to review existing listing data for category alignment.
exec
bash -lc "sed -n '1,200p' apps/admin/data/listings.js" in /var/home/rick/Development/mega-directory succeeded in 41ms:
module.exports = [
  {
    id: 'lst_nova_electric',
    businessName: 'Nova Electric Co.',
    category: 'Electricians',
    location: 'Brooklyn, NY',
    website: 'https://novaelectric.example.com',
    phone: '(347) 555-0112',
    summary: '24/7 emergency electricians covering every borough with rapid dispatch teams.',
    notes: 'Crawler ingestion flagged missing license number.',
    score: 82,
    status: 'pending',
    source: 'Crawler Feed A',
    submittedAt: '2024-05-22T09:30:00-04:00',
    lastUpdated: '2024-05-22T09:30:00-04:00',
  },
  {
    id: 'lst_green_canopy',
    businessName: 'Green Canopy Tree Care',
    category: 'Arborists',

thinking
**Mapping category and location data**
exec
bash -lc "sed -n '1,200p' apps/admin/views/listings/index.ejs" in /var/home/rick/Development/mega-directory succeeded in 42ms:
<%- include('../partials/page-start', { title: 'Listing Review', active: 'listings' }) %>
<%
  const pageData = pagination || {
    totalItems: listings.length,
    start: listings.length ? 1 : 0,
    end: listings.length,
    page: 1,
    totalPages: 1,
    hasPrevious: false,
    hasNext: false,
    previousPage: null,
    nextPage: null
  };
%>
<section class="panel stack gap-md listing-review">
  <header class="panel-header">
    <div>
      <p class="eyebrow">Moderation</p>
      <h2>Review incoming listings</h2>
      <p class="muted">Edit listing details, capture manual notes, and choose whether to approve or deactivate each entry.</p>



thinking
**Designing directory page service and tests**
thinking
**Planning validation rules and test cases for directory pages**

This chunk lays out detailed validation requirements for creating and updating directory pages, covering required fields, uniqueness checks, location handling, metadata trimming, and status toggles. I’m designing corresponding tests to enforce these rules, including scenarios for missing fields, duplicates, location-agnostic handling, metadata updates, and conflict rejections, all while considering implementation details like ID generation and error reporting to guide later coding.
thinking
**Preparing test suite scaffolding and workflow**

I’m planning how to write the test files first—recognizing that without the service and data modules they’ll initially fail imports. I’m mapping a TDD workflow where tests are added before full code, running them to fail, then implementing minimal stubs if needed to run tests properly, and finally fleshing out functionality. This careful sequencing will help ensure tests drive development while handling module dependencies gracefully.
file update
A /var/home/rick/Development/mega-directory/apps/admin/test/directoryPageService.test.js
const test = require('node:test');
const assert = require('node:assert/strict');

const directoryStore = require('../data/directoryPages');
const directoryOptions = require('../data/directoryPageOptions');
const {
  createDirectoryPage,
  updateDirectoryPages
} = require('../services/directoryPageService');

const originalStore = deepClone(directoryStore);

function resetStore() {
  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
}

test('createDirectoryPage enforces required fields and uniqueness', () => {
  resetStore();

  const initialLength = directoryStore.length;
  const invalid = createDirectoryPage({
    title: '',
    categoryId: '',
    locationId: '',
    subdomain: '  ',
    subdirectory: '',
    locationAgnostic: false,
    metaTitle: '',
    metaDescription: ''
  });

  assert.ok(invalid.errors);
  assert.deepStrictEqual(
    Object.keys(invalid.errors).sort(),
    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
  );
  assert.strictEqual(directoryStore.length, initialLength);

  const existing = directoryStore[0];
  assert.ok(existing, 'expected seed directory pages for tests');

  const duplicate = createDirectoryPage({
    title: 'Duplicate Attempt',
    categoryId: existing.categoryId,
    locationId: existing.locationId,
    subdomain: existing.subdomain,
    subdirectory: existing.subdirectory,
    locationAgnostic: Boolean(existing.locationAgnostic),
    metaTitle: 'Example',
    metaDescription: 'Example description'
  });

  assert.ok(duplicate.errors.subdomain);
  assert.ok(duplicate.errors.subdirectory);
  assert.strictEqual(directoryStore.length, initialLength);
});

test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
  resetStore();

  const category = directoryOptions.categories?.[0];
  assert.ok(category, 'expected at least one category option');

  const result = createDirectoryPage({
    title: '  Remote Support Specialists  ',
    categoryId: category.id,
    locationAgnostic: true,
    locationId: '',
    subdomain: '  remote-support ',
    subdirectory: '  remote/support  ',
    metaTitle: '  Remote Support Pros  ',
    metaDescription: '  Nationwide remote troubleshooting help.  ',
    metaKeywords: '  support, remote, it  ',
    ogImageUrl: 'https://cdn.example.com/images/remote.png',
    heroTitle: '  Remote Experts  ',
    heroSubtitle: '  Help desk on demand  ',
    introMarkdown: '  **Get help** anytime.  '
  });

  assert.ifError(result.errors);
  assert.ok(result.record?.id);
  assert.strictEqual(result.record.title, 'Remote Support Specialists');
  assert.strictEqual(result.record.locationId, null);
  assert.strictEqual(result.record.locationAgnostic, true);
  assert.strictEqual(result.record.subdomain, 'remote-support');
  assert.strictEqual(result.record.subdirectory, 'remote/support');
  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
});

test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
  resetStore();

  const target = directoryStore[0];
  assert.ok(target, 'expected at least one seed directory page');

  const updatedTitle = `${target.title} (Refreshed)`;
  const updateResult = updateDirectoryPages([
    {
      id: target.id,
      title: updatedTitle,
      heroTitle: 'Updated Hero',
      heroSubtitle: 'Updated Subtitle',
      introMarkdown: 'Updated intro',
      metaTitle: 'Updated Meta Title',
      metaDescription: '  Trim this description   ',
      metaKeywords: 'alpha, beta, gamma',
      ogImageUrl: 'https://cdn.example.com/og/new.png',
      save: true
    }
  ]);

  assert.strictEqual(updateResult.updated, 1);
  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
  assert.strictEqual(target.title, updatedTitle);
  assert.strictEqual(target.heroTitle, 'Updated Hero');
  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
  assert.strictEqual(target.introMarkdown, 'Updated intro');
  assert.strictEqual(target.metaDescription, 'Trim this description');
  assert.strictEqual(target.status, 'ACTIVE');
  assert.strictEqual(target.isActive, true);

  const deactivateResult = updateDirectoryPages([
    {
      id: target.id,
      deactivate: true
    }
  ]);

  assert.strictEqual(deactivateResult.updated, 1);
  assert.strictEqual(target.status, 'ARCHIVED');
  assert.strictEqual(target.isActive, false);
});

test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
  resetStore();

  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
  const first = directoryStore[0];
  const second = directoryStore[1];

  const conflict = updateDirectoryPages([
    {
      id: second.id,
      subdomain: first.subdomain
    }
  ]);

  assert.strictEqual(conflict.updated, 0);
  assert.ok(conflict.errors?.[second.id]?.subdomain);

  const invalidLocation = updateDirectoryPages([
    {
      id: second.id,
      locationAgnostic: false,
      locationId: ''
    }
  ]);

  assert.strictEqual(invalidLocation.updated, 0);
  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
});

function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A apps/admin/test/directoryPageService.test.js
file update:
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Updating plan after adding tests**
Plan update
  ✓ Review task requirements and current admin code to outline UI/data needs
  ✓ Add failing tests covering directory page validation and persistence logic
  → Implement directory page data store and service to satisfy tests
  • Build Express route, EJS view, and styles for the directory page management UI
  • Run relevant automated tests to verify changes
file update:
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Implementing directory data and services**

I'm setting up the data files with categories and locations and defining directory pages with example entries. Then I'll implement service functions to handle creating and updating directory pages, including detailed validation, normalization, and uniqueness checks, making sure fields like metaTitle and metaDescription are enforced properly. I'll design helpers for slug normalization, checkbox parsing, and label lookups to smoothly integrate with the rest of the app.
file update
A /var/home/rick/Development/mega-directory/apps/admin/data/directoryPageOptions.js
module.exports = {
  categories: [
    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
  ],
  locations: [
    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
  ]
};
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A apps/admin/data/directoryPageOptions.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Adding directoryPages.js file**
file update
A /var/home/rick/Development/mega-directory/apps/admin/data/directoryPages.js
module.exports = [
  {
    id: 'dir_electricians_nyc',
    title: 'Top Electricians in New York City',
    slug: 'nyc-electricians',
    categoryId: 'cat_electricians',
    locationId: 'loc_new_york_ny',
    locationAgnostic: false,
    subdomain: 'nyc-electricians',
    subdirectory: 'nyc/electricians',
    heroTitle: 'Trusted NYC Electricians',
    heroSubtitle: 'Hire vetted pros across all five boroughs',
    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
    metaTitle: 'Best Electricians in NYC | Mega Directory',
    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
    metaKeywords: 'electricians,nyc,licensed,emergency',
    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
    status: 'ACTIVE',
    isActive: true,
    createdAt: '2024-05-10T14:20:00-04:00',
    updatedAt: '2024-05-20T09:45:00-04:00'
  },
  {
    id: 'dir_plumbers_atl',
    title: 'Atlanta Plumbers Guide',
    slug: 'atlanta-plumbers',
    categoryId: 'cat_plumbers',
    locationId: 'loc_atlanta_ga',
    locationAgnostic: false,
    subdomain: 'atlanta-plumbers',
    subdirectory: 'atlanta-ga/plumbers',
    heroTitle: 'Metro Atlanta Plumbers',
    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
    metaTitle: 'Atlanta Plumbers | Mega Directory',
    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
    status: 'DRAFT',
    isActive: false,
    createdAt: '2024-05-11T08:05:00-04:00',
    updatedAt: '2024-05-19T10:10:00-04:00'
  }
];
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
A apps/admin/data/directoryPages.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Implementing directory page service**

I'm laying out the new service in `apps/admin/services/directoryPageService.js`, focusing on helper functions to fetch pages and options, plus creation and update handlers that rely on a robust payload normalization step. I'll carefully handle validation, field assignments, uniqueness checks, and timestamps to keep data consistent and errors clear. This includes managing status flags and ensuring the service exports the right functions for route access. It's quite detailed, but I want to make sure the directory pages behave correctly across all actions.
file update
A /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
const directoryPages = require('../data/directoryPages');
const directoryOptions = require('../data/directoryPageOptions');

const STATUSES = {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

function getDirectoryPages() {
  return directoryPages.map((page) => ({
    ...page,
    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
    locationLabel: page.locationAgnostic
      ? 'Location agnostic'
      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
  }));
}

function getDirectoryOptions() {
  return {
    categories: directoryOptions.categories.slice(),
    locations: directoryOptions.locations.slice(),
    statuses: Object.values(STATUSES)
  };
}

function createDirectoryPage(payload = {}) {
  const { record, errors } = normalizePayload(payload, { mode: 'create' });
  if (hasErrors(errors)) {
    return { errors };
  }

  const timestamp = new Date().toISOString();
  const storedRecord = {
    ...record,
    id: record.id || generateId(record.title),
    createdAt: timestamp,
    updatedAt: timestamp,
    status: STATUSES.DRAFT,
    isActive: false
  };

  directoryPages.push(storedRecord);
  return { record: storedRecord, errors: null };
}

function updateDirectoryPages(updates = []) {
  if (!Array.isArray(updates) || updates.length === 0) {
    return { updated: 0, errors: null };
  }

  let updated = 0;
  const errorBag = {};

  updates.forEach((payload) => {
    if (!payload?.id) {
      return;
    }

    const record = directoryPages.find((entry) => entry.id === payload.id);
    if (!record) {
      return;
    }

    const { record: nextState, errors } = normalizePayload(payload, {
      mode: 'update',
      existingRecord: record
    });

    if (hasErrors(errors)) {
      errorBag[record.id] = errors;
      return;
    }

    Object.assign(record, nextState);

    if (parseCheckbox(payload.deactivate)) {
      record.status = STATUSES.ARCHIVED;
      record.isActive = false;
    } else if (parseCheckbox(payload.save)) {
      record.status = STATUSES.ACTIVE;
      record.isActive = true;
    }

    record.updatedAt = new Date().toISOString();
    updated += 1;
  });

  return {
    updated,
    errors: Object.keys(errorBag).length ? errorBag : null
  };
}

function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
  if (mode === 'update' && !existingRecord) {
    throw new Error('existingRecord is required for update mode');
  }

  const baseRecord = existingRecord
    ? { ...existingRecord }
    : {
        id: null,
        title: '',
        slug: '',
        categoryId: '',
        locationId: null,
        locationAgnostic: false,
        subdomain: '',
        subdirectory: '',
        heroTitle: '',
        heroSubtitle: '',
        introMarkdown: '',
        metaTitle: '',
        metaDescription: '',
        metaKeywords: '',
        ogImageUrl: '',
        status: STATUSES.DRAFT,
        isActive: false,
        createdAt: null,
        updatedAt: null
      };

  const next = { ...baseRecord };
  const errors = {};

  assignString(next, payload, 'title');
  assignString(next, payload, 'heroTitle');
  assignString(next, payload, 'heroSubtitle');
  assignString(next, payload, 'introMarkdown');
  assignString(next, payload, 'metaTitle');
  assignString(next, payload, 'metaDescription');
  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
  assignString(next, payload, 'ogImageUrl');

  if (payload.categoryId !== undefined || mode === 'create') {
    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
    next.categoryId = value || '';
  }

  if (payload.locationAgnostic !== undefined || mode === 'create') {
    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
  }

  if (payload.locationId !== undefined) {
    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
    next.locationId = value || null;
  } else if (!existingRecord && next.locationId === undefined) {
    next.locationId = null;
  }

  if (next.locationAgnostic) {
    next.locationId = null;
  }

  if (payload.subdomain !== undefined || mode === 'create') {
    next.subdomain = sanitizeSubdomain(payload.subdomain);
  }

  if (payload.subdirectory !== undefined || mode === 'create') {
    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
    next.slug = buildSlug(next.subdirectory);
  } else if (!next.slug && next.subdirectory) {
    next.slug = buildSlug(next.subdirectory);
  }

  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });

  return { record: next, errors };
}

function validateRecord(record, errors, { mode, currentId }) {
  if (!record.title) {
    errors.title = 'Title is required';
  }

  if (!record.categoryId || !resolveCategory(record.categoryId)) {
    errors.categoryId = 'Select a valid category';
  }

  if (!record.metaTitle) {
    errors.metaTitle = 'Meta title is required';
  }

  if (!record.metaDescription) {
    errors.metaDescription = 'Meta description is required';
  }

  if (!record.subdomain) {
    errors.subdomain = 'Subdomain is required';
  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
    errors.subdomain = 'Subdomain is already in use';
  }

  if (!record.subdirectory) {
    errors.subdirectory = 'Subdirectory is required';
  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
    errors.subdirectory = 'Subdirectory is already in use';
  }

  if (!record.locationAgnostic) {
    if (!record.locationId) {
      errors.locationId = 'Select a location';
    } else if (!resolveLocation(record.locationId)) {
      errors.locationId = 'Select a valid location';
    }
  }
}

function sanitizeSubdomain(value) {
  if (typeof value !== 'string') {
    return '';
  }
  return value.trim().toLowerCase().replace(/\s+/g, '-');
}

function sanitizeSubdirectory(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const trimmed = value.trim().replace(/^\/+|\/+$|\s+/g, (match) => {
    if (/^\/+|\/+$/.test(match)) {
      return '';
    }
    return '-';
  });
  return trimmed.replace(/\/+/, '/');
}

function buildSlug(subdirectory = '') {
  if (!subdirectory) {
    return '';
  }
  return subdirectory
    .trim()
    .replace(/^\/+|\/+$|\s+/g, (match) => {
      if (/^\/+|\/+$/.test(match)) {
        return '';
      }
      return '-';
    })
    .replace(/\//g, '-')
    .replace(/[^a-z0-9-]/gi, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .toLowerCase();
}

function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
  if (payload[field] === undefined) {
    return;
  }

  if (typeof payload[field] !== 'string') {
    target[field] = '';
    return;
  }

  const value = collapseWhitespace
    ? collapseSpaces(payload[field])
    : payload[field].trim();
  target[field] = value;
}

function collapseSpaces(value) {
  return value.trim().replace(/\s+/g, ' ');
}

function resolveCategory(id) {
  return directoryOptions.categories.find((entry) => entry.id === id) || null;
}

function resolveLocation(id) {
  if (!id) {
    return null;
  }
  return directoryOptions.locations.find((entry) => entry.id === id) || null;
}

function isUnique(field, value, currentId = null) {
  if (!value) {
    return true;
  }

  const normalized = value.toLowerCase();
  return !directoryPages.some((entry) => {
    if (!entry[field]) {
      return false;
    }
    if (currentId && entry.id === currentId) {
      return false;
    }
    return entry[field].toLowerCase() === normalized;
  });
}

function parseCheckbox(value) {
  if (Array.isArray(value)) {
    return value.some((entry) => parseCheckbox(entry));
  }

  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
  }

  return Boolean(value);
}

function generateId(title = 'directory_page') {
  const suffix = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 32) || 'entry';
  return `dir_${suffix}_${Date.now()}`;
}

function hasErrors(errors) {
  return errors && Object.keys(errors).length > 0;
}

module.exports = {
  getDirectoryPages,
  getDirectoryOptions,
  createDirectoryPage,
  updateDirectoryPages,
  STATUSES
};
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
A apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..8acffb1b6d7ba5a428f7f97f7408dff2410660a9
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,331 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value.trim().toLowerCase().replace(/\s+/g, '-');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value.trim().replace(/^\/+|\/+$|\s+/g, (match) => {
+    if (/^\/+|\/+$/.test(match)) {
+      return '';
+    }
+    return '-';
+  });
+  return trimmed.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  if (!subdirectory) {
+    return '';
+  }
+  return subdirectory
+    .trim()
+    .replace(/^\/+|\/+$|\s+/g, (match) => {
+      if (/^\/+|\/+$/.test(match)) {
+        return '';
+      }
+      return '-';
+    })
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/gi, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .toLowerCase();
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..8acffb1b6d7ba5a428f7f97f7408dff2410660a9
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,331 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value.trim().toLowerCase().replace(/\s+/g, '-');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value.trim().replace(/^\/+|\/+$|\s+/g, (match) => {
+    if (/^\/+|\/+$/.test(match)) {
+      return '';
+    }
+    return '-';
+  });
+  return trimmed.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  if (!subdirectory) {
+    return '';
+  }
+  return subdirectory
+    .trim()
+    .replace(/^\/+|\/+$|\s+/g, (match) => {
+      if (/^\/+|\/+$/.test(match)) {
+        return '';
+      }
+      return '-';
+    })
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/gi, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .toLowerCase();
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Refining sanitization functions for paths and slugs**

I'm ironing out the sanitizeSubdirectory and sanitizeSubdomain functions to properly trim, standardize case, replace whitespace with hyphens, and handle slashes and invalid characters consistently. I'll update buildSlug to rely on these for cleaner, predictable path and slug strings. This should align with expected behaviors and improve test pass rates.
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
@@ -214,3 +214,8 @@
   }
-  return value.trim().toLowerCase().replace(/\s+/g, '-');
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
 }
@@ -221,9 +226,9 @@
   }
-  const trimmed = value.trim().replace(/^\/+|\/+$|\s+/g, (match) => {
-    if (/^\/+|\/+$/.test(match)) {
-      return '';
-    }
-    return '-';
-  });
-  return trimmed.replace(/\/+/, '/');
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
 }
@@ -231,18 +236,11 @@
 function buildSlug(subdirectory = '') {
-  if (!subdirectory) {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
     return '';
   }
-  return subdirectory
-    .trim()
-    .replace(/^\/+|\/+$|\s+/g, (match) => {
-      if (/^\/+|\/+$/.test(match)) {
-        return '';
-      }
-      return '-';
-    })
+  return normalized
     .replace(/\//g, '-')
-    .replace(/[^a-z0-9-]/gi, '-')
+    .replace(/[^a-z0-9-]/g, '-')
     .replace(/-+/g, '-')
-    .replace(/^-|-$/g, '')
-    .toLowerCase();
+    .replace(/^-|-$/g, '');
 }
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..101dbda9130311ab92405829fc85e290a53db0d1
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..101dbda9130311ab92405829fc85e290a53db0d1
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Correcting regex in sanitizeSubdirectory**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..101dbda9130311ab92405829fc85e290a53db0d1
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..101dbda9130311ab92405829fc85e290a53db0d1
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Correcting patch application**
exec
bash -lc 'rg -n "sanitizeSubdirectory" -n apps/admin/services/directoryPageService.js' in /var/home/rick/Development/mega-directory succeeded in 41ms:
162:    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
223:function sanitizeSubdirectory(value) {
237:  const normalized = sanitizeSubdirectory(subdirectory);
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..101dbda9130311ab92405829fc85e290a53db0d1
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

exec
bash -lc "sed -n '223,250p' apps/admin/services/directoryPageService.js" in /var/home/rick/Development/mega-directory succeeded in 44ms:
function sanitizeSubdirectory(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const trimmed = value
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-');

  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
}

function buildSlug(subdirectory = '') {
  const normalized = sanitizeSubdirectory(subdirectory);
  if (!normalized) {
    return '';
  }
  return normalized
    .replace(/\//g, '-')
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..101dbda9130311ab92405829fc85e290a53db0d1
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Fixing regex replacement**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
@@ -232,3 +232,3 @@
   const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
-  return withoutEdges.replace(/\/+ /g, '/').replace(/\/+\//g, '/');
+  return withoutEdges.replace(/\/+/, '/');
 }
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Noticing regex needs global flag**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Updating regex replacement**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Clarifying regex replacement behavior**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Correcting regular expression replacement patch**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Updating regex to global replacement**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Checking for autopatch merging**
exec
bash -lc "sed -n '223,240p' apps/admin/services/directoryPageService.js" in /var/home/rick/Development/mega-directory succeeded in 48ms:
function sanitizeSubdirectory(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const trimmed = value
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-');

  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
  return withoutEdges.replace(/\/+/, '/');
}

function buildSlug(subdirectory = '') {
  const normalized = sanitizeSubdirectory(subdirectory);
  if (!normalized) {
    return '';
  }
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Preparing patch for path normalization**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Preparing regex patch with global flag**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Analyzing patch regex issue**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Analyzing patch escape issues**
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Fixing spacing in code line**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Troubleshooting patch escape issues**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Correcting regex patch formatting**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 9ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Investigating escape character issue**
exec
bash -lc "nl -ba apps/admin/services/directoryPageService.js | sed -n '223,240p'" in /var/home/rick/Development/mega-directory succeeded in 41ms:
   223	function sanitizeSubdirectory(value) {
   224	  if (typeof value !== 'string') {
   225	    return '';
   226	  }
   227	  const trimmed = value
   228	    .trim()
   229	    .toLowerCase()
   230	    .replace(/\s+/g, '-');
   231	
   232	  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
   233	  return withoutEdges.replace(/\/+/, '/');
   234	}
   235	
   236	function buildSlug(subdirectory = '') {
   237	  const normalized = sanitizeSubdirectory(subdirectory);
   238	  if (!normalized) {
   239	    return '';
   240	  }
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Updating regex pattern on line 233**
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Checking spacing near commas**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Correcting regex global flag usage**
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Preparing regex replacement fix**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..ea1ac2d64075fd291333d33503192194ed9b16cd
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Preparing patch for correct slash escaping**
file update
M /var/home/rick/Development/mega-directory/apps/admin/services/directoryPageService.js
@@ -232,3 +232,3 @@
   const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
-  return withoutEdges.replace(/\/+/, '/');
+  return withoutEdges.replace(/\/+/g, '/');
 }
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/admin/services/directoryPageService.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Verifying patch content**
exec
bash -lc "sed -n '223,235p' apps/admin/services/directoryPageService.js" in /var/home/rick/Development/mega-directory succeeded in 82ms:
function sanitizeSubdirectory(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const trimmed = value
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-');

  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
  return withoutEdges.replace(/\/+/g, '/');
}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Verifying and refining data sanitization and validation**

I’m working through ensuring all sanitization, normalization, and validation functions behave correctly—handling trimming, lowercasing, whitespace collapsing, uniqueness checks, and error returns as expected. I see tests cover most edge cases, and I’m thinking about when to run tests to confirm service reliability before moving on to UI steps.
Plan update
  ✓ Review task requirements and current admin code to outline UI/data needs
  ✓ Add failing tests covering directory page validation and persistence logic
  ✓ Implement directory page data store and service to satisfy tests
  → Build Express route, EJS view, and styles for the directory page management UI
  • Run relevant automated tests to verify changes
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Designing directory pages route and view**
exec
bash -lc 'rg -n "field-error" -n apps/admin/public/css/admin.css' in /var/home/rick/Development/mega-directory exited 1 in 95ms:

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Designing directory pages UI and route**

I'm mapping out the CSS styles for error messages and directory cards, then structuring the EJS view to handle creation and listing of directory pages with fields, error displays, and toggles. I'm planning the route logic to build a sanitized view model, handle create/update with validation, and integrate navigation and registration for this new directory pages feature.
file update
A /var/home/rick/Development/mega-directory/apps/admin/routes/directoryPages.js
const express = require('express');

const {
  getDirectoryPages,
  getDirectoryOptions,
  createDirectoryPage,
  updateDirectoryPages
} = require('../services/directoryPageService');

const router = express.Router();

router.get('/', (req, res) => {
  const savedCount = parseCount(req.query.saved);
  const createdCount = parseCount(req.query.created);
  const viewModel = buildViewModel({ savedCount, createdCount });

  res.render('directory-pages/index', {
    ...viewModel,
    active: 'directory-pages'
  });
});

router.post('/', (req, res) => {
  const intent = req.body?.intent;
  if (intent === 'create') {
    return handleCreate(req, res);
  }
  return handleBulkUpdate(req, res);
});

function handleCreate(req, res) {
  const payload = req.body?.newPage || {};
  const result = createDirectoryPage(payload);
  if (result.errors) {
    const viewModel = buildViewModel({
      creationErrors: result.errors,
      creationDraft: payload
    });

    return res.status(400).render('directory-pages/index', {
      ...viewModel,
      active: 'directory-pages'
    });
  }

  return res.redirect('/directory-pages?created=1');
}

function handleBulkUpdate(req, res) {
  const updates = normalizePagesPayload(req.body?.pages);
  const result = updateDirectoryPages(updates);

  if (result.errors) {
    const viewModel = buildViewModel({
      updateErrors: result.errors,
      savedCount: result.updated
    });

    return res.status(400).render('directory-pages/index', {
      ...viewModel,
      active: 'directory-pages'
    });
  }

  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
}

function buildSavedQuery(saved) {
  if (!Number.isFinite(saved) || saved <= 0) {
    return '';
  }
  const params = new URLSearchParams({ saved });
  return `?${params.toString()}`;
}

function normalizePagesPayload(payload) {
  if (!payload) {
    return [];
  }

  const entries = Array.isArray(payload) ? payload : Object.values(payload);
  return entries
    .map((entry) => entry || {})
    .map((entry) => ({
      id: entry.id,
      title: entry.title,
      categoryId: entry.categoryId,
      locationId: entry.locationId,
      locationAgnostic: entry.locationAgnostic,
      subdomain: entry.subdomain,
      subdirectory: entry.subdirectory,
      heroTitle: entry.heroTitle,
      heroSubtitle: entry.heroSubtitle,
      introMarkdown: entry.introMarkdown,
      metaTitle: entry.metaTitle,
      metaDescription: entry.metaDescription,
      metaKeywords: entry.metaKeywords,
      ogImageUrl: entry.ogImageUrl,
      save: entry.save,
      deactivate: entry.deactivate
    }));
}

function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
  const options = getDirectoryOptions();
  return {
    title: 'Directory Page Builder',
    pages: getDirectoryPages(),
    categories: options.categories,
    locations: options.locations,
    statuses: options.statuses,
    savedCount,
    createdCount,
    creationErrors,
    creationDraft,
    updateErrors
  };
}

function parseCount(value) {
  if (value === undefined) {
    return null;
  }
  const parsed = Number(value);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
}

module.exports = router;
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
A apps/admin/routes/directoryPages.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Designing directory pages admin view and styles**

I'm mapping out a detailed EJS view for managing directory pages with create and bulk update forms, including validations and error handling. I also need to add CSS grid layouts and responsive styles, update navigation to link to the new page, and register the route in the admin app. Before creating the view file, I'll ensure the views directory for directory-pages exists to keep things organized.
exec
bash -lc 'mkdir -p apps/admin/views/directory-pages' in /var/home/rick/Development/mega-directory succeeded in 100ms:

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}


thinking
**Composing the view template logic**
file update
A /var/home/rick/Development/mega-directory/apps/admin/views/directory-pages/index.ejs
<%
  const creationValues = creationDraft || {};
  const creationErr = creationErrors || {};
  const existingErrors = updateErrors || {};

  function fieldHasError(errors, key) {
    if (!errors) return false;
    return Boolean(errors[key]);
  }

  function fieldMessage(errors, key) {
    if (!errors) return null;
    return errors[key] || null;
  }
%>
<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
<section class="panel stack gap-lg directory-admin">
  <header class="panel-header">
    <div>
      <p class="eyebrow">Directories</p>
      <h2>Craft category + location pages</h2>
      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
    </div>
    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
  </header>

  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
  <% } %>
  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
  <% } %>

  <section class="stack gap-md directory-create">
    <div class="section-heading">
      <h3>Create a new directory page</h3>
      <p class="muted">Link a category and location, then provide metadata overrides.</p>
    </div>
    <form method="POST" action="/directory-pages" class="stack gap-md">
      <input type="hidden" name="intent" value="create" />
      <input type="hidden" name="newPage[locationAgnostic]" value="0" />

      <div class="field-grid">
        <label class="field-label">Page title
          <input
            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
            type="text"
            name="newPage[title]"
            value="<%= creationValues.title || '' %>"
            placeholder="Best Electricians in Austin" />
          <% if (fieldHasError(creationErr, 'title')) { %>
            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
          <% } %>
        </label>

        <label class="field-label">Category
          <select
            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
            name="newPage[categoryId]">
            <option value="">Select category</option>
            <% categories.forEach((category) => { %>
              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
            <% }) %>
          </select>
          <% if (fieldHasError(creationErr, 'categoryId')) { %>
            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
          <% } %>
        </label>

        <label class="field-label">Location (optional when agnostic)
          <select
            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
            name="newPage[locationId]">
            <option value="">Select location</option>
            <% locations.forEach((location) => { %>
              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
            <% }) %>
          </select>
          <% if (fieldHasError(creationErr, 'locationId')) { %>
            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
          <% } %>
        </label>

        <label class="toggle-label">
          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
          Location agnostic page
        </label>
      </div>

      <div class="field-grid">
        <label class="field-label">Subdomain
          <input
            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
            type="text"
            name="newPage[subdomain]"
            placeholder="austin-plumbers"
            value="<%= creationValues.subdomain || '' %>" />
          <% if (fieldHasError(creationErr, 'subdomain')) { %>
            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
          <% } %>
        </label>

        <label class="field-label">Subdirectory
          <input
            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
            type="text"
            name="newPage[subdirectory]"
            placeholder="austin-tx/plumbers"
            value="<%= creationValues.subdirectory || '' %>" />
          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
          <% } %>
        </label>
      </div>

      <div class="field-grid">
        <label class="field-label">Hero title
          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
        </label>
        <label class="field-label">Hero subtitle
          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
        </label>
      </div>

      <label class="field-label">Intro markdown
        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
      </label>

      <div class="field-grid">
        <label class="field-label">Meta title
          <input
            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
            type="text"
            name="newPage[metaTitle]"
            value="<%= creationValues.metaTitle || '' %>" />
          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
          <% } %>
        </label>
        <label class="field-label">Meta keywords
          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
        </label>
      </div>

      <label class="field-label">Meta description
        <textarea
          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
          name="newPage[metaDescription]"
          rows="3"
          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
        <% } %>
      </label>

      <label class="field-label">OG image URL
        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
      </label>

      <div class="form-actions">
        <button type="submit" class="btn primary">Create directory page</button>
        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
      </div>
    </form>
  </section>

  <section class="stack gap-md">
    <div class="section-heading">
      <h3>Edit existing pages</h3>
      <p class="muted">Toggle save/deactivate to control publish state.</p>
    </div>

    <% if (!pages.length) { %>
      <p class="empty-state">No directory pages yet. Create one above.</p>
    <% } else { %>
      <form method="POST" action="/directory-pages" class="stack gap-md">
        <input type="hidden" name="intent" value="bulk-update" />
        <div class="stack gap-md">
          <% pages.forEach((page, index) => { %>
            <% const errors = existingErrors[page.id]; %>
            <article class="directory-card stack gap-md">
              <header class="directory-card__header">
                <div>
                  <p class="eyebrow"><%= page.categoryLabel %></p>
                  <h4><%= page.title %></h4>
                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
                </div>
                <div class="directory-card__toggles">
                  <label class="toggle-label">
                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
                    Save / Publish
                  </label>
                  <label class="toggle-label">
                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
                    Deactivate
                  </label>
                </div>
              </header>

              <% if (errors) { %>
                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
                </div>
              <% } %>

              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />

              <div class="field-grid">
                <label class="field-label">Page title
                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
                  <% if (fieldHasError(errors, 'title')) { %>
                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
                  <% } %>
                </label>

                <label class="field-label">Category
                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
                    <option value="">Select category</option>
                    <% categories.forEach((category) => { %>
                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
                    <% }) %>
                  </select>
                  <% if (fieldHasError(errors, 'categoryId')) { %>
                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
                  <% } %>
                </label>

                <label class="field-label">Location
                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
                    <option value="">Select location</option>
                    <% locations.forEach((location) => { %>
                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
                    <% }) %>
                  </select>
                  <p class="location-note">Leave blank if location agnostic.</p>
                  <% if (fieldHasError(errors, 'locationId')) { %>
                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
                  <% } %>
                </label>

                <label class="toggle-label">
                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
                  Location agnostic directory
                </label>
              </div>

              <div class="field-grid">
                <label class="field-label">Subdomain
                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
                  <% if (fieldHasError(errors, 'subdomain')) { %>
                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
                  <% } %>
                </label>
                <label class="field-label">Subdirectory
                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
                  <% if (fieldHasError(errors, 'subdirectory')) { %>
                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
                  <% } %>
                </label>
              </div>

              <div class="field-grid">
                <label class="field-label">Hero title
                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
                </label>
                <label class="field-label">Hero subtitle
                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
                </label>
              </div>

              <label class="field-label">Intro markdown
                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
              </label>

              <div class="field-grid">
                <label class="field-label">Meta title
                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
                  <% if (fieldHasError(errors, 'metaTitle')) { %>
                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
                  <% } %>
                </label>
                <label class="field-label">Meta keywords
                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
                </label>
              </div>

              <label class="field-label">Meta description
                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
                <% if (fieldHasError(errors, 'metaDescription')) { %>
                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
                <% } %>
              </label>

              <label class="field-label">OG image URL
                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
              </label>
            </article>
          <% }) %>
        </div>

        <div class="form-actions">
          <button type="submit" class="btn primary">Save directory edits</button>
          <p class="muted">Updates apply immediately in this demo.</p>
        </div>
      </form>
    <% } %>
  </section>
</section>
<%- include('../partials/page-end') %>
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A apps/admin/views/directory-pages/index.ejs
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>


thinking
**Verifying data handling and preparing nav update**
file update
M /var/home/rick/Development/mega-directory/apps/admin/views/partials/page-start.ejs
@@ -18,2 +18,3 @@
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M apps/admin/views/partials/page-start.ejs
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Updating admin app routes**
file update
M /var/home/rick/Development/mega-directory/apps/admin/index.js
@@ -6,2 +6,3 @@
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
@@ -25,2 +26,3 @@
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M apps/admin/index.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Enhancing admin CSS styles**
file update
M /var/home/rick/Development/mega-directory/apps/admin/public/css/admin.css
@@ -178,2 +178,58 @@
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
apply_patch(auto_approved=true) exited 0 in 70ms:
Success. Updated the following files:
M apps/admin/public/css/admin.css
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1aa58c38b9b3da2a1262040fda8b64f173e37
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,128 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: payload
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Improving route data handling and UI adjustments**

I'm focusing on refining UI responsiveness and fixing data handling in the route. I'll implement a helper to sanitize creation draft data—especially converting checkbox strings like '0' to booleans—to prevent truthy pitfalls in the view. I'll also verify that error re-renders use this sanitized data and ensure the UI elements like `.directory-card__header` behave well on small screens. This involves adding a local `parseCheckbox` helper since the service's isn't exported, and updating the route accordingly.
file update
M /var/home/rick/Development/mega-directory/apps/admin/routes/directoryPages.js
@@ -36,3 +36,3 @@
       creationErrors: result.errors,
-      creationDraft: payload
+      creationDraft: buildCreationDraft(payload)
     });
@@ -127,2 +127,31 @@
 
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
 module.exports = router;
apply_patch(auto_approved=true) exited 0 in 49ms:
Success. Updated the following files:
M apps/admin/routes/directoryPages.js
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..653240f620f7a8933ce715b65e22a606025dd67a
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,311 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Enhancing view robustness with helpers**
file update
M /var/home/rick/Development/mega-directory/apps/admin/views/directory-pages/index.ejs
@@ -14,2 +14,11 @@
   }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
 %>
@@ -186,3 +195,3 @@
                   <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
-                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= new Date(page.updatedAt).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
                 </div>
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M apps/admin/views/directory-pages/index.ejs
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..b291c0a15527495a4a829b97e4bec57f5f33ee41
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..b291c0a15527495a4a829b97e4bec57f5f33ee41
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Updating status string handling**
file update
M /var/home/rick/Development/mega-directory/apps/admin/views/directory-pages/index.ejs
@@ -195,3 +195,3 @@
                   <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
-                  <p class="muted">Status <strong class="status-label"><%= page.status.toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
                 </div>
apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M apps/admin/views/directory-pages/index.ejs
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Preparing to run comprehensive tests**

I’m making sure all necessary variables, service functions, routes, and view logic are in place, including error handling and payload normalization. Next, I plan to run `npm test` from the repo root to verify all related tests pass without issues, confirming the recent changes are solid.
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory succeeded in 4.72s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 204.51837
  type: 'test'
  ...
1..1
# tests 1
# suites 0
# pass 1
# fail 0
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Marking test completion in plan**
Plan update
  ✓ Review task requirements and current admin code to outline UI/data needs
  ✓ Add failing tests covering directory page validation and persistence logic
  ✓ Implement directory page data store and service to satisfy tests
  ✓ Build Express route, EJS view, and styles for the directory page management UI
  ✓ Run relevant automated tests to verify changes
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Preparing final summary**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/mega-directory succeeded in 47ms:
## main...origin/main [ahead 5]
 M .env.example
?? .editorconfig
?? .vscode/
?? apps/
?? codex/LOGS/codex_run_2025-11-12_06-13-21.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log.done
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log.done
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log.done
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log.done
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log.done
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log
?? codex/TASKS/work_list
?? db/geography/
?? db/migrations/002_location_hierarchy.sql
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Summarizing directory admin changes**
exec
bash -lc 'nl -ba apps/admin/services/directoryPageService.js | head -n 40' in /var/home/rick/Development/mega-directory succeeded in 51ms:
nl: write error: Broken pipe
     1	const directoryPages = require('../data/directoryPages');
     2	const directoryOptions = require('../data/directoryPageOptions');
     3	
     4	const STATUSES = {
     5	  DRAFT: 'DRAFT',
     6	  ACTIVE: 'ACTIVE',
     7	  ARCHIVED: 'ARCHIVED'
     8	};
     9	
    10	function getDirectoryPages() {
    11	  return directoryPages.map((page) => ({
    12	    ...page,
    13	    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
    14	    locationLabel: page.locationAgnostic
    15	      ? 'Location agnostic'
    16	      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
    17	  }));
    18	}
    19	
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Gathering line numbers for context**
exec
bash -lc 'nl -ba apps/admin/routes/directoryPages.js | head -n 80' in /var/home/rick/Development/mega-directory succeeded in 47ms:
     1	const express = require('express');
     2	
     3	const {
     4	  getDirectoryPages,
     5	  getDirectoryOptions,
     6	  createDirectoryPage,
     7	  updateDirectoryPages
     8	} = require('../services/directoryPageService');
     9	
    10	const router = express.Router();
    11	
    12	router.get('/', (req, res) => {
    13	  const savedCount = parseCount(req.query.saved);
    14	  const createdCount = parseCount(req.query.created);
    15	  const viewModel = buildViewModel({ savedCount, createdCount });
    16	
    17	  res.render('directory-pages/index', {
    18	    ...viewModel,
    19	    active: 'directory-pages'
    20	  });
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Planning line number references**
exec
bash -lc 'rg -n "directory-card" apps/admin/public/css/admin.css' in /var/home/rick/Development/mega-directory succeeded in 44ms:
179:.directory-card {
186:.directory-card__header {
193:.directory-card__toggles {
230:.directory-card textarea,
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Searching for field-grid references**
exec
bash -lc 'rg -n "field-grid" apps/admin/public/css/admin.css' in /var/home/rick/Development/mega-directory succeeded in 58ms:
200:.field-grid {
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Searching for field-error occurrences**
exec
bash -lc 'rg -n "field-error" apps/admin/public/css/admin.css' in /var/home/rick/Development/mega-directory succeeded in 48ms:
210:.field-error {
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Checking line numbers for nav update**
exec
bash -lc 'nl -ba apps/admin/views/partials/page-start.ejs' in /var/home/rick/Development/mega-directory succeeded in 45ms:
     1	<!DOCTYPE html>
     2	<html lang="en">
     3	<head>
     4	  <meta charset="utf-8" />
     5	  <meta name="viewport" content="width=device-width, initial-scale=1" />
     6	  <title><%= title ? `${title} | ${appName}` : appName %></title>
     7	  <link rel="stylesheet" href="/css/admin.css" />
     8	</head>
     9	<body>
    10	  <header class="site-header">
    11	    <div class="container header-inner">
    12	      <div>
    13	        <p class="eyebrow">Internal</p>
    14	        <h1><%= appName %></h1>
    15	      </div>
    16	      <nav class="site-nav">
    17	        <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
    18	        <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
    19	        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
    20	        <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Checking line numbers in index.js**
exec
bash -lc 'nl -ba apps/admin/index.js' in /var/home/rick/Development/mega-directory succeeded in 57ms:
     1	const path = require('path');
     2	const express = require('express');
     3	
     4	const listingsRouter = require('./routes/listings');
     5	const seoRouter = require('./routes/seo');
     6	const categoryLocationsRouter = require('./routes/categoryLocations');
     7	const directoryPagesRouter = require('./routes/directoryPages');
     8	
     9	const app = express();
    10	const port = process.env.PORT || 4000;
    11	
    12	app.set('view engine', 'ejs');
    13	app.set('views', path.join(__dirname, 'views'));
    14	app.locals.appName = 'Mega Directory Admin';
    15	
    16	app.use(express.static(path.join(__dirname, 'public')));
    17	app.use(express.urlencoded({ extended: true }));
    18	app.use(express.json());
    19	
    20	app.get('/', (req, res) => {
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Checking file line numbers**
exec
bash -lc 'nl -ba apps/admin/data/directoryPages.js' in /var/home/rick/Development/mega-directory succeeded in 51ms:
     1	module.exports = [
     2	  {
     3	    id: 'dir_electricians_nyc',
     4	    title: 'Top Electricians in New York City',
     5	    slug: 'nyc-electricians',
     6	    categoryId: 'cat_electricians',
     7	    locationId: 'loc_new_york_ny',
     8	    locationAgnostic: false,
     9	    subdomain: 'nyc-electricians',
    10	    subdirectory: 'nyc/electricians',
    11	    heroTitle: 'Trusted NYC Electricians',
    12	    heroSubtitle: 'Hire vetted pros across all five boroughs',
    13	    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
    14	    metaTitle: 'Best Electricians in NYC | Mega Directory',
    15	    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
    16	    metaKeywords: 'electricians,nyc,licensed,emergency',
    17	    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
    18	    status: 'ACTIVE',
    19	    isActive: true,
    20	    createdAt: '2024-05-10T14:20:00-04:00',
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Counting lines in options file**
exec
bash -lc 'nl -ba apps/admin/data/directoryPageOptions.js' in /var/home/rick/Development/mega-directory succeeded in 42ms:
     1	module.exports = {
     2	  categories: [
     3	    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
     4	    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
     5	    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
     6	  ],
     7	  locations: [
     8	    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
     9	    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
    10	    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
    11	  ]
    12	};
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>


thinking
**Summarizing directory admin updates**
codex
**Directory Admin**
- Added a dedicated node:test suite to drive TDD for directory page creation/editing flows, covering required-field validation, uniqueness rules, location-agnostic handling, and save/deactivate toggles (apps/admin/test/directoryPageService.test.js:1).
- Seeded the in-memory store and option catalog used by the admin app, giving each directory record rich metadata for hero content, routing, and SEO overrides (apps/admin/data/directoryPages.js:1, apps/admin/data/directoryPageOptions.js:1).
- Implemented `directoryPageService` with getters, create/update logic, normalization, and reusable validators so UI actions always enforce category/location linkage, slug/subdomain uniqueness, and metadata requirements (apps/admin/services/directoryPageService.js:1).
- Built an Express router plus a comprehensive EJS management view that surfaces creation and bulk-edit forms, inline validation errors, and status toggles for publish/deactivate workflows (apps/admin/routes/directoryPages.js:1, apps/admin/views/directory-pages/index.ejs:1).
- Wired the new module into the shell (nav + server) and extended the admin stylesheet with directory-card layouts, grid helpers, toggle styles, and error states to keep the UX consistent (apps/admin/index.js:4, apps/admin/views/partials/page-start.ejs:17, apps/admin/public/css/admin.css:179).

Tests:
- `npm test`

Next: integrate this UI with the real API once those endpoints are available so the service can persist to Postgres instead of the in-memory store.
file update:
diff --git a/apps/admin/data/directoryPageOptions.js b/apps/admin/data/directoryPageOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3717515680daee93ff853702c217228cf80fdbd
--- /dev/null
+++ b/apps/admin/data/directoryPageOptions.js
@@ -0,0 +1,12 @@
+module.exports = {
+  categories: [
+    { id: 'cat_electricians', label: 'Electricians', slug: 'electricians' },
+    { id: 'cat_plumbers', label: 'Plumbers', slug: 'plumbers' },
+    { id: 'cat_solar_installers', label: 'Solar Installers', slug: 'solar-installers' }
+  ],
+  locations: [
+    { id: 'loc_new_york_ny', label: 'New York, NY', slug: 'nyc-ny', region: 'NY', country: 'US' },
+    { id: 'loc_atlanta_ga', label: 'Atlanta, GA', slug: 'atlanta-ga', region: 'GA', country: 'US' },
+    { id: 'loc_remote_nationwide', label: 'Remote / Nationwide', slug: 'remote', region: null, country: 'US' }
+  ]
+};
diff --git a/apps/admin/data/directoryPages.js b/apps/admin/data/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..d12c310d7e5b4f4acae766dfa6000fe75b4a8c31
--- /dev/null
+++ b/apps/admin/data/directoryPages.js
@@ -0,0 +1,44 @@
+module.exports = [
+  {
+    id: 'dir_electricians_nyc',
+    title: 'Top Electricians in New York City',
+    slug: 'nyc-electricians',
+    categoryId: 'cat_electricians',
+    locationId: 'loc_new_york_ny',
+    locationAgnostic: false,
+    subdomain: 'nyc-electricians',
+    subdirectory: 'nyc/electricians',
+    heroTitle: 'Trusted NYC Electricians',
+    heroSubtitle: 'Hire vetted pros across all five boroughs',
+    introMarkdown: 'Compare **licensed electricians** ready for panel upgrades, EV chargers, and emergency calls.',
+    metaTitle: 'Best Electricians in NYC | Mega Directory',
+    metaDescription: 'Browse vetted electricians for Manhattan, Brooklyn, Queens, the Bronx, and Staten Island.',
+    metaKeywords: 'electricians,nyc,licensed,emergency',
+    ogImageUrl: 'https://cdn.example.com/og/nyc-electricians.png',
+    status: 'ACTIVE',
+    isActive: true,
+    createdAt: '2024-05-10T14:20:00-04:00',
+    updatedAt: '2024-05-20T09:45:00-04:00'
+  },
+  {
+    id: 'dir_plumbers_atl',
+    title: 'Atlanta Plumbers Guide',
+    slug: 'atlanta-plumbers',
+    categoryId: 'cat_plumbers',
+    locationId: 'loc_atlanta_ga',
+    locationAgnostic: false,
+    subdomain: 'atlanta-plumbers',
+    subdirectory: 'atlanta-ga/plumbers',
+    heroTitle: 'Metro Atlanta Plumbers',
+    heroSubtitle: 'Same-day help across Fulton, DeKalb, and Cobb counties',
+    introMarkdown: 'From drain cleaning to tankless installs, find **verified crews** with solid reviews.',
+    metaTitle: 'Atlanta Plumbers | Mega Directory',
+    metaDescription: 'Find drain, sewer, and water heater specialists serving the greater Atlanta metro.',
+    metaKeywords: 'plumbers,atlanta,water heater,drain cleaning',
+    ogImageUrl: 'https://cdn.example.com/og/atl-plumbers.png',
+    status: 'DRAFT',
+    isActive: false,
+    createdAt: '2024-05-11T08:05:00-04:00',
+    updatedAt: '2024-05-19T10:10:00-04:00'
+  }
+];
diff --git a/apps/admin/index.js b/apps/admin/index.js
index 28cd64c90e99b4ff3d480ef8958ca1d06c2fc5f7..c8cba2ac40d455a38ea504a5e1f4e42efd6a583c
--- a/apps/admin/index.js
+++ b/apps/admin/index.js
@@ -4,6 +4,7 @@
 const listingsRouter = require('./routes/listings');
 const seoRouter = require('./routes/seo');
 const categoryLocationsRouter = require('./routes/categoryLocations');
+const directoryPagesRouter = require('./routes/directoryPages');
 
 const app = express();
 const port = process.env.PORT || 4000;
@@ -23,6 +24,7 @@
 app.use('/listings', listingsRouter);
 app.use('/seo', seoRouter);
 app.use('/category-locations', categoryLocationsRouter);
+app.use('/directory-pages', directoryPagesRouter);
 
 app.use((req, res) => {
   res.status(404).render('errors/not-found', {
diff --git a/apps/admin/public/css/admin.css b/apps/admin/public/css/admin.css
index 88c88e18aff77221ccf2b5ff73c4fb833ef85a55..c532b3fa8e8a1a3c81107e206eb2f141d311d6cb
--- a/apps/admin/public/css/admin.css
+++ b/apps/admin/public/css/admin.css
@@ -176,6 +176,62 @@
   padding: 1.5rem;
 }
 
+.directory-card {
+  border: 1px solid var(--border-color);
+  border-radius: 14px;
+  padding: 1.5rem;
+  background: #fff;
+}
+
+.directory-card__header {
+  display: flex;
+  justify-content: space-between;
+  gap: 1rem;
+  flex-wrap: wrap;
+}
+
+.directory-card__toggles {
+  display: flex;
+  gap: 1rem;
+  align-items: center;
+  flex-wrap: wrap;
+}
+
+.field-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  gap: 1rem;
+}
+
+.field-control.is-invalid {
+  border-color: #b91c1c;
+}
+
+.field-error {
+  color: #b91c1c;
+  font-size: 0.85rem;
+  margin-top: 0.25rem;
+}
+
+.toggle-label {
+  display: inline-flex;
+  align-items: center;
+  gap: 0.4rem;
+  font-weight: 500;
+  color: var(--text-muted);
+}
+
+.location-note {
+  font-size: 0.85rem;
+  color: var(--text-muted);
+  margin-top: 0.25rem;
+}
+
+.directory-card textarea,
+.directory-create textarea {
+  min-height: 100px;
+}
+
 .listing-card__header {
   display: flex;
   justify-content: space-between;
diff --git a/apps/admin/routes/directoryPages.js b/apps/admin/routes/directoryPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..8f99882354868ca5777eba35b1ea99f388dddd4d
--- /dev/null
+++ b/apps/admin/routes/directoryPages.js
@@ -0,0 +1,157 @@
+const express = require('express');
+
+const {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const router = express.Router();
+
+router.get('/', (req, res) => {
+  const savedCount = parseCount(req.query.saved);
+  const createdCount = parseCount(req.query.created);
+  const viewModel = buildViewModel({ savedCount, createdCount });
+
+  res.render('directory-pages/index', {
+    ...viewModel,
+    active: 'directory-pages'
+  });
+});
+
+router.post('/', (req, res) => {
+  const intent = req.body?.intent;
+  if (intent === 'create') {
+    return handleCreate(req, res);
+  }
+  return handleBulkUpdate(req, res);
+});
+
+function handleCreate(req, res) {
+  const payload = req.body?.newPage || {};
+  const result = createDirectoryPage(payload);
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      creationErrors: result.errors,
+      creationDraft: buildCreationDraft(payload)
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect('/directory-pages?created=1');
+}
+
+function handleBulkUpdate(req, res) {
+  const updates = normalizePagesPayload(req.body?.pages);
+  const result = updateDirectoryPages(updates);
+
+  if (result.errors) {
+    const viewModel = buildViewModel({
+      updateErrors: result.errors,
+      savedCount: result.updated
+    });
+
+    return res.status(400).render('directory-pages/index', {
+      ...viewModel,
+      active: 'directory-pages'
+    });
+  }
+
+  return res.redirect(`/directory-pages${buildSavedQuery(result.updated)}`);
+}
+
+function buildSavedQuery(saved) {
+  if (!Number.isFinite(saved) || saved <= 0) {
+    return '';
+  }
+  const params = new URLSearchParams({ saved });
+  return `?${params.toString()}`;
+}
+
+function normalizePagesPayload(payload) {
+  if (!payload) {
+    return [];
+  }
+
+  const entries = Array.isArray(payload) ? payload : Object.values(payload);
+  return entries
+    .map((entry) => entry || {})
+    .map((entry) => ({
+      id: entry.id,
+      title: entry.title,
+      categoryId: entry.categoryId,
+      locationId: entry.locationId,
+      locationAgnostic: entry.locationAgnostic,
+      subdomain: entry.subdomain,
+      subdirectory: entry.subdirectory,
+      heroTitle: entry.heroTitle,
+      heroSubtitle: entry.heroSubtitle,
+      introMarkdown: entry.introMarkdown,
+      metaTitle: entry.metaTitle,
+      metaDescription: entry.metaDescription,
+      metaKeywords: entry.metaKeywords,
+      ogImageUrl: entry.ogImageUrl,
+      save: entry.save,
+      deactivate: entry.deactivate
+    }));
+}
+
+function buildViewModel({ savedCount = null, createdCount = null, creationErrors = null, creationDraft = null, updateErrors = null } = {}) {
+  const options = getDirectoryOptions();
+  return {
+    title: 'Directory Page Builder',
+    pages: getDirectoryPages(),
+    categories: options.categories,
+    locations: options.locations,
+    statuses: options.statuses,
+    savedCount,
+    createdCount,
+    creationErrors,
+    creationDraft,
+    updateErrors
+  };
+}
+
+function parseCount(value) {
+  if (value === undefined) {
+    return null;
+  }
+  const parsed = Number(value);
+  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
+}
+
+function buildCreationDraft(payload = {}) {
+  return {
+    title: payload.title || '',
+    categoryId: payload.categoryId || '',
+    locationId: payload.locationId || '',
+    locationAgnostic: parseCheckbox(payload.locationAgnostic),
+    subdomain: payload.subdomain || '',
+    subdirectory: payload.subdirectory || '',
+    heroTitle: payload.heroTitle || '',
+    heroSubtitle: payload.heroSubtitle || '',
+    introMarkdown: payload.introMarkdown || '',
+    metaTitle: payload.metaTitle || '',
+    metaDescription: payload.metaDescription || '',
+    metaKeywords: payload.metaKeywords || '',
+    ogImageUrl: payload.ogImageUrl || ''
+  };
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+  return Boolean(value);
+}
+
+module.exports = router;
diff --git a/apps/admin/services/directoryPageService.js b/apps/admin/services/directoryPageService.js
new file mode 100644
index 0000000000000000000000000000000000000000..f86980d097af4e5f94708e8cd3a860808d64e3c3
--- /dev/null
+++ b/apps/admin/services/directoryPageService.js
@@ -0,0 +1,329 @@
+const directoryPages = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+
+const STATUSES = {
+  DRAFT: 'DRAFT',
+  ACTIVE: 'ACTIVE',
+  ARCHIVED: 'ARCHIVED'
+};
+
+function getDirectoryPages() {
+  return directoryPages.map((page) => ({
+    ...page,
+    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
+    locationLabel: page.locationAgnostic
+      ? 'Location agnostic'
+      : resolveLocation(page.locationId)?.label ?? 'Unknown location'
+  }));
+}
+
+function getDirectoryOptions() {
+  return {
+    categories: directoryOptions.categories.slice(),
+    locations: directoryOptions.locations.slice(),
+    statuses: Object.values(STATUSES)
+  };
+}
+
+function createDirectoryPage(payload = {}) {
+  const { record, errors } = normalizePayload(payload, { mode: 'create' });
+  if (hasErrors(errors)) {
+    return { errors };
+  }
+
+  const timestamp = new Date().toISOString();
+  const storedRecord = {
+    ...record,
+    id: record.id || generateId(record.title),
+    createdAt: timestamp,
+    updatedAt: timestamp,
+    status: STATUSES.DRAFT,
+    isActive: false
+  };
+
+  directoryPages.push(storedRecord);
+  return { record: storedRecord, errors: null };
+}
+
+function updateDirectoryPages(updates = []) {
+  if (!Array.isArray(updates) || updates.length === 0) {
+    return { updated: 0, errors: null };
+  }
+
+  let updated = 0;
+  const errorBag = {};
+
+  updates.forEach((payload) => {
+    if (!payload?.id) {
+      return;
+    }
+
+    const record = directoryPages.find((entry) => entry.id === payload.id);
+    if (!record) {
+      return;
+    }
+
+    const { record: nextState, errors } = normalizePayload(payload, {
+      mode: 'update',
+      existingRecord: record
+    });
+
+    if (hasErrors(errors)) {
+      errorBag[record.id] = errors;
+      return;
+    }
+
+    Object.assign(record, nextState);
+
+    if (parseCheckbox(payload.deactivate)) {
+      record.status = STATUSES.ARCHIVED;
+      record.isActive = false;
+    } else if (parseCheckbox(payload.save)) {
+      record.status = STATUSES.ACTIVE;
+      record.isActive = true;
+    }
+
+    record.updatedAt = new Date().toISOString();
+    updated += 1;
+  });
+
+  return {
+    updated,
+    errors: Object.keys(errorBag).length ? errorBag : null
+  };
+}
+
+function normalizePayload(payload = {}, { mode, existingRecord } = {}) {
+  if (mode === 'update' && !existingRecord) {
+    throw new Error('existingRecord is required for update mode');
+  }
+
+  const baseRecord = existingRecord
+    ? { ...existingRecord }
+    : {
+        id: null,
+        title: '',
+        slug: '',
+        categoryId: '',
+        locationId: null,
+        locationAgnostic: false,
+        subdomain: '',
+        subdirectory: '',
+        heroTitle: '',
+        heroSubtitle: '',
+        introMarkdown: '',
+        metaTitle: '',
+        metaDescription: '',
+        metaKeywords: '',
+        ogImageUrl: '',
+        status: STATUSES.DRAFT,
+        isActive: false,
+        createdAt: null,
+        updatedAt: null
+      };
+
+  const next = { ...baseRecord };
+  const errors = {};
+
+  assignString(next, payload, 'title');
+  assignString(next, payload, 'heroTitle');
+  assignString(next, payload, 'heroSubtitle');
+  assignString(next, payload, 'introMarkdown');
+  assignString(next, payload, 'metaTitle');
+  assignString(next, payload, 'metaDescription');
+  assignString(next, payload, 'metaKeywords', { collapseWhitespace: true });
+  assignString(next, payload, 'ogImageUrl');
+
+  if (payload.categoryId !== undefined || mode === 'create') {
+    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
+    next.categoryId = value || '';
+  }
+
+  if (payload.locationAgnostic !== undefined || mode === 'create') {
+    next.locationAgnostic = parseCheckbox(payload.locationAgnostic);
+  }
+
+  if (payload.locationId !== undefined) {
+    const value = typeof payload.locationId === 'string' ? payload.locationId.trim() : '';
+    next.locationId = value || null;
+  } else if (!existingRecord && next.locationId === undefined) {
+    next.locationId = null;
+  }
+
+  if (next.locationAgnostic) {
+    next.locationId = null;
+  }
+
+  if (payload.subdomain !== undefined || mode === 'create') {
+    next.subdomain = sanitizeSubdomain(payload.subdomain);
+  }
+
+  if (payload.subdirectory !== undefined || mode === 'create') {
+    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
+    next.slug = buildSlug(next.subdirectory);
+  } else if (!next.slug && next.subdirectory) {
+    next.slug = buildSlug(next.subdirectory);
+  }
+
+  validateRecord(next, errors, { mode, currentId: existingRecord?.id ?? null });
+
+  return { record: next, errors };
+}
+
+function validateRecord(record, errors, { mode, currentId }) {
+  if (!record.title) {
+    errors.title = 'Title is required';
+  }
+
+  if (!record.categoryId || !resolveCategory(record.categoryId)) {
+    errors.categoryId = 'Select a valid category';
+  }
+
+  if (!record.metaTitle) {
+    errors.metaTitle = 'Meta title is required';
+  }
+
+  if (!record.metaDescription) {
+    errors.metaDescription = 'Meta description is required';
+  }
+
+  if (!record.subdomain) {
+    errors.subdomain = 'Subdomain is required';
+  } else if (!isUnique('subdomain', record.subdomain, currentId)) {
+    errors.subdomain = 'Subdomain is already in use';
+  }
+
+  if (!record.subdirectory) {
+    errors.subdirectory = 'Subdirectory is required';
+  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
+    errors.subdirectory = 'Subdirectory is already in use';
+  }
+
+  if (!record.locationAgnostic) {
+    if (!record.locationId) {
+      errors.locationId = 'Select a location';
+    } else if (!resolveLocation(record.locationId)) {
+      errors.locationId = 'Select a valid location';
+    }
+  }
+}
+
+function sanitizeSubdomain(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  return value
+    .trim()
+    .toLowerCase()
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function sanitizeSubdirectory(value) {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value
+    .trim()
+    .toLowerCase()
+    .replace(/\s+/g, '-');
+
+  const withoutEdges = trimmed.replace(/^\/+|\/+$/g, '');
+  return withoutEdges.replace(/\/+/g, '/');
+}
+
+function buildSlug(subdirectory = '') {
+  const normalized = sanitizeSubdirectory(subdirectory);
+  if (!normalized) {
+    return '';
+  }
+  return normalized
+    .replace(/\//g, '-')
+    .replace(/[^a-z0-9-]/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
+
+function assignString(target, payload, field, { collapseWhitespace = false } = {}) {
+  if (payload[field] === undefined) {
+    return;
+  }
+
+  if (typeof payload[field] !== 'string') {
+    target[field] = '';
+    return;
+  }
+
+  const value = collapseWhitespace
+    ? collapseSpaces(payload[field])
+    : payload[field].trim();
+  target[field] = value;
+}
+
+function collapseSpaces(value) {
+  return value.trim().replace(/\s+/g, ' ');
+}
+
+function resolveCategory(id) {
+  return directoryOptions.categories.find((entry) => entry.id === id) || null;
+}
+
+function resolveLocation(id) {
+  if (!id) {
+    return null;
+  }
+  return directoryOptions.locations.find((entry) => entry.id === id) || null;
+}
+
+function isUnique(field, value, currentId = null) {
+  if (!value) {
+    return true;
+  }
+
+  const normalized = value.toLowerCase();
+  return !directoryPages.some((entry) => {
+    if (!entry[field]) {
+      return false;
+    }
+    if (currentId && entry.id === currentId) {
+      return false;
+    }
+    return entry[field].toLowerCase() === normalized;
+  });
+}
+
+function parseCheckbox(value) {
+  if (Array.isArray(value)) {
+    return value.some((entry) => parseCheckbox(entry));
+  }
+
+  if (typeof value === 'string') {
+    const normalized = value.trim().toLowerCase();
+    return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
+  }
+
+  return Boolean(value);
+}
+
+function generateId(title = 'directory_page') {
+  const suffix = title
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '')
+    .slice(0, 32) || 'entry';
+  return `dir_${suffix}_${Date.now()}`;
+}
+
+function hasErrors(errors) {
+  return errors && Object.keys(errors).length > 0;
+}
+
+module.exports = {
+  getDirectoryPages,
+  getDirectoryOptions,
+  createDirectoryPage,
+  updateDirectoryPages,
+  STATUSES
+};
diff --git a/apps/admin/test/directoryPageService.test.js b/apps/admin/test/directoryPageService.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..066d9877ce4d09919133c7ebc32a7e152d3c6eec
--- /dev/null
+++ b/apps/admin/test/directoryPageService.test.js
@@ -0,0 +1,168 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+
+const directoryStore = require('../data/directoryPages');
+const directoryOptions = require('../data/directoryPageOptions');
+const {
+  createDirectoryPage,
+  updateDirectoryPages
+} = require('../services/directoryPageService');
+
+const originalStore = deepClone(directoryStore);
+
+function resetStore() {
+  directoryStore.splice(0, directoryStore.length, ...deepClone(originalStore));
+}
+
+test('createDirectoryPage enforces required fields and uniqueness', () => {
+  resetStore();
+
+  const initialLength = directoryStore.length;
+  const invalid = createDirectoryPage({
+    title: '',
+    categoryId: '',
+    locationId: '',
+    subdomain: '  ',
+    subdirectory: '',
+    locationAgnostic: false,
+    metaTitle: '',
+    metaDescription: ''
+  });
+
+  assert.ok(invalid.errors);
+  assert.deepStrictEqual(
+    Object.keys(invalid.errors).sort(),
+    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
+  );
+  assert.strictEqual(directoryStore.length, initialLength);
+
+  const existing = directoryStore[0];
+  assert.ok(existing, 'expected seed directory pages for tests');
+
+  const duplicate = createDirectoryPage({
+    title: 'Duplicate Attempt',
+    categoryId: existing.categoryId,
+    locationId: existing.locationId,
+    subdomain: existing.subdomain,
+    subdirectory: existing.subdirectory,
+    locationAgnostic: Boolean(existing.locationAgnostic),
+    metaTitle: 'Example',
+    metaDescription: 'Example description'
+  });
+
+  assert.ok(duplicate.errors.subdomain);
+  assert.ok(duplicate.errors.subdirectory);
+  assert.strictEqual(directoryStore.length, initialLength);
+});
+
+test('createDirectoryPage accepts location-agnostic directories and normalizes fields', () => {
+  resetStore();
+
+  const category = directoryOptions.categories?.[0];
+  assert.ok(category, 'expected at least one category option');
+
+  const result = createDirectoryPage({
+    title: '  Remote Support Specialists  ',
+    categoryId: category.id,
+    locationAgnostic: true,
+    locationId: '',
+    subdomain: '  remote-support ',
+    subdirectory: '  remote/support  ',
+    metaTitle: '  Remote Support Pros  ',
+    metaDescription: '  Nationwide remote troubleshooting help.  ',
+    metaKeywords: '  support, remote, it  ',
+    ogImageUrl: 'https://cdn.example.com/images/remote.png',
+    heroTitle: '  Remote Experts  ',
+    heroSubtitle: '  Help desk on demand  ',
+    introMarkdown: '  **Get help** anytime.  '
+  });
+
+  assert.ifError(result.errors);
+  assert.ok(result.record?.id);
+  assert.strictEqual(result.record.title, 'Remote Support Specialists');
+  assert.strictEqual(result.record.locationId, null);
+  assert.strictEqual(result.record.locationAgnostic, true);
+  assert.strictEqual(result.record.subdomain, 'remote-support');
+  assert.strictEqual(result.record.subdirectory, 'remote/support');
+  assert.strictEqual(result.record.metaTitle, 'Remote Support Pros');
+  assert.strictEqual(result.record.metaDescription, 'Nationwide remote troubleshooting help.');
+  assert.strictEqual(result.record.metaKeywords, 'support, remote, it');
+  assert.strictEqual(directoryStore.at(-1).id, result.record.id);
+});
+
+test('updateDirectoryPages applies edits and handles save/deactivate toggles', () => {
+  resetStore();
+
+  const target = directoryStore[0];
+  assert.ok(target, 'expected at least one seed directory page');
+
+  const updatedTitle = `${target.title} (Refreshed)`;
+  const updateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      title: updatedTitle,
+      heroTitle: 'Updated Hero',
+      heroSubtitle: 'Updated Subtitle',
+      introMarkdown: 'Updated intro',
+      metaTitle: 'Updated Meta Title',
+      metaDescription: '  Trim this description   ',
+      metaKeywords: 'alpha, beta, gamma',
+      ogImageUrl: 'https://cdn.example.com/og/new.png',
+      save: true
+    }
+  ]);
+
+  assert.strictEqual(updateResult.updated, 1);
+  assert.ok(!updateResult.errors || Object.keys(updateResult.errors).length === 0);
+  assert.strictEqual(target.title, updatedTitle);
+  assert.strictEqual(target.heroTitle, 'Updated Hero');
+  assert.strictEqual(target.heroSubtitle, 'Updated Subtitle');
+  assert.strictEqual(target.introMarkdown, 'Updated intro');
+  assert.strictEqual(target.metaDescription, 'Trim this description');
+  assert.strictEqual(target.status, 'ACTIVE');
+  assert.strictEqual(target.isActive, true);
+
+  const deactivateResult = updateDirectoryPages([
+    {
+      id: target.id,
+      deactivate: true
+    }
+  ]);
+
+  assert.strictEqual(deactivateResult.updated, 1);
+  assert.strictEqual(target.status, 'ARCHIVED');
+  assert.strictEqual(target.isActive, false);
+});
+
+test('updateDirectoryPages rejects conflicts and invalid location assignments', () => {
+  resetStore();
+
+  assert.ok(directoryStore.length >= 2, 'expected multiple directory pages for conflict tests');
+  const first = directoryStore[0];
+  const second = directoryStore[1];
+
+  const conflict = updateDirectoryPages([
+    {
+      id: second.id,
+      subdomain: first.subdomain
+    }
+  ]);
+
+  assert.strictEqual(conflict.updated, 0);
+  assert.ok(conflict.errors?.[second.id]?.subdomain);
+
+  const invalidLocation = updateDirectoryPages([
+    {
+      id: second.id,
+      locationAgnostic: false,
+      locationId: ''
+    }
+  ]);
+
+  assert.strictEqual(invalidLocation.updated, 0);
+  assert.ok(invalidLocation.errors?.[second.id]?.locationId);
+});
+
+function deepClone(value) {
+  return JSON.parse(JSON.stringify(value));
+}
diff --git a/apps/admin/views/directory-pages/index.ejs b/apps/admin/views/directory-pages/index.ejs
new file mode 100644
index 0000000000000000000000000000000000000000..91d522fea2d95c55dac91d11b53e09f619a2f39f
--- /dev/null
+++ b/apps/admin/views/directory-pages/index.ejs
@@ -0,0 +1,320 @@
+<%
+  const creationValues = creationDraft || {};
+  const creationErr = creationErrors || {};
+  const existingErrors = updateErrors || {};
+
+  function fieldHasError(errors, key) {
+    if (!errors) return false;
+    return Boolean(errors[key]);
+  }
+
+  function fieldMessage(errors, key) {
+    if (!errors) return null;
+    return errors[key] || null;
+  }
+
+  function formatTimestamp(value) {
+    if (!value) return 'Unknown';
+    const date = new Date(value);
+    if (Number.isNaN(date.getTime())) {
+      return 'Unknown';
+    }
+    return date.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
+  }
+%>
+<%- include('../partials/page-start', { title: title || 'Directory Page Builder', active }) %>
+<section class="panel stack gap-lg directory-admin">
+  <header class="panel-header">
+    <div>
+      <p class="eyebrow">Directories</p>
+      <h2>Craft category + location pages</h2>
+      <p class="muted">Set routing, hero copy, and SEO metadata for each directory page before publishing.</p>
+    </div>
+    <div class="badge">Total pages <strong><%= pages.length %></strong></div>
+  </header>
+
+  <% if (typeof createdCount === 'number' && createdCount > 0) { %>
+    <div class="alert success">Created <strong><%= createdCount %></strong> new directory page.</div>
+  <% } %>
+  <% if (typeof savedCount === 'number' && savedCount > 0) { %>
+    <div class="alert success">Saved <strong><%= savedCount %></strong> director<%= savedCount === 1 ? 'y' : 'ies' %>.</div>
+  <% } %>
+
+  <section class="stack gap-md directory-create">
+    <div class="section-heading">
+      <h3>Create a new directory page</h3>
+      <p class="muted">Link a category and location, then provide metadata overrides.</p>
+    </div>
+    <form method="POST" action="/directory-pages" class="stack gap-md">
+      <input type="hidden" name="intent" value="create" />
+      <input type="hidden" name="newPage[locationAgnostic]" value="0" />
+
+      <div class="field-grid">
+        <label class="field-label">Page title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'title') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[title]"
+            value="<%= creationValues.title || '' %>"
+            placeholder="Best Electricians in Austin" />
+          <% if (fieldHasError(creationErr, 'title')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'title') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Category
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'categoryId') ? 'is-invalid' : '' %>"
+            name="newPage[categoryId]">
+            <option value="">Select category</option>
+            <% categories.forEach((category) => { %>
+              <option value="<%= category.id %>" <%= creationValues.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'categoryId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'categoryId') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Location (optional when agnostic)
+          <select
+            class="field-control <%= fieldHasError(creationErr, 'locationId') ? 'is-invalid' : '' %>"
+            name="newPage[locationId]">
+            <option value="">Select location</option>
+            <% locations.forEach((location) => { %>
+              <option value="<%= location.id %>" <%= creationValues.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+            <% }) %>
+          </select>
+          <% if (fieldHasError(creationErr, 'locationId')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'locationId') %></p>
+          <% } %>
+        </label>
+
+        <label class="toggle-label">
+          <input type="checkbox" name="newPage[locationAgnostic]" value="1" <%= creationValues.locationAgnostic ? 'checked' : '' %> />
+          Location agnostic page
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Subdomain
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdomain') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdomain]"
+            placeholder="austin-plumbers"
+            value="<%= creationValues.subdomain || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdomain')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdomain') %></p>
+          <% } %>
+        </label>
+
+        <label class="field-label">Subdirectory
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'subdirectory') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[subdirectory]"
+            placeholder="austin-tx/plumbers"
+            value="<%= creationValues.subdirectory || '' %>" />
+          <% if (fieldHasError(creationErr, 'subdirectory')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'subdirectory') %></p>
+          <% } %>
+        </label>
+      </div>
+
+      <div class="field-grid">
+        <label class="field-label">Hero title
+          <input class="field-control" type="text" name="newPage[heroTitle]" value="<%= creationValues.heroTitle || '' %>" />
+        </label>
+        <label class="field-label">Hero subtitle
+          <input class="field-control" type="text" name="newPage[heroSubtitle]" value="<%= creationValues.heroSubtitle || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Intro markdown
+        <textarea class="field-control" name="newPage[introMarkdown]" rows="3" placeholder="Short intro copy."><%= creationValues.introMarkdown || '' %></textarea>
+      </label>
+
+      <div class="field-grid">
+        <label class="field-label">Meta title
+          <input
+            class="field-control <%= fieldHasError(creationErr, 'metaTitle') ? 'is-invalid' : '' %>"
+            type="text"
+            name="newPage[metaTitle]"
+            value="<%= creationValues.metaTitle || '' %>" />
+          <% if (fieldHasError(creationErr, 'metaTitle')) { %>
+            <p class="field-error"><%= fieldMessage(creationErr, 'metaTitle') %></p>
+          <% } %>
+        </label>
+        <label class="field-label">Meta keywords
+          <input class="field-control" type="text" name="newPage[metaKeywords]" value="<%= creationValues.metaKeywords || '' %>" />
+        </label>
+      </div>
+
+      <label class="field-label">Meta description
+        <textarea
+          class="field-control <%= fieldHasError(creationErr, 'metaDescription') ? 'is-invalid' : '' %>"
+          name="newPage[metaDescription]"
+          rows="3"
+          placeholder="150-160 characters ideal."><%= creationValues.metaDescription || '' %></textarea>
+        <% if (fieldHasError(creationErr, 'metaDescription')) { %>
+          <p class="field-error"><%= fieldMessage(creationErr, 'metaDescription') %></p>
+        <% } %>
+      </label>
+
+      <label class="field-label">OG image URL
+        <input class="field-control" type="url" name="newPage[ogImageUrl]" placeholder="https://cdn.example.com/og.png" value="<%= creationValues.ogImageUrl || '' %>" />
+      </label>
+
+      <div class="form-actions">
+        <button type="submit" class="btn primary">Create directory page</button>
+        <p class="muted">Entries are stored in-memory until API wiring is completed.</p>
+      </div>
+    </form>
+  </section>
+
+  <section class="stack gap-md">
+    <div class="section-heading">
+      <h3>Edit existing pages</h3>
+      <p class="muted">Toggle save/deactivate to control publish state.</p>
+    </div>
+
+    <% if (!pages.length) { %>
+      <p class="empty-state">No directory pages yet. Create one above.</p>
+    <% } else { %>
+      <form method="POST" action="/directory-pages" class="stack gap-md">
+        <input type="hidden" name="intent" value="bulk-update" />
+        <div class="stack gap-md">
+          <% pages.forEach((page, index) => { %>
+            <% const errors = existingErrors[page.id]; %>
+            <article class="directory-card stack gap-md">
+              <header class="directory-card__header">
+                <div>
+                  <p class="eyebrow"><%= page.categoryLabel %></p>
+                  <h4><%= page.title %></h4>
+                  <p class="muted">Location: <strong><%= page.locationLabel %></strong></p>
+                  <p class="muted">Status <strong class="status-label"><%= (page.status || 'draft').toLowerCase() %></strong> • Updated <strong><%= formatTimestamp(page.updatedAt) %></strong></p>
+                </div>
+                <div class="directory-card__toggles">
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][save]" value="1" <%= page.isActive ? 'checked' : '' %> />
+                    Save / Publish
+                  </label>
+                  <label class="toggle-label">
+                    <input type="checkbox" name="pages[<%= index %>][deactivate]" value="1" <%= !page.isActive && page.status === 'ARCHIVED' ? 'checked' : '' %> />
+                    Deactivate
+                  </label>
+                </div>
+              </header>
+
+              <% if (errors) { %>
+                <div class="alert" style="background:#fef2f2;color:#b91c1c;">
+                  <strong>Fix required:</strong> <%= Object.values(errors).join(', ') %>
+                </div>
+              <% } %>
+
+              <input type="hidden" name="pages[<%= index %>][id]" value="<%= page.id %>" />
+              <input type="hidden" name="pages[<%= index %>][locationAgnostic]" value="0" />
+
+              <div class="field-grid">
+                <label class="field-label">Page title
+                  <input class="field-control <%= fieldHasError(errors, 'title') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][title]" value="<%= page.title %>" />
+                  <% if (fieldHasError(errors, 'title')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'title') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Category
+                  <select class="field-control <%= fieldHasError(errors, 'categoryId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][categoryId]">
+                    <option value="">Select category</option>
+                    <% categories.forEach((category) => { %>
+                      <option value="<%= category.id %>" <%= page.categoryId === category.id ? 'selected' : '' %>><%= category.label %></option>
+                    <% }) %>
+                  </select>
+                  <% if (fieldHasError(errors, 'categoryId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'categoryId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="field-label">Location
+                  <select class="field-control <%= fieldHasError(errors, 'locationId') ? 'is-invalid' : '' %>" name="pages[<%= index %>][locationId]">
+                    <option value="">Select location</option>
+                    <% locations.forEach((location) => { %>
+                      <option value="<%= location.id %>" <%= page.locationId === location.id ? 'selected' : '' %>><%= location.label %></option>
+                    <% }) %>
+                  </select>
+                  <p class="location-note">Leave blank if location agnostic.</p>
+                  <% if (fieldHasError(errors, 'locationId')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'locationId') %></p>
+                  <% } %>
+                </label>
+
+                <label class="toggle-label">
+                  <input type="checkbox" name="pages[<%= index %>][locationAgnostic]" value="1" <%= page.locationAgnostic ? 'checked' : '' %> />
+                  Location agnostic directory
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Subdomain
+                  <input class="field-control <%= fieldHasError(errors, 'subdomain') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdomain]" value="<%= page.subdomain %>" />
+                  <% if (fieldHasError(errors, 'subdomain')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdomain') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Subdirectory
+                  <input class="field-control <%= fieldHasError(errors, 'subdirectory') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][subdirectory]" value="<%= page.subdirectory %>" />
+                  <% if (fieldHasError(errors, 'subdirectory')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'subdirectory') %></p>
+                  <% } %>
+                </label>
+              </div>
+
+              <div class="field-grid">
+                <label class="field-label">Hero title
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroTitle]" value="<%= page.heroTitle %>" />
+                </label>
+                <label class="field-label">Hero subtitle
+                  <input class="field-control" type="text" name="pages[<%= index %>][heroSubtitle]" value="<%= page.heroSubtitle %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Intro markdown
+                <textarea class="field-control" name="pages[<%= index %>][introMarkdown]" rows="3"><%= page.introMarkdown %></textarea>
+              </label>
+
+              <div class="field-grid">
+                <label class="field-label">Meta title
+                  <input class="field-control <%= fieldHasError(errors, 'metaTitle') ? 'is-invalid' : '' %>" type="text" name="pages[<%= index %>][metaTitle]" value="<%= page.metaTitle %>" />
+                  <% if (fieldHasError(errors, 'metaTitle')) { %>
+                    <p class="field-error"><%= fieldMessage(errors, 'metaTitle') %></p>
+                  <% } %>
+                </label>
+                <label class="field-label">Meta keywords
+                  <input class="field-control" type="text" name="pages[<%= index %>][metaKeywords]" value="<%= page.metaKeywords %>" />
+                </label>
+              </div>
+
+              <label class="field-label">Meta description
+                <textarea class="field-control <%= fieldHasError(errors, 'metaDescription') ? 'is-invalid' : '' %>" name="pages[<%= index %>][metaDescription]" rows="3"><%= page.metaDescription %></textarea>
+                <% if (fieldHasError(errors, 'metaDescription')) { %>
+                  <p class="field-error"><%= fieldMessage(errors, 'metaDescription') %></p>
+                <% } %>
+              </label>
+
+              <label class="field-label">OG image URL
+                <input class="field-control" type="url" name="pages[<%= index %>][ogImageUrl]" value="<%= page.ogImageUrl %>" />
+              </label>
+            </article>
+          <% }) %>
+        </div>
+
+        <div class="form-actions">
+          <button type="submit" class="btn primary">Save directory edits</button>
+          <p class="muted">Updates apply immediately in this demo.</p>
+        </div>
+      </form>
+    <% } %>
+  </section>
+</section>
+<%- include('../partials/page-end') %>
diff --git a/apps/admin/views/partials/page-start.ejs b/apps/admin/views/partials/page-start.ejs
index 392659e41db65f944025c1709e39236cd4d1a5d0..584ec018730026feb92d251d98ae00db37ef3063
--- a/apps/admin/views/partials/page-start.ejs
+++ b/apps/admin/views/partials/page-start.ejs
@@ -16,6 +16,7 @@
       <nav class="site-nav">
         <a href="/listings" class="nav-link <%= active === 'listings' ? 'is-active' : '' %>">Listings</a>
         <a href="/category-locations" class="nav-link <%= active === 'category-locations' ? 'is-active' : '' %>">Category Locations</a>
+        <a href="/directory-pages" class="nav-link <%= active === 'directory-pages' ? 'is-active' : '' %>">Directory Pages</a>
         <a href="/seo" class="nav-link <%= active === 'seo' ? 'is-active' : '' %>">SEO Fields</a>
       </nav>
     </div>

tokens used
158,583
**Directory Admin**
- Added a dedicated node:test suite to drive TDD for directory page creation/editing flows, covering required-field validation, uniqueness rules, location-agnostic handling, and save/deactivate toggles (apps/admin/test/directoryPageService.test.js:1).
- Seeded the in-memory store and option catalog used by the admin app, giving each directory record rich metadata for hero content, routing, and SEO overrides (apps/admin/data/directoryPages.js:1, apps/admin/data/directoryPageOptions.js:1).
- Implemented `directoryPageService` with getters, create/update logic, normalization, and reusable validators so UI actions always enforce category/location linkage, slug/subdomain uniqueness, and metadata requirements (apps/admin/services/directoryPageService.js:1).
- Built an Express router plus a comprehensive EJS management view that surfaces creation and bulk-edit forms, inline validation errors, and status toggles for publish/deactivate workflows (apps/admin/routes/directoryPages.js:1, apps/admin/views/directory-pages/index.ejs:1).
- Wired the new module into the shell (nav + server) and extended the admin stylesheet with directory-card layouts, grid helpers, toggle styles, and error states to keep the UX consistent (apps/admin/index.js:4, apps/admin/views/partials/page-start.ejs:17, apps/admin/public/css/admin.css:179).

Tests:
- `npm test`

Next: integrate this UI with the real API once those endpoints are available so the service can persist to Postgres instead of the in-memory store.
