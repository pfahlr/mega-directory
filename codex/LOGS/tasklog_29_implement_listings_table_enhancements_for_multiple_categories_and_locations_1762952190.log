OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a7823-9a30-7bd3-8a61-c45a0be5fd75
--------
user
Implement the functionality described in codex/TASKS/29_implement_listings_table_enhancements_for_multiple_categories_and_locations.yaml, then verify with any available tests.
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX

thinking
**Preparing to implement listings enhancements**
exec
bash -lc ls in /var/home/rick/Development/mega-directory succeeded in 45ms:
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
env.json
Makefile
package.json
packages
README.md
scripts
tests
tsconfig.json

thinking
**Examining task file**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/mega-directory succeeded in 42ms:
00_prepare_repository.yaml
01_initialize_astro_frontend.yaml
02_setup_api_server_with_express_and_jwt_auth.yaml
03_design_postgresql_schema.yaml
04_implement_listing_ingestion_api_endpoint.yaml
05_admin_auth_route_and_middleware.yaml
06_frontend_directory_page_rendering.yaml
07_frontend_subcategory_ui_and_layout.yaml
08_setup_featured_listings_logic.yaml
09_add_category_meta_and_seo_controls.yaml
10_scaffold_python_crawler_agent.yaml
11_llm_field_generation_via_jinja2.yaml
12_post_listings_from_crawler_to_api_server.yaml
13_create_json_crawler_configuration_schema.yaml
14_scaffold_admin_ui_application.yaml
15_admin_ui:_listing_review_table.yaml
16_admin_ui:_category_location_approval.yaml
17_admin_ui:_seo_field_editor.yaml
18_deploy_web_+_api_to_railway.yaml
19_setup_logging,_healthchecks_and_monitoring.yaml

thinking
**Opening task 29 file**
exec
bash -lc 'cat codex/TASKS/29_implement_listings_table_enhancements_for_multiple_categories_and_locations.yaml' in /var/home/rick/Development/mega-directory succeeded in 47ms:
id: 29
filename: 29_implement_listings_table_enhancements_for_multiple_categories_and_locations.yaml
title: Implement Listings Table Enhancements for Multiple Categories and Locations
description: >
Refactor listings schema to:
- Allow multiple categories per listing via join table
- Support multiple physical addresses per listing (one-to-many)
- Include optional default location via postal_code_id or city_id for location-agnostic behavior
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
dependencies: []

thinking
**Exploring project structure and database setup**
exec
bash -lc 'ls db' in /var/home/rick/Development/mega-directory succeeded in 54ms:
geography
migrations
schema.prisma
scripts
seed.ts

thinking
**Opening Prisma schema**
exec
bash -lc "sed -n '1,200p' db/schema.prisma" in /var/home/rick/Development/mega-directory succeeded in 50ms:
generator client {
  provider = "prisma-client-js"
}



datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ListingStatus {
  PENDING
  APPROVED
  REJECTED
  INACTIVE
}

enum DirectoryStatus {
  DRAFT
exec
bash -lc "sed -n '200,400p' db/schema.prisma" in /var/home/rick/Development/mega-directory succeeded in 49ms:
  stateRecord      StateProvince? @relation("StateLocations", fields: [stateId], references: [id])
  cityRecord       City?          @relation("CityLocations", fields: [cityId], references: [id])
  postalCodeRecord PostalCode?    @relation("PostalCodeLocations", fields: [postalCodeId], references: [id])

  listings    Listing[]
  directories Directory[]

  @@index([countryId])
  @@index([stateId])
  @@index([cityId])
  @@index([postalCodeId])
}

model Directory {
  id              Int             @id @default(autoincrement())
  title           String
  slug            String          @unique
  subdomain       String          @unique
  subdirectory    String          @unique
  hostname        String?

thinking
**Planning multi-category and location enhancements**

I’m figuring out how to support multiple categories and physical addresses per listing by creating join tables and optional default locations. I want to check the current test setup and project structure so I can write proper tests first, following the TDD approach mentioned in the instructions. Let’s see how the existing code and tests are organized, especially around the listing model and API.
exec
bash -lc 'ls apps' in /var/home/rick/Development/mega-directory succeeded in 42ms:
admin
api
crawler
web

thinking
**Exploring project structure and database setup**
exec
bash -lc 'cat package.json' in /var/home/rick/Development/mega-directory succeeded in 47ms:
{
  "name": "mega-directory",
  "private": true,
  "version": "0.1.0",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "test": "npm run test:root && npm run test:workspaces",
    "test:root": "node --test tests/**/*.test.js",
    "test:workspaces": "npm run test --workspaces --if-present"
  }
}

thinking
**Listing packages directory**
exec
bash -lc 'ls packages' in /var/home/rick/Development/mega-directory succeeded in 43ms:
shared-config

thinking
**Exploring API directory**
exec
bash -lc 'ls apps/api' in /var/home/rick/Development/mega-directory succeeded in 122ms:
dist
Dockerfile
node_modules
package.json
package-lock.json
src
test
tsconfig.json
types

thinking
**Inspecting apps/api/src directory**
exec
bash -lc 'ls apps/api/src' in /var/home/rick/Development/mega-directory succeeded in 46ms:
logger.ts
server.ts

thinking
**Checking distribution and server files**
exec
bash -lc "sed -n '1,200p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 46ms:
import express, { type Express, type Request, type RequestHandler } from 'express';
import jwt, { type JwtPayload } from 'jsonwebtoken';
import { DEFAULT_PORTS, PROJECT_NAME } from '@mega-directory/config';
import { createLogger, createRequestLogger, type Logger } from './logger';

const DEFAULT_PORT = DEFAULT_PORTS.api;
const DEFAULT_LISTING_STATUS: ListingStatus = 'INACTIVE';
const MAX_SLUG_LENGTH = 80;
const DEFAULT_ADMIN_TOKEN_TTL_SECONDS = 60 * 15;

type ListingStatus = 'INACTIVE' | 'ACTIVE';

type NullableString = string | null;

type ListingLocation =
  | {
      addressLine1?: string;
      addressLine2?: string;
      city?: string;
      region?: string;

thinking
**Continuing to review file contents**
exec
bash -lc "sed -n '200,400p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 51ms:
  return app;
}

export function startServer() {
  const app = createServer();
  const { port } = getAppLocals(app).config;
  app.listen(port, () => {
    getAppLocals(app).logger.info(
      { event: 'api.start', port, environment: process.env.NODE_ENV || 'development' },
      `API server running at http://localhost:${port}`
    );
  });
}

if (require.main === module) {
  startServer();
}

function extractBearerToken(req: Request) {
  const headerSource =
exec
bash -lc "sed -n '400,800p' apps/api/src/server.ts" in /var/home/rick/Development/mega-directory succeeded in 44ms:
  }
  return null;
}

function validateListingPayload(payload: unknown): ListingValidationResult {
  const errors: string[] = [];
  if (!isPlainObject(payload)) {
    return { valid: false, errors: ['Each listing must be an object'] };
  }

  const title = sanitizeNullableString(payload.title);
  if (!title) {
    errors.push('title is required');
  }

  const categorySlug = sanitizeNullableString(payload.categorySlug);
  if (!categorySlug) {
    errors.push('categorySlug is required');
  }


thinking
**Analyzing database schema and listing data**
exec
bash -lc 'rg -n "addressLine1" -n' in /var/home/rick/Development/mega-directory succeeded in 54ms:
apps/api/src/server.ts:17:      addressLine1?: string;
apps/api/src/server.ts:550:  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'] as const;
db/migrations/001_core_schema.sql:108:  "addressLine1" TEXT,
db/seed.ts:451:      addressLine1: '45 Water Street',
db/schema.prisma:275:  addressLine1     String?
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:1205:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:1462:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:1859:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:2283:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:2687:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:3109:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:3531:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:3953:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:4374:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_04_implement_listing_ingestion_api_endpoint_1762853214.log:4788:+  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_09_add_category_meta_and_seo_controls_1762856433.log:123:  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_08_setup_featured_listings_logic_1762855542.log:222:  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_15_admin_ui:_listing_review_table_1762859672.log:356:  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_19_setup_logging,_healthchecks_and_monitoring_1762861633.log:144:  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];
codex/LOGS/tasklog_12_post_listings_from_crawler_to_api_server_1762857915.log:342:  const fields = ['addressLine1', 'addressLine2', 'city', 'region', 'postalCode', 'country'];

thinking
**Planning schema refactor for categories**

I’m mapping out a multi-step plan to refactor the listings schema so that each listing can link to multiple categories with a join table, replacing the current single `categoryId` field. I’ll also check how other models like Directory reference categories and update any code relying on the old structure. I want to gather more context from relevant files before proceeding.
exec
bash -lc "sed -n '1,200p' codex/TASKS/codex_phase_1b_2.yaml" in /var/home/rick/Development/mega-directory succeeded in 49ms:
project: mega-directory
version: 1.0
phases:
  - phase: 1
    description: Core system buildout — listings pipeline, directory structure, admin tools, crawler, API, and frontend delivery

    components:
      api_server:
        language: TypeScript
        framework: Node/Express
        deployment: Railway
        endpoints:
          - listings: [GET, POST, PUT, DELETE]
          - addresses: [GET, POST, PUT, DELETE]
          - categories: [GET, POST, PUT, DELETE]
          - directory_pages: [GET, POST, PUT, DELETE]
          - directory_metadata: [GET, PUT]
        notes:
          - Postal, city, state/province, and country tables are loaded from external datasets.
          - Listings reference postal_code_id or city_id depending on geography.

thinking
**Preparing schema updates**
exec
bash -lc 'rg -n "physical" -n db/seed.ts' in /var/home/rick/Development/mega-directory exited 1 in 74ms:


thinking
**Investigating schema-related test coverage**
exec
bash -lc 'ls tests' in /var/home/rick/Development/mega-directory succeeded in 48ms:
dev_bootstrap_test.sh
directory_pages_schema.test.js

thinking
**Inspecting test style**
exec
bash -lc "sed -n '1,200p' tests/directory_pages_schema.test.js" in /var/home/rick/Development/mega-directory succeeded in 44ms:
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const test = require('node:test');

function loadCoreSchema() {
  const schemaPath = path.resolve(__dirname, '..', 'db', 'migrations', '001_core_schema.sql');
  return fs.readFileSync(schemaPath, 'utf8');
}

function extractTableBlock(sql, tableName) {
  const tableRegex = new RegExp(
    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
    'i'
  );
  const match = sql.match(tableRegex);
  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
  return match[1];
}


thinking
**Considering migration test strategy**
exec
bash -lc 'ls db/migrations' in /var/home/rick/Development/mega-directory succeeded in 41ms:
001_core_schema.sql
002_location_hierarchy.sql

thinking
**Planning new migration file**
exec
bash -lc "sed -n '1,160p' db/migrations/002_location_hierarchy.sql" in /var/home/rick/Development/mega-directory succeeded in 41ms:
-- Geographic hierarchy tables and related foreign keys
-- Includes countries, states/provinces, cities, and postal codes plus
-- bridge columns on locations/listings for direct references

CREATE TABLE "Country" (
  "id" INTEGER PRIMARY KEY,
  "name" TEXT NOT NULL,
  "iso2" TEXT NOT NULL UNIQUE,
  "iso3" TEXT,
  "numericCode" TEXT,
  "phoneCode" TEXT,
  "capital" TEXT,
  "currency" TEXT,
  "currencyName" TEXT,
  "currencySymbol" TEXT,
  "tld" TEXT,
  "nativeName" TEXT,
  "region" TEXT,
  "subregion" TEXT,
  "translations" JSONB,

thinking
**Preparing schema migration and tests updates**
exec
bash -lc 'rg -n "categoryId"' in /var/home/rick/Development/mega-directory succeeded in 53ms:
apps/admin/test/directoryPageService.test.js:23:    categoryId: '',
apps/admin/test/directoryPageService.test.js:35:    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
apps/admin/test/directoryPageService.test.js:44:    categoryId: existing.categoryId,
apps/admin/test/directoryPageService.test.js:66:    categoryId: category.id,
apps/admin/services/directoryPageService.js:13:    categoryLabel: resolveCategory(page.categoryId)?.label ?? 'Unknown category',
apps/admin/services/directoryPageService.js:107:        categoryId: '',
apps/admin/services/directoryPageService.js:137:  if (payload.categoryId !== undefined || mode === 'create') {
apps/admin/services/directoryPageService.js:138:    const value = typeof payload.categoryId === 'string' ? payload.categoryId.trim() : '';
apps/admin/services/directoryPageService.js:139:    next.categoryId = value || '';
apps/admin/services/directoryPageService.js:178:  if (!record.categoryId || !resolveCategory(record.categoryId)) {
apps/admin/services/directoryPageService.js:179:    errors.categoryId = 'Select a valid category';
apps/admin/data/directoryPages.js:6:    categoryId: 'cat_electricians',
apps/admin/data/directoryPages.js:27:    categoryId: 'cat_plumbers',
db/schema.prisma:233:  categoryId      Int
db/schema.prisma:236:  category   Category @relation(fields: [categoryId], references: [id])
db/schema.prisma:241:  @@unique([categoryId, locationId])
db/schema.prisma:254:  categoryId    Int
db/schema.prisma:257:  category   Category    @relation(fields: [categoryId], references: [id])
db/schema.prisma:262:  @@unique([categoryId, slug])
db/schema.prisma:303:  categoryId       Int

thinking
**Analyzing listing schema refactor requirements**
exec
bash -lc "sed -n '1,220p' db/migrations/001_core_schema.sql" in /var/home/rick/Development/mega-directory succeeded in 44ms:
-- Core relational schema for Mega Directory
-- Includes directories, listings, categorization, featured slots, users, and LLM configs

CREATE TYPE "ListingStatus" AS ENUM ('PENDING', 'APPROVED', 'REJECTED', 'INACTIVE');
CREATE TYPE "DirectoryStatus" AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'EDITOR', 'MODERATOR', 'CRAWLER');
CREATE TYPE "UserStatus" AS ENUM ('INVITED', 'ACTIVE', 'SUSPENDED');
CREATE TYPE "FeaturedSlotTier" AS ENUM ('HERO', 'PREMIUM', 'STANDARD');
CREATE TYPE "LlmTargetType" AS ENUM ('LISTING', 'CATEGORY', 'DIRECTORY', 'SUBCATEGORY');

CREATE TABLE "User" (
  "id" SERIAL PRIMARY KEY,
  "email" TEXT NOT NULL UNIQUE,
  "passwordHash" TEXT NOT NULL,
  "displayName" TEXT,
  "role" "UserRole" NOT NULL DEFAULT 'ADMIN',
  "status" "UserStatus" NOT NULL DEFAULT 'INVITED',
  "apiTokenHash" TEXT,
  "lastLoginAt" TIMESTAMPTZ,
  "lastPasswordAt" TIMESTAMPTZ,

thinking
**Planning database schema and migration changes**
exec
bash -lc "sed -n '1,200p' db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 47ms:
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function ensureDemoGeography() {
  const unitedStates = await prisma.country.upsert({
    where: { id: 233 },
    update: {
      name: 'United States',
      iso2: 'US',
      iso3: 'USA',
      numericCode: '840',
      phoneCode: '+1',
      capital: 'Washington D.C.',
      currency: 'USD',
      currencyName: 'United States dollar',
      currencySymbol: '$',
      region: 'Americas',
      subregion: 'Northern America',
      timezones: [

thinking
**Searching for listing seeding section**
exec
bash -lc "rg -n \"prisma\\.listing\" -n db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 51ms:
438:  const listing = await prisma.listing.upsert({
478:  await prisma.listingSubcategory.upsert({
492:  await prisma.listingSubcategory.upsert({
506:  const harborListing = await prisma.listing.upsert({
542:  await prisma.listingSubcategory.upsert({
556:  const steadfastListing = await prisma.listing.upsert({
592:  await prisma.listingSubcategory.upsert({

thinking
**Inspecting code section for schema update**
exec
bash -lc "sed -n '400,650p' db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 42ms:
    where: {
      categoryId_slug: { categoryId: servicesCategory.id, slug: 'electricians' }
    },
    update: {},
    create: {
      name: 'Electricians',
      slug: 'electricians',
      description: 'Licensed electricians for residential and commercial projects.',
      categoryId: servicesCategory.id
    }
  });

  const hvacSubcategory = await prisma.subcategory.upsert({
    where: {
      categoryId_slug: { categoryId: servicesCategory.id, slug: 'hvac' }
    },
    update: {},
    create: {
      name: 'HVAC',
      slug: 'hvac',


thinking
**Planning listings schema refactor**

There's a lot to consider updating the listings schema for multi-category and multi-address support. I’m sorting through how to add new join and address tables, whether to remove or keep existing address and category fields for compatibility, and how to update migrations, seeds, Prisma models, and tests accordingly. I want to structure the work so new migrations add the join and address tables, keep or drop old columns thoughtfully, and ensure tests verify the new schema changes before implementation. Balancing spec requirements with existing code dependencies is key here.
thinking
**Analyzing categoryId usage and migration strategy**

I’m verifying all references to `categoryId` in the codebase to ensure it’s safe to remove from `Listing`. I see seeds reference it but app code doesn’t, so removing it is feasible. Next, I plan to create a new migration that adds join and address tables, drops old address and category columns, and updates indexes accordingly. I also need to update the Prisma schema and rewrite seeds to fit the new structure. To keep tests reliable, I’ll add new tests targeting the new migration file to verify these schema changes. Finally, I want to draft a clear multi-step plan to implement and test all these updates thoroughly.
Plan update
  → Add schema tests capturing listings categories + address requirements before implementing changes
  • Implement schema + migration updates (Prisma models, SQL migrations, seed data) for multi-category + multi-address support
  • Run project test suite and verify everything passes

thinking
**Preparing test-driven development for listings schema enhancements**

I'm outlining a detailed plan to write failing tests first for new database migrations and Prisma schema changes related to listings, including join tables and addresses. These tests will check the presence and structure of new SQL tables and Prisma models, ensuring proper foreign keys, constraints, and model relations before implementing the actual migration and schema updates. I'll create helper functions to parse SQL and Prisma schema blocks, then add a new test file `tests/listings_schema_enhancements.test.js` with tests that initially fail until the code changes are done.
file update
A /var/home/rick/Development/mega-directory/tests/listings_table_enhancements.test.js
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const test = require('node:test');

const MIGRATION_FILE = path.resolve(
  __dirname,
  '..',
  'db',
  'migrations',
  '003_listings_table_enhancements.sql'
);
const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');

function loadMigration() {
  return fs.readFileSync(MIGRATION_FILE, 'utf8');
}

function loadPrismaSchema() {
  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
}

function extractTableBlock(sql, tableName) {
  const tableRegex = new RegExp(
    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
    'i'
  );
  const match = sql.match(tableRegex);
  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
  return match[1];
}

function expectColumn(block, columnName, typePattern) {
  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
  assert.match(
    block,
    columnRegex,
    `Expected column "${columnName}" definition to match /${typePattern}/i`
  );
}

function extractPrismaModel(schema, modelName) {
  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
  const match = schema.match(regex);
  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
  return match[1];
}

test('migration adds listings_categories bridge table with FKs', () => {
  const sql = loadMigration();
  const block = extractTableBlock(sql, 'ListingCategory');

  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');

  assert.match(
    block,
    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
    'Expected composite primary key on listingId/categoryId'
  );

  assert.match(
    sql,
    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
    'Expected FK from listing_categories.listingId to Listing.id'
  );

  assert.match(
    sql,
    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
    'Expected FK from listing_categories.categoryId to Category.id'
  );
});

test('migration adds listing_addresses table with geo references', () => {
  const sql = loadMigration();
  const block = extractTableBlock(sql, 'ListingAddress');

  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
  expectColumn(block, 'label', 'TEXT');
  expectColumn(block, 'addressLine1', 'TEXT');
  expectColumn(block, 'addressLine2', 'TEXT');
  expectColumn(block, 'city', 'TEXT');
  expectColumn(block, 'region', 'TEXT');
  expectColumn(block, 'postalCode', 'TEXT');
  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
  expectColumn(block, 'countryId', 'INTEGER');
  expectColumn(block, 'stateId', 'INTEGER');
  expectColumn(block, 'cityId', 'INTEGER');
  expectColumn(block, 'postalCodeId', 'INTEGER');
  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');

  assert.match(
    sql,
    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
    'Expected FK from listing_addresses.listingId to Listing.id'
  );
  assert.match(
    sql,
    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
    'Expected FK from listing_addresses.cityId to City.id'
  );
  assert.match(
    sql,
    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
  );
});

test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
  const schema = loadPrismaSchema();
  const listingBlock = extractPrismaModel(schema, 'Listing');
  assert.match(
    listingBlock,
    /addresses\s+ListingAddress\[\]/,
    'Listing model should expose addresses relation'
  );
  assert.match(
    listingBlock,
    /categories\s+ListingCategory\[\]/,
    'Listing model should expose categories relation'
  );

  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');

  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
});
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
A tests/listings_table_enhancements.test.js
file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Evaluating test running timing**
Plan update
  ✓ Add schema tests capturing listings categories + address requirements before implementing changes
  → Implement schema + migration updates (Prisma models, SQL migrations, seed data) for multi-category + multi-address support
  • Run project test suite and verify everything passes
file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});



thinking
**Implementing listings schema migration**

I’m putting together a new migration that revamps listings by adding join tables for categories and a separate listing addresses table, dropping old direct category and address columns from Listing. I’m carefully planning Prisma schema updates, SQL commands for constraints and indexes, and seed adjustments to keep everything consistent. This way, multi-category and multi-address support will be cleanly integrated without breaking existing setups.
thinking
**Planning Prisma schema updates**

I’m outlining comprehensive updates to the Prisma schema including revising Category and Listing models to replace direct relations with join tables, adding new ListingAddress and ListingCategory models, and extending location-related models with new address relations. Because these changes are broad and detailed, I’ll craft a precise patch to adjust each affected model carefully.
file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Checking schema file context for patch**
exec
bash -lc "sed -n '1,120p' db/schema.prisma" in /var/home/rick/Development/mega-directory succeeded in 45ms:
generator client {
  provider = "prisma-client-js"
}



datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ListingStatus {
  PENDING
  APPROVED
  REJECTED
  INACTIVE
}

enum DirectoryStatus {
  DRAFT
file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Extending patch with more context**
exec
bash -lc "sed -n '120,240p' db/schema.prisma" in /var/home/rick/Development/mega-directory succeeded in 43ms:
  countryCode String
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  country    Country          @relation(fields: [countryId], references: [id])
  state      StateProvince?   @relation(fields: [stateId], references: [id])
  postalCodes PostalCode[]
  listings   Listing[]        @relation("ListingCity")
  locations  Location[]       @relation("CityLocations")

  @@index([countryId])
  @@index([stateId])
}

model PostalCode {
  id          Int             @id @default(autoincrement())
  code        String
  placeName   String
  countryId   Int
  countryCode String
file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Continuing to list definitions**
exec
bash -lc "sed -n '240,440p' db/schema.prisma" in /var/home/rick/Development/mega-directory succeeded in 55ms:

  @@unique([categoryId, locationId])
  @@map("directory_pages")
}

model Subcategory {
  id            Int           @id @default(autoincrement())
  name          String
  slug          String
  description   String?
  displayOrder  Int           @default(0)
  isActive      Boolean       @default(true)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  categoryId    Int
  parentId      Int?

  category   Category    @relation(fields: [categoryId], references: [id])
  parent     Subcategory? @relation("SubcategoryChildren", fields: [parentId], references: [id])
  children   Subcategory[] @relation("SubcategoryChildren")
file update:
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Applying sequential patches**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -81,2 +81,3 @@
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..be91733e7e7cbc49c991f8004e42bd83aee58937
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..be91733e7e7cbc49c991f8004e42bd83aee58937
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Updating StateProvince handling**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -101,2 +101,3 @@
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..da91fd0647028a7b2cfb1d637d5510a97af4a1d3
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..da91fd0647028a7b2cfb1d637d5510a97af4a1d3
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Adding support for City**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -129,2 +129,3 @@
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..0ea91b57166a96fd969922dc3c50756b94607a54
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..0ea91b57166a96fd969922dc3c50756b94607a54
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Adding support for PostalCode**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -158,2 +158,3 @@
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..eead55722469465eabeed82717932d5aed5f6028
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..eead55722469465eabeed82717932d5aed5f6028
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Updating Category relations**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -178,3 +178,3 @@
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..942a874c8dccb1cd54506a9604380120a015396a
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..942a874c8dccb1cd54506a9604380120a015396a
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Preparing model update patch**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -278,10 +278,2 @@
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
@@ -306,3 +298,2 @@
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
@@ -315,3 +306,2 @@
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
@@ -321,2 +311,4 @@
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
@@ -328,3 +320,2 @@
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..6e2bfc7645d55544e0115259d0bf3e249e3ac029
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,7 +318,6 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..6e2bfc7645d55544e0115259d0bf3e249e3ac029
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,7 +318,6 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Planning model additions**
file update
M /var/home/rick/Development/mega-directory/db/schema.prisma
@@ -326,2 +326,45 @@
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
M db/schema.prisma
file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Verifying Prisma schema relations and indexes**
file update
A /var/home/rick/Development/mega-directory/db/migrations/003_listings_table_enhancements.sql
-- Listings table enhancements for multi-category + multi-address support

-- Drop legacy single-category + address columns
ALTER TABLE "Listing"
  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";

ALTER TABLE "Listing"
  DROP COLUMN IF EXISTS "categoryId",
  DROP COLUMN IF EXISTS "addressLine1",
  DROP COLUMN IF EXISTS "addressLine2",
  DROP COLUMN IF EXISTS "city",
  DROP COLUMN IF EXISTS "region",
  DROP COLUMN IF EXISTS "postalCode",
  DROP COLUMN IF EXISTS "country",
  DROP COLUMN IF EXISTS "latitude",
  DROP COLUMN IF EXISTS "longitude";

DROP INDEX IF EXISTS "Listing_category_location_idx";

-- Listing/category bridge table
CREATE TABLE "ListingCategory" (
  "listingId" INTEGER NOT NULL,
  "categoryId" INTEGER NOT NULL,
  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");

CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
  ON "ListingCategory" ("listingId")
  WHERE "isPrimary" IS TRUE;

-- Listing addresses table
CREATE TABLE "ListingAddress" (
  "id" SERIAL PRIMARY KEY,
  "listingId" INTEGER NOT NULL,
  "label" TEXT,
  "addressLine1" TEXT,
  "addressLine2" TEXT,
  "city" TEXT,
  "region" TEXT,
  "postalCode" TEXT,
  "country" TEXT DEFAULT 'US',
  "latitude" DOUBLE PRECISION,
  "longitude" DOUBLE PRECISION,
  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
  "countryId" INTEGER,
  "stateId" INTEGER,
  "cityId" INTEGER,
  "postalCodeId" INTEGER,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
);

CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");

CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
  ON "ListingAddress" ("listingId")
  WHERE "isPrimary" IS TRUE;
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
A db/migrations/003_listings_table_enhancements.sql
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Verifying database schema and seed updates**

I’m double-checking that the tests expect the `ListingAddress` table’s `id` column as a SERIAL PRIMARY KEY and that the foreign key constraints reference the right columns with correct delete behaviors. I also want to align the seed script by removing address fields directly on listings and instead create associated listingCategory and listingAddress entries, ensuring multiple categories per listing are supported. To confirm category data setup, I’ll review the earlier part of the seed file around lines 300-420.
exec
bash -lc "sed -n '300,420p' db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 48ms:
      country: 'US',
      timezone: 'America/Los_Angeles',
      latitude: 37.7749,
      longitude: -122.4194,
      countryId: geography.country.id,
      stateId: geography.states.ca.id,
      cityId: geography.cities.sf.id,
      postalCodeId: geography.postalCodes.sf.id
    },
    create: {
      name: 'San Francisco',
      slug: 'san-francisco',
      state: 'CA',
      country: 'US',
      timezone: 'America/Los_Angeles',
      latitude: 37.7749,
      longitude: -122.4194,
      countryId: geography.country.id,
      stateId: geography.states.ca.id,
      cityId: geography.cities.sf.id,
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Verifying category definitions**
exec
bash -lc 'rg -n "jobsCategory" -n db/seed.ts' in /var/home/rick/Development/mega-directory succeeded in 43ms:
256:  const jobsCategory = await prisma.category.upsert({
389:    categoryId: jobsCategory.id,
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Checking file creation details**
exec
bash -lc "sed -n '220,320p' db/seed.ts" in /var/home/rick/Development/mega-directory succeeded in 43ms:
      nyc: nycCity,
      sf: sfCity
    },
    postalCodes: {
      nyc: nycPostal,
      sf: sfPostal
    }
  };
}

async function main() {
  const geography = await ensureDemoGeography();
  const adminUser = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {},
    create: {
      email: 'admin@example.com',
      passwordHash: 'placeholder-hash',
      displayName: 'Demo Admin',
      role: 'ADMIN',
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});



thinking
**Designing idempotent seeds with helper functions**

I'm figuring out how to update seed data so listings have multiple addresses and categories without creating duplicates. Since upsert requires unique keys we don’t have on listing addresses, I'll instead delete existing related categories and addresses before creating new ones, ensuring idempotency. To keep code clean, I plan to write helper functions that handle deleting and creating address and category records per listing within the seed script. I'll also carefully set defaults like labels and country codes to keep data consistent. This approach should fit the spec and avoid awkward unique constraints.
thinking
**Handling country defaults in address seeds**

I'm deciding how to handle the `country` field when seeding addresses so it defaults to `'US'` but still respects explicit null values. After weighing options, I’m leaning toward simply using `address.country ?? 'US'` in the seed code since all seed addresses are in the US. This keeps things straightforward and avoids unnecessary complexity while still matching previous behavior. Next, I’ll implement the helper functions for seeding categories and addresses.
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -229,2 +229,64 @@
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..1185cc66292a596150f473df21b81d1ffe765e87
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..1185cc66292a596150f473df21b81d1ffe765e87
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Modifying listing creation data structure**
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -512,7 +512,2 @@
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
@@ -529,3 +524,2 @@
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..c5fb911bb44f05a655e0c5e7d520487545477818
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..c5fb911bb44f05a655e0c5e7d520487545477818
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Removing fields from harborListing and steadfast**
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -573,6 +573,2 @@
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
@@ -587,3 +583,2 @@
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..79c98c8ad404dc5f420e37c3b29aa0e869255cbb
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -515,10 +571,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +581,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..79c98c8ad404dc5f420e37c3b29aa0e869255cbb
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -515,10 +571,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +581,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Applying patch to steadfast**
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -618,6 +618,2 @@
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
@@ -632,3 +628,2 @@
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..9f45c70103f53a48321d08b9156b71bf89d450e2
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -515,10 +571,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +581,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -565,10 +616,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +626,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..9f45c70103f53a48321d08b9156b71bf89d450e2
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -515,10 +571,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +581,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -565,10 +616,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +626,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Adding category and address setup**
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -533,2 +533,34 @@
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..2e0b6fe77367357e15070379a8cc930cbb60dcbe
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -565,10 +648,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +658,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..2e0b6fe77367357e15070379a8cc930cbb60dcbe
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -565,10 +648,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +658,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Extending functionality for harborListing and steadfast**
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -624,2 +624,21 @@
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..67eb2c63f0481e70f6403135133e485e9eac2e47
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..67eb2c63f0481e70f6403135133e485e9eac2e47
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Starting on steadfastListing**
file update
M /var/home/rick/Development/mega-directory/db/seed.ts
@@ -688,2 +688,21 @@
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M db/seed.ts
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Verifying schema and seed consistency**

I’m carefully confirming all changes to listing-related schema, seeds, and relations are consistent and meet test expectations. This includes checking defaults, relations, indexes, naming, cascading deletes, and ensuring TypeScript compatibility. I’m also making sure existing constraints match test queries and that the seed scripts utilize the new functions correctly before proceeding to tests.
exec
bash -lc 'cat apps/api/package.json' in /var/home/rick/Development/mega-directory succeeded in 40ms:
{
  "name": "mega-directory-api",
  "private": true,
  "version": "0.1.0",
  "type": "commonjs",
  "main": "dist/server.js",
  "types": "dist/server.d.ts",
  "scripts": {
    "dev": "npm run build && node dist/server.js",
    "dev:watch": "tsc -p tsconfig.json --watch",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "test": "npm run build && node --test test/**/*.test.js"
  },
  "dependencies": {
    "@mega-directory/config": "file:../../packages/shared-config",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Investigating TypeScript compilation setup**
exec
bash -lc 'cat tsconfig.json' in /var/home/rick/Development/mega-directory succeeded in 40ms:
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true
  }
}
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Validating schema and test setup**

I'm double-checking the Prisma schema changes and corresponding database migrations to ensure defaults, relations, and foreign keys are correct and consistent. I'm also verifying the seeding scripts and test expectations for model extraction patterns. Since dependencies are installed, my next step is running the tests with the proper npm command.
exec
bash -lc 'npm test' in /var/home/rick/Development/mega-directory succeeded in 4.47s:

> mega-directory@0.1.0 test
> npm run test:root && npm run test:workspaces


> mega-directory@0.1.0 test:root
> node --test tests/**/*.test.js

TAP version 13
# Subtest: tests/directory_pages_schema.test.js
ok 1 - tests/directory_pages_schema.test.js
  ---
  duration_ms: 205.260202
  type: 'test'
  ...
# Subtest: tests/listings_table_enhancements.test.js
ok 2 - tests/listings_table_enhancements.test.js
  ---
  duration_ms: 206.224393
  type: 'test'
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Updating plan statuses**
Plan update
  ✓ Add schema tests capturing listings categories + address requirements before implementing changes
  ✓ Implement schema + migration updates (Prisma models, SQL migrations, seed data) for multi-category + multi-address support
  ✓ Run project test suite and verify everything passes
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Preparing line number references**
exec
bash -lc "nl -ba tests/listings_table_enhancements.test.js | sed -n '1,200p'" in /var/home/rick/Development/mega-directory succeeded in 42ms:
     1	const assert = require('node:assert/strict');
     2	const fs = require('node:fs');
     3	const path = require('node:path');
     4	const test = require('node:test');
     5	
     6	const MIGRATION_FILE = path.resolve(
     7	  __dirname,
     8	  '..',
     9	  'db',
    10	  'migrations',
    11	  '003_listings_table_enhancements.sql'
    12	);
    13	const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
    14	
    15	function loadMigration() {
    16	  return fs.readFileSync(MIGRATION_FILE, 'utf8');
    17	}
    18	
    19	function loadPrismaSchema() {
    20	  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Identifying relevant code sections with line numbers**
exec
bash -lc "nl -ba db/schema.prisma | sed -n '120,260p'" in /var/home/rick/Development/mega-directory succeeded in 49ms:
   120	  stateName   String?
   121	  countryId   Int
   122	  countryCode String
   123	  createdAt   DateTime        @default(now())
   124	  updatedAt   DateTime        @updatedAt
   125	
   126	  country    Country          @relation(fields: [countryId], references: [id])
   127	  state      StateProvince?   @relation(fields: [stateId], references: [id])
   128	  postalCodes PostalCode[]
   129	  listings   Listing[]        @relation("ListingCity")
   130	  listingAddresses ListingAddress[] @relation("AddressCity")
   131	  locations  Location[]       @relation("CityLocations")
   132	
   133	  @@index([countryId])
   134	  @@index([stateId])
   135	}
   136	
   137	model PostalCode {
   138	  id          Int             @id @default(autoincrement())
   139	  code        String
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Preparing to fetch more lines**
exec
bash -lc "nl -ba db/schema.prisma | sed -n '260,520p'" in /var/home/rick/Development/mega-directory succeeded in 69ms:
   260	
   261	  category   Category    @relation(fields: [categoryId], references: [id])
   262	  parent     Subcategory? @relation("SubcategoryChildren", fields: [parentId], references: [id])
   263	  children   Subcategory[] @relation("SubcategoryChildren")
   264	  listings   ListingSubcategory[]
   265	
   266	  @@unique([categoryId, slug])
   267	}
   268	
   269	model Listing {
   270	  id               Int              @id @default(autoincrement())
   271	  title            String
   272	  slug             String           @unique
   273	  tagline          String?
   274	  summary          String?
   275	  description      String?
   276	  websiteUrl       String?
   277	  contactEmail     String?
   278	  contactPhone     String?
   279	  priceRange       String?
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Referencing relevant code lines**
exec
bash -lc 'nl -ba db/migrations/003_listings_table_enhancements.sql' in /var/home/rick/Development/mega-directory succeeded in 51ms:
     1	-- Listings table enhancements for multi-category + multi-address support
     2	
     3	-- Drop legacy single-category + address columns
     4	ALTER TABLE "Listing"
     5	  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
     6	
     7	ALTER TABLE "Listing"
     8	  DROP COLUMN IF EXISTS "categoryId",
     9	  DROP COLUMN IF EXISTS "addressLine1",
    10	  DROP COLUMN IF EXISTS "addressLine2",
    11	  DROP COLUMN IF EXISTS "city",
    12	  DROP COLUMN IF EXISTS "region",
    13	  DROP COLUMN IF EXISTS "postalCode",
    14	  DROP COLUMN IF EXISTS "country",
    15	  DROP COLUMN IF EXISTS "latitude",
    16	  DROP COLUMN IF EXISTS "longitude";
    17	
    18	DROP INDEX IF EXISTS "Listing_category_location_idx";
    19	
    20	-- Listing/category bridge table
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Gathering line numbers for seed helpers**
exec
bash -lc "nl -ba db/seed.ts | sed -n '1,220p'" in /var/home/rick/Development/mega-directory succeeded in 52ms:
     1	import { PrismaClient } from '@prisma/client';
     2	
     3	const prisma = new PrismaClient();
     4	
     5	async function ensureDemoGeography() {
     6	  const unitedStates = await prisma.country.upsert({
     7	    where: { id: 233 },
     8	    update: {
     9	      name: 'United States',
    10	      iso2: 'US',
    11	      iso3: 'USA',
    12	      numericCode: '840',
    13	      phoneCode: '+1',
    14	      capital: 'Washington D.C.',
    15	      currency: 'USD',
    16	      currencyName: 'United States dollar',
    17	      currencySymbol: '$',
    18	      region: 'Americas',
    19	      subregion: 'Northern America',
    20	      timezones: [
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Locating line numbers for helper functions**
exec
bash -lc "nl -ba db/seed.ts | sed -n '220,420p'" in /var/home/rick/Development/mega-directory succeeded in 54ms:
   220	      nyc: nycCity,
   221	      sf: sfCity
   222	    },
   223	    postalCodes: {
   224	      nyc: nycPostal,
   225	      sf: sfPostal
   226	    }
   227	  };
   228	}
   229	
   230	type CategoryLinkInput = {
   231	  categoryId: number;
   232	  isPrimary?: boolean;
   233	};
   234	
   235	type ListingAddressInput = {
   236	  label?: string | null;
   237	  addressLine1?: string | null;
   238	  addressLine2?: string | null;
   239	  city?: string | null;
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Extracting code section by line numbers**
exec
bash -lc "nl -ba db/seed.ts | sed -n '420,720p'" in /var/home/rick/Development/mega-directory succeeded in 55ms:
   420	    isActive: false,
   421	    metaTitle: 'Professional Services in SF',
   422	    metaDescription: 'Hand-reviewed professional services across the Bay Area.',
   423	    metaKeywords: 'electricians,hvac,maintenance,san francisco',
   424	    ogImageUrl: 'https://cdn.example.com/directories/pro-services-sf.png',
   425	    locationAgnostic: false,
   426	    categoryId: servicesCategory.id,
   427	    locationId: sf.id
   428	  };
   429	
   430	  await prisma.directory.upsert({
   431	    where: { slug: sfDirectoryData.slug },
   432	    update: sfDirectoryData,
   433	    create: sfDirectoryData
   434	  });
   435	
   436	  const nycJobsDirectoryData = {
   437	    title: 'NYC Jobs Directory',
   438	    slug: 'jobs-new-york-city',
   439	    subdomain: 'jobs.nyc',
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Requesting remainder of output**
exec
bash -lc "nl -ba db/seed.ts | sed -n '540,760p'" in /var/home/rick/Development/mega-directory succeeded in 43ms:
   540	    {
   541	      label: 'Manhattan HQ',
   542	      addressLine1: '45 Water Street',
   543	      city: 'New York',
   544	      region: 'NY',
   545	      postalCode: '10004',
   546	      country: 'US',
   547	      isPrimary: true,
   548	      countryId: geography.country.id,
   549	      stateId: geography.states.ny.id,
   550	      cityId: geography.cities.nyc.id,
   551	      postalCodeId: geography.postalCodes.nyc.id
   552	    },
   553	    {
   554	      label: 'Midtown Satellite',
   555	      addressLine1: '135 W 50th Street',
   556	      city: 'New York',
   557	      region: 'NY',
   558	      postalCode: '10020',
   559	      country: 'US',
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});


thinking
**Summarizing update details with references**

I'm putting together a clear summary highlighting key changes with file paths and line numbers, focusing on tests added, Prisma schema updates, migration creation, and seed script enhancements. I’ll also note that tests passed and suggest natural next steps like applying the migration and regenerating the Prisma client, using bullet points and numbered lists for clarity.
codex
**Update Summary**
- Added regression coverage that inspects the new migration and Prisma schema so the listings↔categories bridge and physical addresses table must exist with the required columns/FKs (`tests/listings_table_enhancements.test.js:1-138`).
- Reworked the Prisma models to drop single-address columns from `Listing`, add the `ListingCategory`/`ListingAddress` models, and expose the new relations across `Category`, `Listing`, and the geography tables for proper cascading behavior (`db/schema.prisma:167-368`).
- Authored migration `003_listings_table_enhancements.sql` to drop the legacy columns/index, create the join table, create the address table, and add supporting indexes plus partial uniqueness for primary assignments (`db/migrations/003_listings_table_enhancements.sql:1-70`).
- Extended the seed script with helper sync routines plus concrete data that now populates multiple categories and multiple addresses per listing so the new schema is exercised (`db/seed.ts:230-707`).

**Testing**
- `npm test`

**Next Steps**
1. Apply the new migration and regenerate the Prisma client in any dev/test databases (`npx prisma migrate deploy && npx prisma generate`).
2. Re-seed your database (`ts-node db/seed.ts` or existing workflow) so the new category/address data is loaded.
file update:
diff --git a/db/migrations/003_listings_table_enhancements.sql b/db/migrations/003_listings_table_enhancements.sql
new file mode 100644
index 0000000000000000000000000000000000000000..d1099363143472da559d09063a99cf69c01249ef
--- /dev/null
+++ b/db/migrations/003_listings_table_enhancements.sql
@@ -0,0 +1,70 @@
+-- Listings table enhancements for multi-category + multi-address support
+
+-- Drop legacy single-category + address columns
+ALTER TABLE "Listing"
+  DROP CONSTRAINT IF EXISTS "Listing_categoryId_fkey";
+
+ALTER TABLE "Listing"
+  DROP COLUMN IF EXISTS "categoryId",
+  DROP COLUMN IF EXISTS "addressLine1",
+  DROP COLUMN IF EXISTS "addressLine2",
+  DROP COLUMN IF EXISTS "city",
+  DROP COLUMN IF EXISTS "region",
+  DROP COLUMN IF EXISTS "postalCode",
+  DROP COLUMN IF EXISTS "country",
+  DROP COLUMN IF EXISTS "latitude",
+  DROP COLUMN IF EXISTS "longitude";
+
+DROP INDEX IF EXISTS "Listing_category_location_idx";
+
+-- Listing/category bridge table
+CREATE TABLE "ListingCategory" (
+  "listingId" INTEGER NOT NULL,
+  "categoryId" INTEGER NOT NULL,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "assignedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingCategory_pkey" PRIMARY KEY ("listingId", "categoryId"),
+  CONSTRAINT "ListingCategory_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingCategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingCategory_categoryId_idx" ON "ListingCategory" ("categoryId");
+
+CREATE UNIQUE INDEX "ListingCategory_primary_listing_key"
+  ON "ListingCategory" ("listingId")
+  WHERE "isPrimary" IS TRUE;
+
+-- Listing addresses table
+CREATE TABLE "ListingAddress" (
+  "id" SERIAL PRIMARY KEY,
+  "listingId" INTEGER NOT NULL,
+  "label" TEXT,
+  "addressLine1" TEXT,
+  "addressLine2" TEXT,
+  "city" TEXT,
+  "region" TEXT,
+  "postalCode" TEXT,
+  "country" TEXT DEFAULT 'US',
+  "latitude" DOUBLE PRECISION,
+  "longitude" DOUBLE PRECISION,
+  "isPrimary" BOOLEAN NOT NULL DEFAULT FALSE,
+  "countryId" INTEGER,
+  "stateId" INTEGER,
+  "cityId" INTEGER,
+  "postalCodeId" INTEGER,
+  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  CONSTRAINT "ListingAddress_listingId_fkey" FOREIGN KEY ("listingId") REFERENCES "Listing"("id") ON DELETE CASCADE ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_countryId_fkey" FOREIGN KEY ("countryId") REFERENCES "Country"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_stateId_fkey" FOREIGN KEY ("stateId") REFERENCES "StateProvince"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE SET NULL ON UPDATE CASCADE,
+  CONSTRAINT "ListingAddress_postalCodeId_fkey" FOREIGN KEY ("postalCodeId") REFERENCES "PostalCode"("id") ON DELETE SET NULL ON UPDATE CASCADE
+);
+
+CREATE INDEX "ListingAddress_listingId_idx" ON "ListingAddress" ("listingId");
+CREATE INDEX "ListingAddress_cityId_idx" ON "ListingAddress" ("cityId");
+CREATE INDEX "ListingAddress_postalCodeId_idx" ON "ListingAddress" ("postalCodeId");
+
+CREATE UNIQUE INDEX "ListingAddress_primary_listing_key"
+  ON "ListingAddress" ("listingId")
+  WHERE "isPrimary" IS TRUE;
diff --git a/db/schema.prisma b/db/schema.prisma
index bb8037bb6f352061309566ec926005ad34ffcf0a..de027a2e8990212426652c6e371af4c32c312a49
--- a/db/schema.prisma
+++ b/db/schema.prisma
@@ -79,6 +79,7 @@
   cities      City[]
   postalCodes PostalCode[]
   listings    Listing[]         @relation("ListingCountry")
+  listingAddresses ListingAddress[] @relation("AddressCountry")
   locations   Location[]        @relation("CountryLocations")
 }
 
@@ -98,6 +99,7 @@
   cities     City[]
   postalCodes PostalCode[]
   listings   Listing[]  @relation("ListingState")
+  listingAddresses ListingAddress[] @relation("AddressState")
   locations  Location[] @relation("StateLocations")
 
   @@index([countryId])
@@ -125,6 +127,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   postalCodes PostalCode[]
   listings   Listing[]        @relation("ListingCity")
+  listingAddresses ListingAddress[] @relation("AddressCity")
   locations  Location[]       @relation("CityLocations")
 
   @@index([countryId])
@@ -153,6 +156,7 @@
   state      StateProvince?   @relation(fields: [stateId], references: [id])
   city       City?            @relation(fields: [cityId], references: [id])
   listings   Listing[]        @relation("ListingPostalCode")
+  listingAddresses ListingAddress[] @relation("AddressPostalCode")
   locations  Location[]       @relation("PostalCodeLocations")
 
   @@index([countryId, code])
@@ -172,7 +176,7 @@
   createdAt       DateTime       @default(now())
   updatedAt       DateTime       @updatedAt
 
-  listings      Listing[]
+  listingCategories ListingCategory[]
   directories   Directory[]
   subcategories Subcategory[]
 }
@@ -272,14 +276,6 @@
   websiteUrl       String?
   contactEmail     String?
   contactPhone     String?
-  addressLine1     String?
-  addressLine2     String?
-  city             String?
-  region           String?
-  postalCode       String?
-  country          String?          @default("US")
-  latitude         Float?
-  longitude        Float?
   priceRange       String?
   rating           Float?           @default(0)
   reviewCount      Int?             @default(0)
@@ -300,7 +296,6 @@
   archivedAt       DateTime?
   createdAt        DateTime         @default(now())
   updatedAt        DateTime         @updatedAt
-  categoryId       Int
   locationId       Int?
   directoryId      Int?
   approvedById     Int?
@@ -309,12 +304,13 @@
   cityId           Int?
   postalCodeId     Int?
 
-  category      Category             @relation(fields: [categoryId], references: [id])
   location      Location?            @relation(fields: [locationId], references: [id])
   directory     Directory?           @relation(fields: [directoryId], references: [id])
   approvedBy    User?                @relation("ListingApprovedBy", fields: [approvedById], references: [id])
   subcategories ListingSubcategory[]
   featuredSlots FeaturedSlot[]
+  categories    ListingCategory[]
+  addresses     ListingAddress[]
   countryRecord   Country?           @relation("ListingCountry", fields: [countryId], references: [id])
   stateRecord     StateProvince?     @relation("ListingState", fields: [stateId], references: [id])
   cityRecord      City?              @relation("ListingCity", fields: [cityId], references: [id])
@@ -322,13 +318,55 @@
 
   @@index([directoryId])
   @@index([status])
-  @@index([categoryId, locationId])
   @@index([postalCodeId])
   @@index([cityId])
   @@index([stateId])
   @@index([countryId])
 }
 
+model ListingCategory {
+  listing     Listing  @relation(fields: [listingId], references: [id])
+  listingId   Int
+  category    Category @relation(fields: [categoryId], references: [id])
+  categoryId  Int
+  isPrimary   Boolean  @default(false)
+  assignedAt  DateTime @default(now())
+
+  @@id([listingId, categoryId])
+  @@index([categoryId])
+}
+
+model ListingAddress {
+  id            Int       @id @default(autoincrement())
+  listingId     Int
+  label         String?
+  addressLine1  String?
+  addressLine2  String?
+  city          String?
+  region        String?
+  postalCode    String?
+  country       String?   @default("US")
+  latitude      Float?
+  longitude     Float?
+  isPrimary     Boolean   @default(false)
+  countryId     Int?
+  stateId       Int?
+  cityId        Int?
+  postalCodeId  Int?
+  createdAt     DateTime  @default(now())
+  updatedAt     DateTime  @updatedAt
+
+  listing         Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
+  countryRecord   Country?       @relation("AddressCountry", fields: [countryId], references: [id])
+  stateRecord     StateProvince? @relation("AddressState", fields: [stateId], references: [id])
+  cityRecord      City?          @relation("AddressCity", fields: [cityId], references: [id])
+  postalCodeRecord PostalCode?   @relation("AddressPostalCode", fields: [postalCodeId], references: [id])
+
+  @@index([listingId])
+  @@index([cityId])
+  @@index([postalCodeId])
+}
+
 model ListingSubcategory {
   listing       Listing     @relation(fields: [listingId], references: [id])
   listingId     Int
diff --git a/db/seed.ts b/db/seed.ts
index 8fe31a4cae48bb48bacf4d69390aaba7449f6584..74ae55224b4a4fa691eae701324baf0e01aae718
--- a/db/seed.ts
+++ b/db/seed.ts
@@ -227,6 +227,68 @@
   };
 }
 
+type CategoryLinkInput = {
+  categoryId: number;
+  isPrimary?: boolean;
+};
+
+type ListingAddressInput = {
+  label?: string | null;
+  addressLine1?: string | null;
+  addressLine2?: string | null;
+  city?: string | null;
+  region?: string | null;
+  postalCode?: string | null;
+  country?: string | null;
+  latitude?: number | null;
+  longitude?: number | null;
+  isPrimary?: boolean;
+  countryId?: number | null;
+  stateId?: number | null;
+  cityId?: number | null;
+  postalCodeId?: number | null;
+};
+
+async function setListingCategories(listingId: number, categories: CategoryLinkInput[]) {
+  await prisma.listingCategory.deleteMany({ where: { listingId } });
+  if (categories.length === 0) {
+    return;
+  }
+  await prisma.listingCategory.createMany({
+    data: categories.map((entry, index) => ({
+      listingId,
+      categoryId: entry.categoryId,
+      isPrimary: entry.isPrimary ?? index === 0
+    }))
+  });
+}
+
+async function setListingAddresses(listingId: number, addresses: ListingAddressInput[]) {
+  await prisma.listingAddress.deleteMany({ where: { listingId } });
+  if (addresses.length === 0) {
+    return;
+  }
+  await prisma.listingAddress.createMany({
+    data: addresses.map((address, index) => ({
+      listingId,
+      label: address.label ?? (index === 0 ? 'Primary' : null),
+      addressLine1: address.addressLine1 ?? null,
+      addressLine2: address.addressLine2 ?? null,
+      city: address.city ?? null,
+      region: address.region ?? null,
+      postalCode: address.postalCode ?? null,
+      country: address.country ?? 'US',
+      latitude: address.latitude ?? null,
+      longitude: address.longitude ?? null,
+      isPrimary: address.isPrimary ?? index === 0,
+      countryId: address.countryId ?? null,
+      stateId: address.stateId ?? null,
+      cityId: address.cityId ?? null,
+      postalCodeId: address.postalCodeId ?? null
+    }))
+  });
+}
+
 async function main() {
   const geography = await ensureDemoGeography();
   const adminUser = await prisma.user.upsert({
@@ -448,11 +510,6 @@
       websiteUrl: 'https://brightsparks.example.com',
       contactEmail: 'hello@brightsparks.example.com',
       contactPhone: '+1-212-555-0199',
-      addressLine1: '45 Water Street',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       isClaimed: true,
       isSponsored: true,
@@ -465,7 +522,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -475,6 +531,38 @@
     }
   });
 
+  await setListingCategories(listing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true },
+    { categoryId: jobsCategory.id }
+  ]);
+
+  await setListingAddresses(listing.id, [
+    {
+      label: 'Manhattan HQ',
+      addressLine1: '45 Water Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10004',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id,
+      postalCodeId: geography.postalCodes.nyc.id
+    },
+    {
+      label: 'Midtown Satellite',
+      addressLine1: '135 W 50th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10020',
+      country: 'US',
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -515,10 +603,6 @@
       websiteUrl: 'https://harborhvac.example.com',
       contactEmail: 'contact@harborhvac.example.com',
       contactPhone: '+1-929-555-0100',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 90.1,
       rating: 4.7,
@@ -529,7 +613,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -539,6 +622,25 @@
     }
   });
 
+  await setListingCategories(harborListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(harborListing.id, [
+    {
+      label: 'Financial District Office',
+      addressLine1: '140 Broadway',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10005',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
@@ -565,10 +667,6 @@
       websiteUrl: 'https://steadfast.example.com',
       contactEmail: 'hello@steadfast.example.com',
       contactPhone: '+1-917-555-0105',
-      city: 'New York',
-      region: 'NY',
-      postalCode: '10004',
-      country: 'US',
       status: 'APPROVED',
       score: 82.4,
       rating: 4.5,
@@ -579,7 +677,6 @@
       approvedAt: new Date(),
       publishedAt: new Date(),
       approvedById: adminUser.id,
-      categoryId: servicesCategory.id,
       locationId: nyc.id,
       directoryId: nycDirectory.id,
       countryId: geography.country.id,
@@ -589,6 +686,25 @@
     }
   });
 
+  await setListingCategories(steadfastListing.id, [
+    { categoryId: servicesCategory.id, isPrimary: true }
+  ]);
+
+  await setListingAddresses(steadfastListing.id, [
+    {
+      label: 'Uptown Service Center',
+      addressLine1: '200 W 67th Street',
+      city: 'New York',
+      region: 'NY',
+      postalCode: '10023',
+      country: 'US',
+      isPrimary: true,
+      countryId: geography.country.id,
+      stateId: geography.states.ny.id,
+      cityId: geography.cities.nyc.id
+    }
+  ]);
+
   await prisma.listingSubcategory.upsert({
     where: {
       listingId_subcategoryId: {
diff --git a/tests/listings_table_enhancements.test.js b/tests/listings_table_enhancements.test.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf2a803a102cecd9e250f1e82b27fdfcfdd3015d
--- /dev/null
+++ b/tests/listings_table_enhancements.test.js
@@ -0,0 +1,138 @@
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+const test = require('node:test');
+
+const MIGRATION_FILE = path.resolve(
+  __dirname,
+  '..',
+  'db',
+  'migrations',
+  '003_listings_table_enhancements.sql'
+);
+const PRISMA_SCHEMA = path.resolve(__dirname, '..', 'db', 'schema.prisma');
+
+function loadMigration() {
+  return fs.readFileSync(MIGRATION_FILE, 'utf8');
+}
+
+function loadPrismaSchema() {
+  return fs.readFileSync(PRISMA_SCHEMA, 'utf8');
+}
+
+function extractTableBlock(sql, tableName) {
+  const tableRegex = new RegExp(
+    `CREATE TABLE\\s+"${tableName}"\\s*\\(([\\s\\S]*?)\\);`,
+    'i'
+  );
+  const match = sql.match(tableRegex);
+  assert.ok(match, `Expected to find CREATE TABLE for ${tableName}`);
+  return match[1];
+}
+
+function expectColumn(block, columnName, typePattern) {
+  const columnRegex = new RegExp(`"${columnName}"\\s+${typePattern}`, 'i');
+  assert.match(
+    block,
+    columnRegex,
+    `Expected column "${columnName}" definition to match /${typePattern}/i`
+  );
+}
+
+function extractPrismaModel(schema, modelName) {
+  const regex = new RegExp(`model\\s+${modelName}\\s+\\{([\\s\\S]*?)\\n\\}`, 'm');
+  const match = schema.match(regex);
+  assert.ok(match, `Expected to find Prisma model for ${modelName}`);
+  return match[1];
+}
+
+test('migration adds listings_categories bridge table with FKs', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingCategory');
+
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'categoryId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'assignedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    block,
+    /PRIMARY KEY\s*\("listingId",\s*"categoryId"\)/i,
+    'Expected composite primary key on listingId/categoryId'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)/i,
+    'Expected FK from listing_categories.listingId to Listing.id'
+  );
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingCategory_categoryId_fkey"\s+FOREIGN KEY\s*\("categoryId"\)\s+REFERENCES\s+"Category"\("id"\)/i,
+    'Expected FK from listing_categories.categoryId to Category.id'
+  );
+});
+
+test('migration adds listing_addresses table with geo references', () => {
+  const sql = loadMigration();
+  const block = extractTableBlock(sql, 'ListingAddress');
+
+  expectColumn(block, 'id', 'SERIAL\\s+PRIMARY\\s+KEY');
+  expectColumn(block, 'listingId', 'INTEGER\\s+NOT\\s+NULL');
+  expectColumn(block, 'label', 'TEXT');
+  expectColumn(block, 'addressLine1', 'TEXT');
+  expectColumn(block, 'addressLine2', 'TEXT');
+  expectColumn(block, 'city', 'TEXT');
+  expectColumn(block, 'region', 'TEXT');
+  expectColumn(block, 'postalCode', 'TEXT');
+  expectColumn(block, 'country', 'TEXT\\s+DEFAULT\\s+\'US\'');
+  expectColumn(block, 'latitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'longitude', 'DOUBLE\\s+PRECISION');
+  expectColumn(block, 'isPrimary', 'BOOLEAN\\s+NOT\\s+NULL\\s+DEFAULT\\s+FALSE');
+  expectColumn(block, 'countryId', 'INTEGER');
+  expectColumn(block, 'stateId', 'INTEGER');
+  expectColumn(block, 'cityId', 'INTEGER');
+  expectColumn(block, 'postalCodeId', 'INTEGER');
+  expectColumn(block, 'createdAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+  expectColumn(block, 'updatedAt', 'TIMESTAMPTZ\\s+NOT\\s+NULL\\s+DEFAULT\\s+NOW\\(\\)');
+
+  assert.match(
+    sql,
+    /CONSTRAINT\s+"ListingAddress_listingId_fkey"\s+FOREIGN KEY\s*\("listingId"\)\s+REFERENCES\s+"Listing"\("id"\)\s+ON DELETE CASCADE/i,
+    'Expected FK from listing_addresses.listingId to Listing.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("cityId"\)\s+REFERENCES\s+"City"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.cityId to City.id'
+  );
+  assert.match(
+    sql,
+    /FOREIGN KEY\s*\("postalCodeId"\)\s+REFERENCES\s+"PostalCode"\("id"\)\s+ON DELETE SET NULL/i,
+    'Expected FK from listing_addresses.postalCodeId to PostalCode.id'
+  );
+});
+
+test('Prisma schema exposes ListingAddress + ListingCategory relations', () => {
+  const schema = loadPrismaSchema();
+  const listingBlock = extractPrismaModel(schema, 'Listing');
+  assert.match(
+    listingBlock,
+    /addresses\s+ListingAddress\[\]/,
+    'Listing model should expose addresses relation'
+  );
+  assert.match(
+    listingBlock,
+    /categories\s+ListingCategory\[\]/,
+    'Listing model should expose categories relation'
+  );
+
+  const addressBlock = extractPrismaModel(schema, 'ListingAddress');
+  assert.match(addressBlock, /listingId\s+Int/, 'ListingAddress needs listingId field');
+  assert.match(addressBlock, /listing\s+Listing\s+@relation/, 'ListingAddress should relate to Listing');
+
+  const categoryBlock = extractPrismaModel(schema, 'ListingCategory');
+  assert.match(categoryBlock, /listing\s+Listing\s+@relation/, 'ListingCategory should relate to Listing');
+  assert.match(categoryBlock, /category\s+Category\s+@relation/, 'ListingCategory should relate to Category');
+});

tokens used
130,591
**Update Summary**
- Added regression coverage that inspects the new migration and Prisma schema so the listings↔categories bridge and physical addresses table must exist with the required columns/FKs (`tests/listings_table_enhancements.test.js:1-138`).
- Reworked the Prisma models to drop single-address columns from `Listing`, add the `ListingCategory`/`ListingAddress` models, and expose the new relations across `Category`, `Listing`, and the geography tables for proper cascading behavior (`db/schema.prisma:167-368`).
- Authored migration `003_listings_table_enhancements.sql` to drop the legacy columns/index, create the join table, create the address table, and add supporting indexes plus partial uniqueness for primary assignments (`db/migrations/003_listings_table_enhancements.sql:1-70`).
- Extended the seed script with helper sync routines plus concrete data that now populates multiple categories and multiple addresses per listing so the new schema is exercised (`db/seed.ts:230-707`).

**Testing**
- `npm test`

**Next Steps**
1. Apply the new migration and regenerate the Prisma client in any dev/test databases (`npx prisma migrate deploy && npx prisma generate`).
2. Re-seed your database (`ts-node db/seed.ts` or existing workflow) so the new category/address data is loaded.
