OpenAI Codex v0.57.0 (research preview)
--------
workdir: /var/home/rick/Development/mega-directory
model: gpt-5-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019a7859-c115-7bf0-a9f7-8575da624bd7
--------
user
Implement the functionality described in codex/TASKS/33_add_directory_routing_logic_subdomain_subdirectory_handling.yaml, then verify with any available tests.
ERROR: MCP client for `exa` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.exa]
startup_timeout_sec = XX
ERROR: MCP client for `mcp` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.mcp]
startup_timeout_sec = XX
ERROR: MCP client for `vibe-check-mcp-server` timed out after 10 seconds. Add or adjust `startup_timeout_sec` in your config.toml:
[mcp_servers.vibe-check-mcp-server]
startup_timeout_sec = XX

thinking
**Preparing to read task file**
exec
bash -lc 'ls codex/TASKS' in /var/home/rick/Development/mega-directory succeeded in 124ms:
00_prepare_repository.yaml
01_initialize_astro_frontend.yaml
02_setup_api_server_with_express_and_jwt_auth.yaml
03_design_postgresql_schema.yaml
04_implement_listing_ingestion_api_endpoint.yaml
05_admin_auth_route_and_middleware.yaml
06_frontend_directory_page_rendering.yaml
07_frontend_subcategory_ui_and_layout.yaml
08_setup_featured_listings_logic.yaml
09_add_category_meta_and_seo_controls.yaml
10_scaffold_python_crawler_agent.yaml
11_llm_field_generation_via_jinja2.yaml
12_post_listings_from_crawler_to_api_server.yaml
13_create_json_crawler_configuration_schema.yaml
14_scaffold_admin_ui_application.yaml
15_admin_ui:_listing_review_table.yaml
16_admin_ui:_category_location_approval.yaml
17_admin_ui:_seo_field_editor.yaml
18_deploy_web_+_api_to_railway.yaml
19_setup_logging,_healthchecks_and_monitoring.yaml

thinking
**Viewing file 33**
exec
bash -lc 'cat codex/TASKS/33_add_directory_routing_logic_subdomain_subdirectory_handling.yaml' in /var/home/rick/Development/mega-directory succeeded in 97ms:
id: 33
filename: 33_add_directory_routing_logic_subdomain_subdirectory_handling.yaml
title: Add Directory Routing Logic (Subdomain/Subdirectory Handling)
description: >
Implement dynamic routing rules based on configuration:
- Redirect subdirectory → subdomain or vice versa, per config
- Ensure astro site implements a configuration option where the site either uses the subdomain or the subdirectory to load the correct directory
- Enforce canonical URLs
- Integrate with Astro routing engine
- additional information regarding entire development project this task is part of can be referenced in `codex/TASKS/codex_phase_1b_2.yaml`
dependencies: []

thinking
**Exploring repository structure**
exec
bash -lc ls in /var/home/rick/Development/mega-directory succeeded in 44ms:
AGENTS.md
apps
codex
codex.toml
codex.yaml
db
docker-compose.yml
docs
docs.tar
env.json
Makefile
package.json
packages
README.md
scripts
tests
tsconfig.json

thinking
**Searching for Astro front-end**
exec
bash -lc 'ls apps' in /var/home/rick/Development/mega-directory succeeded in 45ms:
admin
api
crawler
web

thinking
**Investigating directory routing setup**
exec
bash -lc 'ls apps/web' in /var/home/rick/Development/mega-directory succeeded in 44ms:
astro.config.mjs
dist
Dockerfile
node_modules
package.json
package-lock.json
postcss.config.cjs
public
README.md
src
tailwind.config.mjs
test
tsconfig.json

thinking
**Inspecting source directory**
exec
bash -lc 'ls apps/web/src' in /var/home/rick/Development/mega-directory succeeded in 43ms:
components
config
data
layouts
lib
pages
styles

thinking
**Checking config folder**
exec
bash -lc 'ls apps/web/src/config' in /var/home/rick/Development/mega-directory succeeded in 43ms:
site-config.js

thinking
**Opening file for review**
exec
bash -lc 'cat apps/web/src/config/site-config.js' in /var/home/rick/Development/mega-directory succeeded in 43ms:
export const siteConfig = {
  siteName: 'Mega Directory',
  tagline: 'Curated business listings with reviewer-backed scoring and inclusive UX.',
  canonicalHost: 'megadirectory.local',
  canonicalUrl: 'https://megadirectory.local',
  defaultDescription:
    'Mega Directory delivers human-reviewed business listings with transparent scoring, accessibility-first markup, and lightning-fast Astro pages.',
  defaultOgImage: '/og-default.svg',
  twitterHandle: '@megadirectory',
  directoryRouting: {
    primary: 'subdirectory',
    subdirectoryBase: '/directories',
    subdomainRoot: 'megadirectory.local',
    protocol: 'https',
  },
};

thinking
**Searching for directoryRouting usage**
exec
bash -lc 'rg -n "directoryRouting" -n' in /var/home/rick/Development/mega-directory succeeded in 162ms:
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:145:  directoryRouting: {
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:154:**Searching for directoryRouting usage**
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:156:bash -lc 'rg -n "directoryRouting" -n' in /var/home/rick/Development/mega-directory
apps/web/src/config/site-config.js:10:  directoryRouting: {
apps/web/src/lib/directory-helpers.js:11:const directoryRouting = siteConfig.directoryRouting ?? {};
apps/web/src/lib/directory-helpers.js:12:const SUBDIRECTORY_BASE = normalizeBasePath(directoryRouting.subdirectoryBase ?? '/directories');
apps/web/src/lib/directory-helpers.js:13:const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
apps/web/src/lib/directory-helpers.js:14:const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
apps/web/src/lib/directory-helpers.js:16:  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:265:const directoryRouting = siteConfig.directoryRouting ?? {};
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:266:const SUBDIRECTORY_BASE = normalizeBasePath(directoryRouting.subdirectoryBase ?? '/directories');
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:267:const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:268:const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:270:  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:789:  directoryRouting: {
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:280:apps/web/src/lib/directory-helpers.js:13:const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:281:apps/web/src/lib/directory-helpers.js:16:  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:303:const directoryRouting = siteConfig.directoryRouting ?? {};
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:304:const SUBDIRECTORY_BASE = normalizeBasePath(directoryRouting.subdirectoryBase ?? '/directories');
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:305:const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');

thinking
**Opening directory-helpers.js file**
exec
bash -lc "sed -n '1,200p' apps/web/src/lib/directory-helpers.js" in /var/home/rick/Development/mega-directory succeeded in 45ms:
import { siteConfig } from '../config/site-config.js';

const FALLBACK_SCORE = -Infinity;
const DEFAULT_FEATURED_LIMIT = 3;
const FALLBACK_HERO_LABEL = 'Top pick';
const FALLBACK_TIER_TWO_LABEL = 'Tier-two highlight';
const FEATURED_TIER_ORDER = { HERO: 0, PREMIUM: 1, STANDARD: 2 };
const DEFAULT_DIRECTORY_NAME = 'Mega Directory';
const DEFAULT_CATEGORY_DESCRIPTION_TEMPLATE =
  'Discover curated NAME listings on Mega Directory.';
const directoryRouting = siteConfig.directoryRouting ?? {};
const SUBDIRECTORY_BASE = normalizeBasePath(directoryRouting.subdirectoryBase ?? '/directories');
const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
const PRIMARY_ROUTING_MODE =
  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';

function ensureLeadingSlash(value) {
  if (!value) {
    return '/';

thinking
**Extending file view**
exec
bash -lc "sed -n '200,400p' apps/web/src/lib/directory-helpers.js" in /var/home/rick/Development/mega-directory succeeded in 46ms:
  const locationSegment = normalizeSlug(locationSlug);
  const slug = `${categorySegment}/${locationSegment}`;
  return buildDirectoryPagePath({ subdirectory: slug });
}

export function buildSubcategoryPath(categoryOrDirectory, locationSlug, maybeSubcategory) {
  let directory;
  let subcategorySlug = maybeSubcategory;

  if (categoryOrDirectory && typeof categoryOrDirectory === 'object') {
    directory = categoryOrDirectory;
    subcategorySlug = locationSlug;
  } else {
    directory = { subdirectory: `${normalizeSlug(categoryOrDirectory)}/${normalizeSlug(locationSlug)}` };
  }

  const basePath = buildDirectoryPagePath(directory);
  if (!subcategorySlug) {
    return basePath;
  }

thinking
**Inspecting dynamic routing setup**
exec
bash -lc 'ls apps/web/src/pages' in /var/home/rick/Development/mega-directory succeeded in 47ms:
directories
index.astro

thinking
**Listing directories**
exec
bash -lc 'ls apps/web/src/pages/directories' in /var/home/rick/Development/mega-directory succeeded in 44ms:
index.astro
[...path].astro

thinking
**Checking bracket file presence**
exec
bash -lc "sed -n '1,200p' apps/web/src/pages/directories/[...path].astro" in /var/home/rick/Development/mega-directory succeeded in 46ms:
---
import DirectoryPage from '../../components/DirectoryPage.astro';
import { fetchDirectoryCatalog, fetchDirectoryBySlug } from '../../data/directory-service.js';
import {
  buildDirectoryRouteConfig,
  buildDirectorySubcategories,
  buildSubcategoryFilterNav,
  filterListingsBySubcategory,
  getDirectorySubdirectorySlug,
  segmentFeaturedListings,
  sortListingsByScore,
} from '../../lib/directory-helpers.js';

export async function getStaticPaths() {
  const directories = await fetchDirectoryCatalog();
  return directories.flatMap((directory) => {
    const baseSlug = getDirectorySubdirectorySlug(directory);
    const subcategoryEntries = buildDirectorySubcategories(directory).map((subcategory) => ({
      params: { path: `${baseSlug}/${subcategory.slug}` },
      props: { directorySlug: directory.slug, subcategorySlug: subcategory.slug },

thinking
**Investigating dynamic routing and directory data**

I’m focusing on implementing dynamic routing to handle subdomains versus subdirectories. To do that well, I want to check related files like `DirectoryPage` and see if there are functions managing canonical URLs or path handling. I’m inspecting the data in `apps/web/src/data/d` to understand the directory structure better. Let’s explore this carefully!
exec
bash -lc 'ls apps/web/src/data' in /var/home/rick/Development/mega-directory succeeded in 44ms:
directory-catalog.js
directory-service.js

thinking
**Opening service**
exec
bash -lc "sed -n '1,200p' apps/web/src/data/directory-service.js" in /var/home/rick/Development/mega-directory succeeded in 44ms:
import { directoryCatalog } from './directory-catalog.js';
import { findDirectoryBySlug } from '../lib/directory-helpers.js';

const API_BASE_URL =
  typeof import.meta?.env?.PUBLIC_API_BASE_URL === 'string'
    ? import.meta.env.PUBLIC_API_BASE_URL
    : typeof process !== 'undefined'
      ? process.env.PUBLIC_API_BASE_URL
      : undefined;

async function fetchJson(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed request ${response.status}`);
  }
  return response.json();
}

export async function fetchDirectoryCatalog() {
  if (!API_BASE_URL) {

thinking
**Searching for subdomain and routing config**
exec
bash -lc "rg -n \"subdomain\" -n apps/web/src -g'*'" in /var/home/rick/Development/mega-directory succeeded in 44ms:
apps/web/src/config/site-config.js:13:    subdomainRoot: 'megadirectory.local',
apps/web/src/data/directory-catalog.js:4:    subdomain: 'pros-nyc',
apps/web/src/data/directory-catalog.js:127:    subdomain: 'pros-denver',
apps/web/src/data/directory-catalog.js:214:    subdomain: 'jobs-nyc',
apps/web/src/data/directory-catalog.js:306:    subdomain: 'jobs-sf',
apps/web/src/lib/directory-helpers.js:13:const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
apps/web/src/lib/directory-helpers.js:16:  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
apps/web/src/lib/directory-helpers.js:136:  const slug = sanitizeHostname(directory?.subdomain);
apps/web/src/lib/directory-helpers.js:152:  const subdomainHost = buildDirectorySubdomainHost(directory);
apps/web/src/lib/directory-helpers.js:153:  const subdomainUrl = subdomainHost ? `${ROUTING_PROTOCOL}://${subdomainHost}` : null;
apps/web/src/lib/directory-helpers.js:155:    PRIMARY_ROUTING_MODE === 'subdomain' && subdomainUrl ? subdomainUrl : `${canonicalBaseUrl}${subdirectory}`;
apps/web/src/lib/directory-helpers.js:159:    subdomainHost,
apps/web/src/lib/directory-helpers.js:160:    subdomainUrl,

thinking
**Opening directory catalog file**
exec
bash -lc "sed -n '1,160p' apps/web/src/data/directory-catalog.js" in /var/home/rick/Development/mega-directory succeeded in 42ms:
export const directoryCatalog = [
  {
    slug: 'professional-services-new-york-city',
    subdomain: 'pros-nyc',
    subdirectory: 'professional-services/new-york-city',
    locationAgnostic: false,
    name: 'NYC Professional Services',
    heroTitle: 'Trusted Pros in New York City',
    heroSubtitle: 'Electricians, HVAC teams, and general contractors with transparent SLAs.',
    category: {
      slug: 'professional-services',
      name: 'Professional Services',
      description: 'Verified operators for commercial and residential work orders.',
      metaTitle: 'Professional Services Directory',
      metaDescription: 'Curated electricians, HVAC crews, and facilities partners.',
    },
    location: {
      slug: 'new-york-city',
      name: 'New York City',
      state: 'NY',

thinking
**Planning dynamic routing implementation**
exec
bash -lc 'cat apps/web/astro.config.mjs' in /var/home/rick/Development/mega-directory succeeded in 43ms:
// @ts-check
import { defineConfig } from 'astro/config';
import tailwind from '@astrojs/tailwind';

export default defineConfig({
  integrations: [
    tailwind({
      applyBaseStyles: true,
    }),
  ],
});

thinking
**Planning dynamic routing and canonical logic**

I'm figuring out how to implement dynamic routing based on host or subdirectory, with canonical URLs and redirects aligned to configuration. I want to check existing directory routes and middleware, explore components like DirectoryPage, and investigate how canonical logic is currently handled to ensure smooth integration with Astro and routing setup. Let’s explore the config and code for this!
exec
bash -lc 'rg -n "canonical" -n apps/web/src' in /var/home/rick/Development/mega-directory succeeded in 51ms:
apps/web/src/config/site-config.js:4:  canonicalHost: 'megadirectory.local',
apps/web/src/config/site-config.js:5:  canonicalUrl: 'https://megadirectory.local',
apps/web/src/lib/directory-helpers.js:13:const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
apps/web/src/lib/directory-helpers.js:108:const canonicalBaseUrl =
apps/web/src/lib/directory-helpers.js:109:  siteConfig.canonicalUrl?.replace(/\/$/, '') ||
apps/web/src/lib/directory-helpers.js:110:  (siteConfig.canonicalHost ? `${ROUTING_PROTOCOL}://${siteConfig.canonicalHost}` : '');
apps/web/src/lib/directory-helpers.js:154:  const canonical =
apps/web/src/lib/directory-helpers.js:155:    PRIMARY_ROUTING_MODE === 'subdomain' && subdomainUrl ? subdomainUrl : `${canonicalBaseUrl}${subdirectory}`;
apps/web/src/lib/directory-helpers.js:161:    canonicalUrl: canonical,
apps/web/src/layouts/BaseLayout.astro:30:const canonicalBase = siteConfig.canonicalUrl?.replace(/\/$/, '') || '';
apps/web/src/layouts/BaseLayout.astro:32:const canonicalUrl =
apps/web/src/layouts/BaseLayout.astro:33:  seo.canonicalUrl ??
apps/web/src/layouts/BaseLayout.astro:34:  (canonicalBase ? `${canonicalBase}${currentPath || '/'}` : currentPath || '/');
apps/web/src/layouts/BaseLayout.astro:56:    {canonicalUrl && <link rel="canonical" href={canonicalUrl} />}
apps/web/src/layouts/BaseLayout.astro:71:    {canonicalUrl && <meta property="og:url" content={canonicalUrl} />}
apps/web/src/components/DirectoryPage.astro:42:  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
apps/web/src/components/DirectoryPage.astro:60:    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,

thinking
**Opening BaseLayout component**
exec
bash -lc "sed -n '1,200p' apps/web/src/layouts/BaseLayout.astro" in /var/home/rick/Development/mega-directory succeeded in 40ms:
---
import SiteFooter from '../components/SiteFooter.astro';
import SiteHeader from '../components/SiteHeader.astro';
import { siteConfig } from '../config/site-config.js';
import '../styles/global.css';

const {
  title,
  description,
  navItems,
  showHeader = true,
  showFooter = true,
  seo = {},
} = Astro.props;

const siteName = siteConfig.siteName;
const resolvedTitle = title ?? siteName;
const computedTitle =
  seo.title ??
  (resolvedTitle === siteName ? siteName : `${resolvedTitle} · ${siteName}`);

thinking
**Investigating canonical meta handling**
exec
bash -lc "sed -n '1,200p' apps/web/src/components/DirectoryPage.astro" in /var/home/rick/Development/mega-directory succeeded in 44ms:
---
import BaseLayout from '../layouts/BaseLayout.astro';
import {
  resolveCategorySeoMetadata,
  buildDirectoryMapPins,
  shouldRenderDirectoryMap,
} from '../lib/directory-helpers.js';
import DirectoryListing from './DirectoryListing.astro';
import DirectoryMap from './DirectoryMap.astro';

const {
  directory,
  navItems,
  heroStats,
  listings = [],
  totalListings = listings.length,
  subcategoryNav = [],
  featuredHero = null,
  featuredTierTwo = [],
  mapListings = directory?.listings ?? [],

thinking
**Checking routing logic in pages**
exec
bash -lc "sed -n '1,160p' apps/web/src/pages/directories/index.astro" in /var/home/rick/Development/mega-directory succeeded in 40ms:
---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { directoryCatalog } from '../../data/directory-catalog.js';
import { buildDirectoryGroups } from '../../lib/directory-helpers.js';

const groups = buildDirectoryGroups(directoryCatalog);
const totalLocations = groups.reduce((sum, group) => sum + group.locations.length, 0);
const totalListings = groups.reduce((sum, group) => sum + group.totalListings, 0);

const navItems = [
  { href: '#overview', label: 'Overview' },
  { href: '#directories', label: 'Directories' },
];

const heroStats = [
  { label: 'Active categories', value: groups.length },
  { label: 'Locations tracked', value: totalLocations },
  { label: 'Listings scored', value: totalListings },
];
---

thinking
**Planning subdomain and routing integration**
exec
bash -lc "rg -n \"Astro\" apps/web/src -g'*middleware*'" in /var/home/rick/Development/mega-directory exited 1 in 43ms:


thinking
**Checking for middleware and Astro usage**
exec
bash -lc 'cat apps/web/package.json' in /var/home/rick/Development/mega-directory succeeded in 42ms:
{
  "name": "mega-directory-astro",
  "private": true,
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "start": "astro dev",
    "build": "astro build",
    "preview": "astro preview",
    "test": "node --test ./test/**/*.test.mjs",
    "astro": "astro"
  },
  "dependencies": {
    "astro": "^5.15.5"
  },
  "devDependencies": {
    "@astrojs/tailwind": "^5.1.1",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.49",

thinking
**Investigating middleware for host routing**
exec
bash -lc 'rg -n "getDirectorySubdirectorySlug" -n' in /var/home/rick/Development/mega-directory succeeded in 46ms:
apps/web/test/directory-helpers.test.mjs:16:  getDirectorySubdirectorySlug,
apps/web/test/directory-helpers.test.mjs:190:test('getDirectorySubdirectorySlug + buildDirectoryPagePath respect overrides', () => {
apps/web/test/directory-helpers.test.mjs:192:  assert.strictEqual(getDirectorySubdirectorySlug(directory), 'professional-services/new-york-city');
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:254:  getDirectorySubdirectorySlug,
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:262:    const baseSlug = getDirectorySubdirectorySlug(directory);
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:493:bash -lc 'rg -n "getDirectorySubdirectorySlug" -n' in /var/home/rick/Development/mega-directory
apps/web/src/lib/directory-helpers.js:112:export function getDirectorySubdirectorySlug(directory) {
apps/web/src/lib/directory-helpers.js:144:  const slug = getDirectorySubdirectorySlug(directory);
apps/web/src/lib/directory-helpers.js:179:    (directory) => getDirectorySubdirectorySlug(directory) === target,
apps/web/src/pages/directories/[...path].astro:9:  getDirectorySubdirectorySlug,
apps/web/src/pages/directories/[...path].astro:17:    const baseSlug = getDirectorySubdirectorySlug(directory);
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:241:  getDirectorySubdirectorySlug,
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:248:    const baseSlug = getDirectorySubdirectorySlug(directory);
codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log:339:  getDirectorySubdirectorySlug,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:158:  getDirectorySubdirectorySlug,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:165:    const baseSlug = getDirectorySubdirectorySlug(directory);
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:762:  getDirectorySubdirectorySlug,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:1084:   getDirectorySubdirectorySlug,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:1230:   getDirectorySubdirectorySlug,
codex/LOGS/tasklog_31_build_map_widget_for_directory_pages_with_location-aware_listings_1762953703.log:1532:   getDirectorySubdirectorySlug,

thinking
**Checking for existing tests**
exec
bash -lc "sed -n '1,250p' apps/web/test/directory-helpers.test.mjs" in /var/home/rick/Development/mega-directory succeeded in 40ms:
import test from 'node:test';
import assert from 'node:assert/strict';
import {
  sortListingsByScore,
  buildDirectoryGroups,
  buildDirectoryPath,
  buildDirectoryPagePath,
  buildDirectoryRouteConfig,
  buildSubcategoryPath,
  buildDirectorySubcategories,
  buildSubcategoryFilterNav,
  filterListingsBySubcategory,
  findDirectoryEntry,
  findDirectoryBySlug,
  findDirectoryBySubdirectory,
  getDirectorySubdirectorySlug,
  segmentFeaturedListings,
  resolveCategorySeoMetadata,
  buildDirectoryMapPins,
  shouldRenderDirectoryMap,

thinking
**Preparing to add tests**
exec
bash -lc "sed -n '250,500p' apps/web/test/directory-helpers.test.mjs" in /var/home/rick/Development/mega-directory succeeded in 40ms:
  });
});

test('shouldRenderDirectoryMap respects location-agnostic directories and coordinate presence', () => {
  const nyc = sampleDirectories[0];
  const pins = buildDirectoryMapPins(nyc);
  assert.ok(shouldRenderDirectoryMap(nyc, pins));

  const agnosticDirectory = sampleDirectories[2];
  assert.strictEqual(shouldRenderDirectoryMap(agnosticDirectory), false, 'location-agnostic hidden');

  const listingsWithoutCoords = nyc.listings.map((entry) => ({ ...entry, latitude: null, longitude: null, coordinates: null }));
  assert.strictEqual(
    shouldRenderDirectoryMap(nyc, buildDirectoryMapPins(nyc, listingsWithoutCoords)),
    false,
    'no pins when coordinates missing',
  );
});

test('buildDirectoryGroups nests directories under categories and locations with stats', () => {

thinking
**Evaluating routing test needs**
exec
bash -lc 'ls apps/web/src/lib' in /var/home/rick/Development/mega-directory succeeded in 40ms:
directory-helpers.js

thinking
**Planning dynamic routing integration**

I’m figuring out how to implement dynamic routing in Astro that handles subdomain and subdirectory strategies per configuration, redirects to canonical URLs, and hooks into Astro’s middleware for host and path detection. I’m considering creating middleware to inspect requests, possibly disabling prerender for dynamic subdomain routing, and mapping directory data to requests to unify routing behavior. Next, I’ll search docs and repo for relevant references to help clarify these requirements.
exec
bash -lc 'rg -n "subdirectory" -n' in /var/home/rick/Development/mega-directory succeeded in 49ms:
apps/admin/test/directoryPageService.test.js:26:    subdirectory: '',
apps/admin/test/directoryPageService.test.js:35:    ['categoryId', 'locationId', 'metaDescription', 'metaTitle', 'subdirectory', 'subdomain', 'title']
apps/admin/test/directoryPageService.test.js:47:    subdirectory: existing.subdirectory,
apps/admin/test/directoryPageService.test.js:54:  assert.ok(duplicate.errors.subdirectory);
apps/admin/test/directoryPageService.test.js:70:    subdirectory: '  remote/support  ',
apps/admin/test/directoryPageService.test.js:86:  assert.strictEqual(result.record.subdirectory, 'remote/support');
apps/admin/services/directoryPageService.js:111:        subdirectory: '',
apps/admin/services/directoryPageService.js:161:  if (payload.subdirectory !== undefined || mode === 'create') {
apps/admin/services/directoryPageService.js:162:    next.subdirectory = sanitizeSubdirectory(payload.subdirectory);
apps/admin/services/directoryPageService.js:163:    next.slug = buildSlug(next.subdirectory);
apps/admin/services/directoryPageService.js:164:  } else if (!next.slug && next.subdirectory) {
apps/admin/services/directoryPageService.js:165:    next.slug = buildSlug(next.subdirectory);
apps/admin/services/directoryPageService.js:196:  if (!record.subdirectory) {
apps/admin/services/directoryPageService.js:197:    errors.subdirectory = 'Subdirectory is required';
apps/admin/services/directoryPageService.js:198:  } else if (!isUnique('subdirectory', record.subdirectory, currentId)) {
apps/admin/services/directoryPageService.js:199:    errors.subdirectory = 'Subdirectory is already in use';
apps/admin/services/directoryPageService.js:236:function buildSlug(subdirectory = '') {
apps/admin/services/directoryPageService.js:237:  const normalized = sanitizeSubdirectory(subdirectory);
apps/admin/data/directoryPages.js:10:    subdirectory: 'nyc/electricians',
apps/admin/data/directoryPages.js:31:    subdirectory: 'atlanta-ga/plumbers',

thinking
**Searching tests for routing**
exec
bash -lc 'rg -n "routing" -n apps/web' in /var/home/rick/Development/mega-directory succeeded in 46ms:
apps/web/public/og-default.svg:26:    Subdomain + subdirectory routing with ADA-first layouts

thinking
**Analyzing directory routing with subdomain support**

I'm exploring how to implement directory routing that supports both subdomain and subdirectory approaches. The key challenge is to hook into the request's host and path to serve or redirect correctly, which may require switching Astro's output mode from static SSG to SSR to enable runtime host detection and dynamic routing behavior. I'll verify the current config and consider how middleware or route logic can handle this.
exec
bash -lc 'rg -n "output" apps/web/astro.config.mjs' in /var/home/rick/Development/mega-directory exited 1 in 43ms:


thinking
**Designing directory routing middleware**

I’m mapping out how to implement host-based (subdomain) and path-based (subdirectory) routing with automatic canonical redirects using Astro middleware, focusing on resolving requests by parsing hostnames and paths, and considering data fetching, route rewrites, and where to place helper functions for clean integration. There’s a lot to juggle with request handling APIs and caching strategies, so I’m reviewing the best place to hook into Astro’s lifecycle and how to safely rewrite or redirect requests dynamically.
exec
bash -lc "rg -n \"MiddlewareHandler\" -g'*' node_modules/astro -n" in /var/home/rick/Development/mega-directory exited 2 in 43ms:
rg: node_modules/astro: IO error for operation on node_modules/astro: No such file or directory (os error 2)

thinking
**Checking dependencies location**
exec
bash -lc "rg -n \"MiddlewareHandler\" -g'*' apps/web/node_modules -n" in /var/home/rick/Development/mega-directory exited 124 in 10.06s:


thinking
**Narrowing search scope**
exec
bash -lc 'ls apps/web/node_modules | head' in /var/home/rick/Development/mega-directory succeeded in 43ms:
acorn
@alloc
ansi-align
ansi-regex
ansi-styles
anymatch
any-promise
arg
argparse
aria-query

thinking
**Searching for astro folder**
exec
bash -lc 'ls apps/web/node_modules | grep astro | head' in /var/home/rick/Development/mega-directory succeeded in 42ms:
astro
@astrojs

thinking
**Searching for MiddlewareHandler in Astro node_modules**
exec
bash -lc 'rg -n "MiddlewareHandler" apps/web/node_modules/astro | head' in /var/home/rick/Development/mega-directory succeeded in 244ms:


thinking
**Searching for APIContext and rewrite usage**
exec
bash -lc 'rg -n "rewrite" apps/web/node_modules/astro | head' in /var/home/rick/Development/mega-directory succeeded in 44ms:


thinking
**Analyzing middleware strategies for subdomain routing**

I’m exploring how to use middleware in Astro to distinguish between subdomain and subdirectory routing modes. The goal is to serve directory pages either on the subdomain or subdirectory based on a config setting, possibly by rewriting request paths or redirecting to canonical URLs. Since Astro’s middleware API might lack rewrite support, I’m considering alternatives like returning custom responses or tweaking route parameters, but I need to verify actual capabilities in Astro’s server code and type definitions to find the best approach.
exec
bash -lc 'rg -n "onRequest" apps/web/node_modules/astro | head -n 40' in /var/home/rick/Development/mega-directory succeeded in 46ms:


thinking
**Inspecting Astro middleware types**
exec
bash -lc 'ls apps/web/node_modules/astro/dist/types/public' in /var/home/rick/Development/mega-directory succeeded in 59ms:
common.d.ts
common.js
config.d.ts
config.js
content.d.ts
content.js
context.d.ts
context.js
elements.d.ts
elements.js
extendables.d.ts
extendables.js
index.d.ts
index.js
integrations.d.ts
integrations.js
internal.d.ts
internal.js
manifest.d.ts
manifest.js

thinking
**Checking for middleware definitions**
exec
bash -lc "rg -n \"Middleware\" apps/web/node_modules/astro/dist/types -g'*.d.ts' | head -n 40" in /var/home/rick/Development/mega-directory succeeded in 208ms:
apps/web/node_modules/astro/dist/types/public/common.d.ts:86:export type MiddlewareNext = (rewritePayload?: RewritePayload) => Promise<Response>;
apps/web/node_modules/astro/dist/types/public/common.d.ts:87:export type MiddlewareHandler = (context: APIContext, next: MiddlewareNext) => Promise<Response> | Response | Promise<void> | void;
apps/web/node_modules/astro/dist/types/public/common.d.ts:88:export type AstroMiddlewareInstance = {
apps/web/node_modules/astro/dist/types/public/common.d.ts:89:    onRequest?: MiddlewareHandler;
apps/web/node_modules/astro/dist/types/public/context.d.ts:482:     * import { defineMiddleware } from "astro:middleware";
apps/web/node_modules/astro/dist/types/public/context.d.ts:484:     * export const onRequest = defineMiddleware((context, next) => {
apps/web/node_modules/astro/dist/types/public/integrations.d.ts:71:    edgeMiddleware: boolean;
apps/web/node_modules/astro/dist/types/public/integrations.d.ts:144:export type AstroIntegrationMiddleware = {
apps/web/node_modules/astro/dist/types/public/integrations.d.ts:161:        addMiddleware: (mid: AstroIntegrationMiddleware) => void;

thinking
**Opening context type definitions**
exec
bash -lc "sed -n '430,520p' apps/web/node_modules/astro/dist/types/public/context.d.ts" in /var/home/rick/Development/mega-directory succeeded in 44ms:
     *   return [
     *     { params: { id: '0' }, props: { name: 'Sarah' } },
     *     { params: { id: '1' }, props: { name: 'Chris' } },
     *     { params: { id: '2' }, props: { name: 'Fuzzy' } },
     *   ];
     * }
     *
     * export function GET({ props }: APIContext): Response {
     *   return new Response(`Hello ${props.name}!`);
     * }
     * ```
     *
     * [Reference](https://docs.astro.build/en/reference/api-reference/#contextprops)
     */
    props: AstroSharedContext<Props, APIParams>['props'];
    /**
     * Create a response that redirects to another page.
     *
     * Example usage:
     * ```ts


thinking
**Designing middleware for directory routing**

I'm working out how to implement middleware using Astro’s `defineMiddleware` to handle directory-based routing by rewriting requests based on host or path. Since needed helper functions like `sanitizeHostname` aren’t exported from `directory-helpers`, I’m planning to add exports for key constants and functions to avoid duplication, while considering a new shared module for routing utilities to keep logic consistent and maintainable.
thinking
**Searching for normalizeSubdirectory usage**
exec
bash -lc 'rg -n "normalizeSubdirectory" -n' in /var/home/rick/Development/mega-directory succeeded in 47ms:
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:738:**Searching for normalizeSubdirectory usage**
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:740:bash -lc 'rg -n "normalizeSubdirectory" -n' in /var/home/rick/Development/mega-directory
apps/web/src/lib/directory-helpers.js:54:const normalizeSubdirectory = (value, fallback = 'directory') => {
apps/web/src/lib/directory-helpers.js:118:    return normalizeSubdirectory(directory.subdirectory);
apps/web/src/lib/directory-helpers.js:122:    return normalizeSubdirectory(directory.slug);
apps/web/src/lib/directory-helpers.js:128:    return normalizeSubdirectory(`${categorySlug}/${locationSlug}`);
apps/web/src/lib/directory-helpers.js:132:  return normalizeSubdirectory(derived || directory.name);
apps/web/src/lib/directory-helpers.js:177:  const target = normalizeSubdirectory(subdirectoryPath);
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:1809:+function normalizeSubdirectory(value, fallback = 'directory') {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:1970:+function normalizeSubdirectory(value, fallback = 'directory') {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2130:+function normalizeSubdirectory(value, fallback = 'directory') {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2152:-function normalizeSubdirectory(value, fallback = 'directory') {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2471:+const normalizeSubdirectory = (value, fallback = 'directory') => {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2639:+const normalizeSubdirectory = (value, fallback = 'directory') => {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2807:+const normalizeSubdirectory = (value, fallback = 'directory') => {
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2840:+    return normalizeSubdirectory(directory.subdirectory);
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2844:+    return normalizeSubdirectory(directory.slug);
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2848:+  return normalizeSubdirectory(derived || directory.name);
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:2893:+  const target = normalizeSubdirectory(subdirectoryPath);
codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log:3055:+const normalizeSubdirectory = (value, fallback = 'directory') => {

thinking
**Planning module refactoring and middleware integration**

I’m working through exporting key functions like `normalizeSubdirectory` and `sanitizeHostname` from `directory-helpers.js` to avoid duplication, considering how to restructure or create a new `directory-routing.js` module for middleware use, and thinking through implementation details for middleware handling directory matching by subdomain, including hostname sanitization, caching, and request rewriting logic. This involves careful exporting and importing to prevent circular dependencies and ensuring consistent hostname normalization across modules.
exec
bash -lc 'rg -n "rewrite" apps/web/node_modules/astro/dist/types/public/context.d.ts' in /var/home/rick/Development/mega-directory succeeded in 42ms:
119:     * It rewrites to another page. As opposed to redirects, the URL won't change, and Astro will render the HTML emitted
126:     * 	return Astro.rewrite('/fallback-page')
130:    rewrite: AstroSharedContext['rewrite'];
258:     * Useful to track the original URL before rewrites were applied.
282:     * It rewrites to another page. As opposed to redirects, the URL won't change, and Astro will render the HTML emitted
289:     * 	return Astro.rewrite('/fallback-page')
293:    rewrite(rewritePayload: RewritePayload): Promise<Response>;
468:     *   return ctx.rewrite(new URL("../"), ctx.url);
472:    rewrite: AstroSharedContext['rewrite'];

thinking
**Inspecting common.d.ts for RewritePayload**
exec
bash -lc "sed -n '60,140p' apps/web/node_modules/astro/dist/types/public/common.d.ts" in /var/home/rick/Development/mega-directory succeeded in 49ms:
    size: number;
    /** number of last page */
    lastPage: number;
    url: {
        /** url of the current page */
        current: string;
        /** url of the previous page (if there is one) */
        prev: string | undefined;
        /** url of the next page (if there is one) */
        next: string | undefined;
        /** url of the first page (if the current page is not the first page) */
        first: string | undefined;
        /** url of the last page (if the current page is not the last page) */
        last: string | undefined;
    };
}
export type PaginateFunction = <PaginateData, AdditionalPaginateProps extends Props, AdditionalPaginateParams extends Params>(data: readonly PaginateData[], args?: PaginateOptions<AdditionalPaginateProps, AdditionalPaginateParams>) => {
    params: Simplify<{
        page: string | undefined;
    } & OmitIndexSignature<AdditionalPaginateParams>>;




thinking
**Designing middleware for directory routing**
thinking
**Planning modular routing helpers and tests**

I'm organizing pure helper functions into a new module to handle directory and subdomain matching based on paths and hosts. This will keep middleware focused and make testing easier by letting me write unit tests for these core routing logics separately. I'm also deciding how to reuse normalization utilities and sample data to keep tests manageable and consistent.
thinking
**Detailing routing utility functions and middleware integration**

I'm outlining the precise data structures and helper functions needed for path and host matching, plus building canonical URLs and redirect targets. I’m also sketching how these utilities tie into middleware logic for handling requests efficiently, including caching and early exits for irrelevant paths or hosts. This detailed plan helps me stay organized before diving into coding everything.
thinking
**Designing caching and matching utilities with thorough testing plan**

I’m implementing directory caching, refined subdomain and subdirectory match functions, and utility helpers ensuring consistent path normalization and base stripping. I’m also thinking through middleware integration and how to efficiently avoid redundant computations, plus planning tests to validate these new routing helpers end-to-end.
exec
bash -lc 'rg -n "@astrojs/node" -n' in /var/home/rick/Development/mega-directory succeeded in 51ms:
codex/LOGS/tasklog_33_add_directory_routing_logic_subdomain_subdirectory_handling_1762955739.log:821:bash -lc 'rg -n "@astrojs/node" -n' in /var/home/rick/Development/mega-directory

thinking
**Evaluating SSR adapter constraints and routing approach**

I'm examining why the Astro Node adapter isn't present, which blocks true SSR with `output: 'server'`. Given network restrictions preventing installing new dependencies, adding the adapter isn't feasible, so I plan to implement middleware compatible with existing static or dev setups without changing config yet. I'll also ensure canonical URLs correctly reflect subcategory paths by passing `subcategorySlug` from the dynamic route to the page component and adjusting SEO metadata accordingly. This approach balances spec demands with environment limits and sets up for future SSR enablement if the adapter is added.
exec
bash -lc 'rg -n "buildSubcategoryFilterNav" apps/web/src/lib/directory-helpers.js' in /var/home/rick/Development/mega-directory succeeded in 42ms:
426:export function buildSubcategoryFilterNav(directory, activeSubcategory) {
exec
bash -lc "sed -n '400,520p' apps/web/src/lib/directory-helpers.js" in /var/home/rick/Development/mega-directory succeeded in 40ms:
    .sort((a, b) => {
      if (b.listingCount !== a.listingCount) {
        return b.listingCount - a.listingCount;
      }
      return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
    });
}

export function filterListingsBySubcategory(listings = [], subcategorySlug) {
  const sortedListings = sortListingsByScore(listings);
  if (!subcategorySlug) {
    return sortedListings;
  }

  const normalizedSlug = normalizeSlug(subcategorySlug, '');
  if (!normalizedSlug) {
    return [];
  }

  return sortedListings.filter((listing) =>

thinking
**Reviewing slug normalization and middleware integration**

I'm making sure the `buildSubcategoryFilterNav` uses a normalized slug consistently, especially through runtime path rewriting and new middleware. I want to confirm that rewritten paths are sanitized and align with static paths, while considering server-side middleware behavior, caching, and testing impact before running relevant tests.
exec
bash -lc 'cat package.json' in /var/home/rick/Development/mega-directory succeeded in 39ms:
{
  "name": "mega-directory",
  "private": true,
  "version": "0.1.0",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "test": "npm run test:root && npm run test:workspaces",
    "test:root": "node --test tests/**/*.test.js",
    "test:workspaces": "npm run test --workspaces --if-present"
  }
}

thinking
**Planning test strategy and implementation steps**
Plan update
Implementing routing requires coordinating helpers, middleware, and tests, so outlining the steps keeps changes consistent.
  → Inspect current directory routing helpers/config and design needed test coverage for subdomain vs. subdirectory flows.
  • Implement routing helpers + middleware + canonical updates driven by the new tests.
  • Run the relevant test suites and verify routing-related behavior.

thinking
**Marking Step1 completion for plan update**
Plan update
  ✓ Inspect current directory routing helpers/config and design needed test coverage for subdomain vs. subdirectory flows.
  → Implement routing helpers + middleware + canonical updates driven by the new tests.
  • Run the relevant test suites and verify routing-related behavior.

thinking
**Planning TDD setup for new module**

I’m figuring out how to add tests before implementing `directory-routing.js` following TDD. I’ll create a stub module exporting placeholder functions so tests can import without error, then write tests that fail initially, ensuring proper TDD workflow. Also, I need to update `directory-helpers.js` to export some constants and functions to support the new module and tests.

thinking
**Inspecting sanitizeHostname function**
exec
bash -lc "sed -n '1,120p' apps/web/src/lib/directory-helpers.js" in /var/home/rick/Development/mega-directory succeeded in 39ms:
import { siteConfig } from '../config/site-config.js';

const FALLBACK_SCORE = -Infinity;
const DEFAULT_FEATURED_LIMIT = 3;
const FALLBACK_HERO_LABEL = 'Top pick';
const FALLBACK_TIER_TWO_LABEL = 'Tier-two highlight';
const FEATURED_TIER_ORDER = { HERO: 0, PREMIUM: 1, STANDARD: 2 };
const DEFAULT_DIRECTORY_NAME = 'Mega Directory';
const DEFAULT_CATEGORY_DESCRIPTION_TEMPLATE =
  'Discover curated NAME listings on Mega Directory.';
const directoryRouting = siteConfig.directoryRouting ?? {};
const SUBDIRECTORY_BASE = normalizeBasePath(directoryRouting.subdirectoryBase ?? '/directories');
const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
const PRIMARY_ROUTING_MODE =
  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';

function ensureLeadingSlash(value) {
  if (!value) {
    return '/';

thinking
**Applying patch to add exports**
file update
M /var/home/rick/Development/mega-directory/apps/web/src/lib/directory-helpers.js
@@ -16,2 +16,8 @@
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
apply_patch(auto_approved=true) exited 0 in 6ms:
Success. Updated the following files:
M apps/web/src/lib/directory-helpers.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..71b85a86783164a16e54743a3b56ec3040158a9f
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..71b85a86783164a16e54743a3b56ec3040158a9f
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {


thinking
**Exporting sanitizeHostname function**
file update
M /var/home/rick/Development/mega-directory/apps/web/src/lib/directory-helpers.js
@@ -38,3 +38,3 @@
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/web/src/lib/directory-helpers.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..4662e2f9efd3e76b70b6aea896aa63c735fe744e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..4662e2f9efd3e76b70b6aea896aa63c735fe744e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()


thinking
**Preparing to export function**
file update
M /var/home/rick/Development/mega-directory/apps/web/src/lib/directory-helpers.js
@@ -59,3 +59,3 @@
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
apply_patch(auto_approved=true) exited 0 in 8ms:
Success. Updated the following files:
M apps/web/src/lib/directory-helpers.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }


thinking
**Designing stub module with planned exports**

I'll create a stub module exporting all planned functions with placeholder returns to avoid import errors, setting the stage for writing tests next before implementing actual logic.
file update
A /var/home/rick/Development/mega-directory/apps/web/src/lib/directory-routing.js
import {
  buildDirectoryPagePath,
  buildDirectoryRouteConfig,
  directoryRoutingSettings,
  getDirectorySubdirectorySlug,
  normalizeSubdirectory,
  sanitizeHostname,
} from './directory-helpers.js';

export function matchSubdirectoryRequest() {
  return null;
}

export function matchSubdomainRequest() {
  return null;
}

export function buildDirectoryResponseTargets(directory, subpath = '') {
  const routeConfig = buildDirectoryRouteConfig(directory);
  const path = buildDirectoryPagePath(directory);
  return {
    path,
    canonicalUrl: routeConfig.canonicalUrl,
    subdomainUrl: routeConfig.subdomainUrl,
    subpath,
  };
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A apps/web/src/lib/directory-routing.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..276bda7fda35e51456cd2c87d1f37246617dac7f
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,27 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+export function matchSubdirectoryRequest() {
+  return null;
+}
+
+export function matchSubdomainRequest() {
+  return null;
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  const routeConfig = buildDirectoryRouteConfig(directory);
+  const path = buildDirectoryPagePath(directory);
+  return {
+    path,
+    canonicalUrl: routeConfig.canonicalUrl,
+    subdomainUrl: routeConfig.subdomainUrl,
+    subpath,
+  };
+}

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..276bda7fda35e51456cd2c87d1f37246617dac7f
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,27 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+export function matchSubdirectoryRequest() {
+  return null;
+}
+
+export function matchSubdomainRequest() {
+  return null;
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  const routeConfig = buildDirectoryRouteConfig(directory);
+  const path = buildDirectoryPagePath(directory);
+  return {
+    path,
+    canonicalUrl: routeConfig.canonicalUrl,
+    subdomainUrl: routeConfig.subdomainUrl,
+    subpath,
+  };
+}


thinking
**Preparing new test cases for directory routing**
file update
M /var/home/rick/Development/mega-directory/apps/web/test/directory-helpers.test.mjs
@@ -21,2 +21,7 @@
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
@@ -470 +475,56 @@
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M apps/web/test/directory-helpers.test.mjs
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..276bda7fda35e51456cd2c87d1f37246617dac7f
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,27 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+export function matchSubdirectoryRequest() {
+  return null;
+}
+
+export function matchSubdomainRequest() {
+  return null;
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  const routeConfig = buildDirectoryRouteConfig(directory);
+  const path = buildDirectoryPagePath(directory);
+  return {
+    path,
+    canonicalUrl: routeConfig.canonicalUrl,
+    subdomainUrl: routeConfig.subdomainUrl,
+    subpath,
+  };
+}
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..276bda7fda35e51456cd2c87d1f37246617dac7f
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,27 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+export function matchSubdirectoryRequest() {
+  return null;
+}
+
+export function matchSubdomainRequest() {
+  return null;
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  const routeConfig = buildDirectoryRouteConfig(directory);
+  const path = buildDirectoryPagePath(directory);
+  return {
+    path,
+    canonicalUrl: routeConfig.canonicalUrl,
+    subdomainUrl: routeConfig.subdomainUrl,
+    subpath,
+  };
+}
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Implementing directory-routing logic with helpers**

I’m mapping out the core functions to handle subdirectory and subdomain routing by normalizing paths and hosts carefully. I’m focusing on computing a consistent base path, stripping it from request paths, and matching directories based on slugs. The plan covers helper utilities to cleanly append subpaths and build response targets, all while respecting case and trailing slash edge cases. Next, I’ll replace the stubs with this logic in `directory-routing.js`.
file update
D /var/home/rick/Development/mega-directory/apps/web/src/lib/directory-routing.js
import {
  buildDirectoryPagePath,
  buildDirectoryRouteConfig,
  directoryRoutingSettings,
  getDirectorySubdirectorySlug,
  normalizeSubdirectory,
  sanitizeHostname,
} from './directory-helpers.js';

export function matchSubdirectoryRequest() {
  return null;
}

export function matchSubdomainRequest() {
  return null;
}

export function buildDirectoryResponseTargets(directory, subpath = '') {
  const routeConfig = buildDirectoryRouteConfig(directory);
  const path = buildDirectoryPagePath(directory);
  return {
    path,
    canonicalUrl: routeConfig.canonicalUrl,
    subdomainUrl: routeConfig.subdomainUrl,
    subpath,
  };
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
D apps/web/src/lib/directory-routing.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Adding new file with content**
file update
A /var/home/rick/Development/mega-directory/apps/web/src/lib/directory-routing.js
import {
  buildDirectoryPagePath,
  buildDirectoryRouteConfig,
  directoryRoutingSettings,
  getDirectorySubdirectorySlug,
  normalizeSubdirectory,
  sanitizeHostname,
} from './directory-helpers.js';

const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
const NORMALIZED_BASE =
  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');

const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';

const normalizePathname = (pathname = '/') => {
  if (!pathname) {
    return '/';
  }
  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
  return withLeading.replace(/\/{2,}/g, '/');
};

const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');

const stripSubdirectoryBase = (pathname = '') => {
  const normalizedPath = normalizePathname(pathname);
  if (BASE_WITH_LEADING === '/') {
    return normalizedPath.replace(/^\/+/, '');
  }

  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
  const comparableBase = BASE_WITH_LEADING.toLowerCase();

  if (comparablePath === comparableBase) {
    return '';
  }

  if (!comparablePath.startsWith(`${comparableBase}/`)) {
    return null;
  }

  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
};

const appendSubpath = (base, subpath) => {
  if (!base) {
    return base ?? null;
  }
  if (!subpath) {
    return base;
  }
  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
  return `${trimmed}/${subpath}`;
};

const normalizeSubpath = (subpath = '') => {
  if (!subpath) {
    return '';
  }
  return normalizeSubdirectory(subpath, '');
};

const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);

export function matchSubdirectoryRequest(directories = [], pathname = '/') {
  if (!Array.isArray(directories) || directories.length === 0) {
    return null;
  }

  const rawRemainder = stripSubdirectoryBase(pathname);
  if (rawRemainder === null) {
    return null;
  }

  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
  if (!normalizedPath) {
    return null;
  }

  let candidate = null;
  for (const directory of directories) {
    const slug = getDirectorySubdirectorySlug(directory);
    if (!slug) {
      continue;
    }

    if (normalizedPath === slug) {
      return {
        directory,
        slug,
        subpath: '',
        subcategorySlug: '',
      };
    }

    if (normalizedPath.startsWith(`${slug}/`)) {
      const rest = normalizedPath.slice(slug.length + 1);
      if (!candidate || slug.length > candidate.slug.length) {
        candidate = { directory, slug, subpath: rest };
      }
    }
  }

  if (!candidate) {
    return null;
  }

  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
  return {
    directory: candidate.directory,
    slug: candidate.slug,
    subpath: candidate.subpath,
    subcategorySlug,
  };
}

export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
    return null;
  }

  const normalizedHost = sanitizeRequestHost(hostname);
  if (
    !normalizedHost ||
    normalizedHost === SUBDOMAIN_ROOT ||
    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
  ) {
    return null;
  }

  const directory = directories.find((entry) => {
    const routes = buildDirectoryRouteConfig(entry);
    return routes.subdomainHost === normalizedHost;
  });

  if (!directory) {
    return null;
  }

  let normalizedPath = normalizeSubdirectory(pathname, '');
  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
  } else if (normalizedPath === BASE_STRIPPED) {
    normalizedPath = '';
  }

  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
  return {
    directory,
    subpath: normalizedPath,
    subcategorySlug,
    host: normalizedHost,
  };
}

export function buildDirectoryResponseTargets(directory, subpath = '') {
  if (!directory) {
    return {
      path: null,
      canonicalUrl: null,
      subdomainUrl: null,
      subpath: '',
    };
  }

  const normalizedSubpath = normalizeSubpath(subpath);
  const basePath = buildDirectoryPagePath(directory);
  const routeConfig = buildDirectoryRouteConfig(directory);

  return {
    path: appendSubpath(basePath, normalizedSubpath),
    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
    subpath: normalizedSubpath,
  };
}
apply_patch(auto_approved=true) exited 0 in 7ms:
Success. Updated the following files:
A apps/web/src/lib/directory-routing.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Verifying subdomain routing logic**
exec
bash -lc 'rg -n "normalizeSubdirectory" apps/web/src/lib/directory-routing.js' in /var/home/rick/Development/mega-directory succeeded in 42ms:
6:  normalizeSubdirectory,
64:  return normalizeSubdirectory(subpath, '');
79:  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
144:  let normalizedPath = normalizeSubdirectory(pathname, '');
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Planning subcategory slug integration**

I'm organizing how to pass and normalize the subcategory slug to the DirectoryPage component, making sure the canonical URL updates correctly with that slug. There’s a lot to consider around reusing existing route helpers versus recalculating routes, and how best to cleanly append the slug for SEO payloads without breaking other dependent components. I'll likely compute active route targets upstream and pass them down to avoid duplication while keeping the base routes intact for other uses.
exec
bash -lc "rg -n \"\\.routes\" -n apps/web/src" in /var/home/rick/Development/mega-directory succeeded in 42ms:
apps/web/src/components/DirectoryPage.astro:32:const routeMeta = directory?.routes ?? {};
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});



thinking
**Refining directory routing middleware**
thinking
**Enhancing middleware to skip asset requests and enforce canonical paths**

I’m making the middleware smarter by detecting static asset requests (like CSS or JS files) to skip rewriting those, so assets load correctly on subdomains. Also, I plan to enforce canonical URLs by redirecting requests with non-normalized paths to their proper lowercase, trimmed form—this keeps URLs consistent whether the primary mode is subdomain or subdirectory. I’ll implement helpers to build redirects, rewrite paths, and integrate these checks while ensuring query parameters persist across redirects. Next, I’ll update the DirectoryPage component to pass needed props and prepare for middleware integration and testing.
file update
A /var/home/rick/Development/mega-directory/apps/web/src/middleware.js
import { defineMiddleware } from 'astro:middleware';
import { fetchDirectoryCatalog } from './data/directory-service.js';
import { directoryRoutingSettings } from './lib/directory-helpers.js';
import {
  buildDirectoryResponseTargets,
  matchSubdirectoryRequest,
  matchSubdomainRequest,
} from './lib/directory-routing.js';

const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
const NORMALIZED_BASE =
  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;

let cachedDirectories = [];
let cacheTimestamp = 0;

const looksLikeAssetPath = (pathname = '') => {
  const segment = pathname.split('/').pop() ?? '';
  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
};

const isSubdirectoryCandidate = (pathname = '') => {
  if (!pathname || NORMALIZED_BASE === '/') {
    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
  }
  const normalized = pathname.replace(/\/{2,}/g, '/');
  const lowered = normalized.toLowerCase();
  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
};

const isSubdomainCandidate = (hostname = '') => {
  if (!SUBDOMAIN_SUFFIX || !hostname) {
    return false;
  }
  const lowered = hostname.toLowerCase();
  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
};

const absoluteUrlForPath = (contextUrl, path) => {
  try {
    const base = `${contextUrl.protocol}//${contextUrl.host}`;
    const target = new URL(path, base);
    return target;
  } catch {
    return null;
  }
};

const applySearch = (targetUrl, contextUrl) => {
  if (!targetUrl) {
    return null;
  }
  targetUrl.search = contextUrl.search;
  targetUrl.hash = '';
  return targetUrl;
};

const buildRedirectResponse = (context, target) => {
  const finalTarget = applySearch(target, context.url);
  if (!finalTarget) {
    return null;
  }
  return context.redirect(finalTarget.toString(), 308);
};

const getDirectories = async () => {
  const now = Date.now();
  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
    return cachedDirectories;
  }

  try {
    const result = await fetchDirectoryCatalog();
    if (Array.isArray(result)) {
      cachedDirectories = result;
      cacheTimestamp = now;
      return cachedDirectories;
    }
  } catch {
    // Fall through to return existing cache.
  }

  cacheTimestamp = now;
  return cachedDirectories;
};

const handleSubdomainRequest = (context, match) => {
  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
  if (!targets.path) {
    return null;
  }

  if (PRIMARY_MODE === 'subdomain') {
    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
  }

  if (targets.canonicalUrl) {
    const redirectUrl = new URL(targets.canonicalUrl, context.url);
    return buildRedirectResponse(context, redirectUrl);
  }

  const fallback = absoluteUrlForPath(context.url, targets.path);
  return fallback ? context.rewrite(fallback) : null;
};

const handleSubdirectoryRequest = (context, match) => {
  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
  if (!targets.path) {
    return null;
  }

  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
    const redirectUrl = new URL(targets.subdomainUrl, context.url);
    return buildRedirectResponse(context, redirectUrl);
  }

  const normalizedPath =
    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
  if (targets.path !== normalizedPath) {
    const normalizedUrl = new URL(context.url.toString());
    normalizedUrl.pathname = targets.path;
    return buildRedirectResponse(context, normalizedUrl);
  }

  return null;
};

export const onRequest = defineMiddleware(async (context, next) => {
  const { url } = context;
  if (!url || looksLikeAssetPath(url.pathname)) {
    return next();
  }

  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);

  if (!hostIsSubdomain && !pathIsDirectory) {
    return next();
  }

  const directories = await getDirectories();
  if (!directories.length) {
    return next();
  }

  if (hostIsSubdomain) {
    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
    if (match) {
      const response = handleSubdomainRequest(context, match);
      if (response) {
        return response;
      }
    }
  }

  if (pathIsDirectory) {
    const match = matchSubdirectoryRequest(directories, url.pathname);
    if (match) {
      const response = handleSubdirectoryRequest(context, match);
      if (response) {
        return response;
      }
    }
  }

  return next();
});
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
A apps/web/src/middleware.js
file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Reviewing rewrite and redirect logic**

I'm carefully checking URL handling and rewrite logic to ensure canonical paths, search parameters, and casing are consistently managed—especially for subdomain versus subdirectory modes—and planning updates to preserve query strings on rewrites and refine directory candidate detection. I'll also update the DirectoryPage component to use these refined targets for SEO metadata.
file update
M /var/home/rick/Development/mega-directory/apps/web/src/components/DirectoryPage.astro
@@ -7,2 +7,3 @@
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
@@ -20,2 +21,3 @@
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
@@ -32,2 +34,5 @@
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
@@ -41,3 +46,3 @@
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
@@ -59,3 +64,3 @@
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M apps/web/src/components/DirectoryPage.astro
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Checking routeMeta usage across code**
exec
bash -lc 'rg -n "routeMeta" apps/web/src/components/DirectoryPage.astro' in /var/home/rick/Development/mega-directory succeeded in 42ms:
34:const routeMeta = directory?.routes ?? {};
37:  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Updating component props and routes**
file update
M /var/home/rick/Development/mega-directory/apps/web/src/pages/directories/[...path].astro
@@ -86,2 +86,3 @@
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M apps/web/src/pages/directories/[...path].astro
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..9ff21a9de24ce50af52a48f582c805b3925ecb5d
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,173 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Reviewing directory response and routing updates**
file update
M /var/home/rick/Development/mega-directory/apps/web/src/middleware.js
@@ -47,2 +47,4 @@
     const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
     return target;
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M apps/web/src/middleware.js
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Reviewing routing logic and planning tests**

I'm double-checking the subdomain and directory routing logic, confirming redirects behave correctly depending on `PRIMARY_MODE` and target URLs. I'm making sure edge cases like missing `subdomainUrl` fall back properly without breaking, the path normalization uses 308 redirects, and rewrite targets are valid URL objects. Also, I’m preparing to run targeted tests for the `apps/web` workspace after finalizing these checks.
exec
bash -lc 'npm run test --workspace apps/web' in /var/home/rick/Development/mega-directory succeeded in 813ms:

> mega-directory-astro@0.0.1 test
> node --test ./test/**/*.test.mjs

TAP version 13
# Subtest: test/directory-helpers.test.mjs
ok 1 - test/directory-helpers.test.mjs
  ---
  duration_ms: 243.984234
  type: 'test'
  ...
1..1
# tests 1
# suites 0
# pass 1
# fail 0
# cancelled 0
# skipped 0
# todo 0
# duration_ms 259.092901
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Updating plan statuses**
Plan update
  ✓ Inspect current directory routing helpers/config and design needed test coverage for subdomain vs. subdirectory flows.
  ✓ Implement routing helpers + middleware + canonical updates driven by the new tests.
  ✓ Run the relevant test suites and verify routing-related behavior.
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Checking git status for changes**
exec
bash -lc 'git status -sb' in /var/home/rick/Development/mega-directory succeeded in 95ms:
## main...origin/main [ahead 6]
 M .env.example
?? .editorconfig
?? .vscode/
?? apps/
?? codex/LOGS/codex_run_2025-11-12_06-13-21.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log
?? codex/LOGS/tasklog_24_setup_project_scaffolding_and_configuration_1762946001.log.done
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log
?? codex/LOGS/tasklog_25_define_directory_page_model_and_metadata_fields_1762949245.log.done
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log
?? codex/LOGS/tasklog_25a_initialize_astro_frontend_with_base_layouts_1762948216.log.done
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log
?? codex/LOGS/tasklog_26_initialize_geographic_location_tables_and_seed_data_1762949750.log.done
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log
?? codex/LOGS/tasklog_27_implement_directory_pages_table_and_metadata_fields_1762950694.log.done
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log
?? codex/LOGS/tasklog_28_build_admin_ui_for_directory_page_creation_and_editing_1762951273.log.done
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log
?? codex/LOGS/tasklog_29_implement_listings_table_enhancements_for_multiple_categories_and_locations_1762952190.log.done
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Preparing file reference details with line numbers**
exec
bash -lc "nl -ba apps/web/src/lib/directory-helpers.js | sed -n '1,80p'" in /var/home/rick/Development/mega-directory succeeded in 90ms:
     1	import { siteConfig } from '../config/site-config.js';
     2	
     3	const FALLBACK_SCORE = -Infinity;
     4	const DEFAULT_FEATURED_LIMIT = 3;
     5	const FALLBACK_HERO_LABEL = 'Top pick';
     6	const FALLBACK_TIER_TWO_LABEL = 'Tier-two highlight';
     7	const FEATURED_TIER_ORDER = { HERO: 0, PREMIUM: 1, STANDARD: 2 };
     8	const DEFAULT_DIRECTORY_NAME = 'Mega Directory';
     9	const DEFAULT_CATEGORY_DESCRIPTION_TEMPLATE =
    10	  'Discover curated NAME listings on Mega Directory.';
    11	const directoryRouting = siteConfig.directoryRouting ?? {};
    12	const SUBDIRECTORY_BASE = normalizeBasePath(directoryRouting.subdirectoryBase ?? '/directories');
    13	const SUBDOMAIN_ROOT = sanitizeHostname(directoryRouting.subdomainRoot ?? siteConfig.canonicalHost ?? '');
    14	const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
    15	const PRIMARY_ROUTING_MODE =
    16	  directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
    17	export const directoryRoutingSettings = {
    18	  primaryMode: PRIMARY_ROUTING_MODE,
    19	  subdirectoryBase: SUBDIRECTORY_BASE,
    20	  subdomainRoot: SUBDOMAIN_ROOT,
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Tracking line numbers for new exports**
exec
bash -lc "nl -ba apps/web/src/lib/directory-routing.js | sed -n '1,260p'" in /var/home/rick/Development/mega-directory succeeded in 41ms:
     1	import {
     2	  buildDirectoryPagePath,
     3	  buildDirectoryRouteConfig,
     4	  directoryRoutingSettings,
     5	  getDirectorySubdirectorySlug,
     6	  normalizeSubdirectory,
     7	  sanitizeHostname,
     8	} from './directory-helpers.js';
     9	
    10	const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
    11	const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
    12	const NORMALIZED_BASE =
    13	  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
    14	const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
    15	const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
    16	
    17	const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
    18	
    19	const normalizePathname = (pathname = '/') => {
    20	  if (!pathname) {
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Preparing to reference middleware lines**
exec
bash -lc "nl -ba apps/web/src/middleware.js | sed -n '1,260p'" in /var/home/rick/Development/mega-directory succeeded in 55ms:
     1	import { defineMiddleware } from 'astro:middleware';
     2	import { fetchDirectoryCatalog } from './data/directory-service.js';
     3	import { directoryRoutingSettings } from './lib/directory-helpers.js';
     4	import {
     5	  buildDirectoryResponseTargets,
     6	  matchSubdirectoryRequest,
     7	  matchSubdomainRequest,
     8	} from './lib/directory-routing.js';
     9	
    10	const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
    11	const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
    12	const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
    13	const NORMALIZED_BASE =
    14	  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
    15	const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
    16	const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
    17	const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
    18	
    19	let cachedDirectories = [];
    20	let cacheTimestamp = 0;
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Preparing to note code changes**
exec
bash -lc "nl -ba apps/web/src/components/DirectoryPage.astro | sed -n '1,120p'" in /var/home/rick/Development/mega-directory succeeded in 41ms:
     1	---
     2	import BaseLayout from '../layouts/BaseLayout.astro';
     3	import {
     4	  resolveCategorySeoMetadata,
     5	  buildDirectoryMapPins,
     6	  shouldRenderDirectoryMap,
     7	} from '../lib/directory-helpers.js';
     8	import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
     9	import DirectoryListing from './DirectoryListing.astro';
    10	import DirectoryMap from './DirectoryMap.astro';
    11	
    12	const {
    13	  directory,
    14	  navItems,
    15	  heroStats,
    16	  listings = [],
    17	  totalListings = listings.length,
    18	  subcategoryNav = [],
    19	  featuredHero = null,
    20	  featuredTierTwo = [],
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Noting line numbers for additions**
exec
bash -lc "nl -ba apps/web/src/pages/directories/[...path].astro | sed -n '1,80p'" in /var/home/rick/Development/mega-directory succeeded in 43ms:
     1	---
     2	import DirectoryPage from '../../components/DirectoryPage.astro';
     3	import { fetchDirectoryCatalog, fetchDirectoryBySlug } from '../../data/directory-service.js';
     4	import {
     5	  buildDirectoryRouteConfig,
     6	  buildDirectorySubcategories,
     7	  buildSubcategoryFilterNav,
     8	  filterListingsBySubcategory,
     9	  getDirectorySubdirectorySlug,
    10	  segmentFeaturedListings,
    11	  sortListingsByScore,
    12	} from '../../lib/directory-helpers.js';
    13	
    14	export async function getStaticPaths() {
    15	  const directories = await fetchDirectoryCatalog();
    16	  return directories.flatMap((directory) => {
    17	    const baseSlug = getDirectorySubdirectorySlug(directory);
    18	    const subcategoryEntries = buildDirectorySubcategories(directory).map((subcategory) => ({
    19	      params: { path: `${baseSlug}/${subcategory.slug}` },
    20	      props: { directorySlug: directory.slug, subcategorySlug: subcategory.slug },
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Highlighting addition of subcategorySlug prop**
exec
bash -lc "nl -ba apps/web/src/pages/directories/[...path].astro | sed -n '80,140p'" in /var/home/rick/Development/mega-directory succeeded in 40ms:
    80	  heroStats={heroStats}
    81	  featuredHero={featuredHero}
    82	  featuredTierTwo={featuredTierTwo}
    83	  listings={remainingListings}
    84	  mapListings={filteredListings}
    85	  totalListings={sortedListings.length}
    86	  subcategoryNav={subcategoryNav}
    87	  subcategorySlug={subcategorySlug}
    88	/>
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Noting test additions**
exec
bash -lc "nl -ba apps/web/test/directory-helpers.test.mjs | sed -n '300,520p'" in /var/home/rick/Development/mega-directory succeeded in 45ms:
   300	  assert.ok(nycDirectory.routes.canonicalUrl.endsWith('/directories/professional-services/new-york-city'));
   301	  assert.deepStrictEqual(nycDirectory.listings.map((listing) => listing.slug), [
   302	    'bright-sparks',
   303	    'harbor-hvac',
   304	    'metro-clean',
   305	  ]);
   306	
   307	  const jobs = groups.find((group) => group.category.slug === 'jobs');
   308	  assert.ok(jobs, 'jobs group present');
   309	  assert.strictEqual(jobs.totalListings, 1);
   310	  assert.strictEqual(jobs.locations.length, 1);
   311	  assert.strictEqual(jobs.locations[0].directories[0].path, '/directories/jobs/new-york-city');
   312	  assert.strictEqual(jobs.category.metaTitle, 'Jobs');
   313	  assert.strictEqual(
   314	    jobs.category.metaDescription,
   315	    'Recruiting partners and curated job boards.'
   316	  );
   317	});
   318	
   319	test('buildDirectorySubcategories aggregates metadata and listing counts', () => {
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Identifying new test line numbers**
exec
bash -lc 'nl -ba apps/web/test/directory-helpers.test.mjs | tail -n 80' in /var/home/rick/Development/mega-directory succeeded in 43ms:
   451	    metaTitle: '  Elite Services  ',
   452	    metaDescription: '  All the best teams  ',
   453	  });
   454	  assert.deepStrictEqual(explicit, {
   455	    metaTitle: 'Elite Services',
   456	    metaDescription: 'All the best teams',
   457	  });
   458	
   459	  const fallbackFromDescription = resolveCategorySeoMetadata({
   460	    name: 'Jobs',
   461	    description: 'Recruiting partners and curated job boards.',
   462	  });
   463	  assert.strictEqual(fallbackFromDescription.metaTitle, 'Jobs');
   464	  assert.strictEqual(
   465	    fallbackFromDescription.metaDescription,
   466	    'Recruiting partners and curated job boards.'
   467	  );
   468	
   469	  const defaultFallback = resolveCategorySeoMetadata({});
   470	  assert.strictEqual(defaultFallback.metaTitle, 'Mega Directory');
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});


thinking
**Summarizing routing changes and tests**

I'll write a friendly, clear summary that highlights the new middleware and routing helpers with file and line references, describe updates to `DirectoryPage` and `[...path].astro`, note the test suite and how to run it, then suggest logical next steps like running the dev server to confirm host rewriting and toggling settings for verification. I'll keep bullet points organized for easy reading and cover all key additions and follow-ups.
codex
**Routing Updates**
- Shared routing config + sanitizers so every layer uses the same canonical normalization, avoiding duplicated slug math (`apps/web/src/lib/directory-helpers.js:17`).
- Added `matchSubdirectoryRequest`, `matchSubdomainRequest`, and `buildDirectoryResponseTargets` utilities to centralize path/host parsing plus canonical/subdomain variant computation for directories and subcategories (`apps/web/src/lib/directory-routing.js:69`, `apps/web/src/lib/directory-routing.js:121`, `apps/web/src/lib/directory-routing.js:160`).
- Introduced an Astro middleware that caches directory metadata, rewrites subdomain hits to the correct static path when subdomains are primary, and 308-redirects to whichever URL style is configured as canonical (also normalizing stray slugs and ignoring asset requests) (`apps/web/src/middleware.js:10`–`apps/web/src/middleware.js:175`).
- Directory pages now append the active subcategory to canonical/JSON-LD URLs and receive the slug from the route so meta tags stay accurate regardless of routing mode (`apps/web/src/components/DirectoryPage.astro:35`, `apps/web/src/pages/directories/[...path].astro:33`, `apps/web/src/pages/directories/[...path].astro:87`).

**Tests**
- `npm run test --workspace apps/web` (passes).

**Next Steps**
1. Run `astro dev` and hit both `/directories/...` and `<subdomain>.<host>` URLs (toggle `directoryRouting.primary`) to confirm redirects/rewrite behavior matches your deployment expectations.
file update:
diff --git a/apps/web/src/components/DirectoryPage.astro b/apps/web/src/components/DirectoryPage.astro
index 6576513ca4ecdeac252afae20318b917f63dcf19..d8a5516fbe43389157ba173fac1035716c065737
--- a/apps/web/src/components/DirectoryPage.astro
+++ b/apps/web/src/components/DirectoryPage.astro
@@ -5,6 +5,7 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../lib/directory-helpers.js';
+import { buildDirectoryResponseTargets } from '../lib/directory-routing.js';
 import DirectoryListing from './DirectoryListing.astro';
 import DirectoryMap from './DirectoryMap.astro';
 
@@ -18,6 +19,7 @@
   featuredHero = null,
   featuredTierTwo = [],
   mapListings = directory?.listings ?? [],
+  subcategorySlug = null,
 } = Astro.props;
 
 const categorySeo = resolveCategorySeoMetadata(directory?.category ?? {});
@@ -30,6 +32,9 @@
 const pageDescription = hasExplicitCategoryDescription ? categorySeo.metaDescription : fallbackDescription;
 const pageTitle = locationName ? `${categorySeo.metaTitle} · ${locationName}` : categorySeo.metaTitle;
 const routeMeta = directory?.routes ?? {};
+const activeRouteTargets = buildDirectoryResponseTargets(directory, subcategorySlug ?? '');
+const canonicalTarget =
+  activeRouteTargets.canonicalUrl ?? activeRouteTargets.path ?? routeMeta.canonicalUrl ?? routeMeta.subdirectory;
 const ogImage =
   typeof directory?.ogImage === 'string'
     ? directory.ogImage
@@ -39,7 +44,7 @@
 const seoPayload = {
   title: pageTitle,
   description: pageDescription,
-  canonicalUrl: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+  canonicalUrl: canonicalTarget,
   image: ogImage,
   openGraph: {
     image: ogImage,
@@ -57,7 +62,7 @@
     '@type': 'CollectionPage',
     name: pageTitle,
     description: pageDescription,
-    url: routeMeta.canonicalUrl ?? routeMeta.subdirectory,
+    url: canonicalTarget,
   },
 };
 
diff --git a/apps/web/src/lib/directory-helpers.js b/apps/web/src/lib/directory-helpers.js
index ddec095e0e18ef4c3b21886b8f70ab184dbf2a20..a75c39c6a0f7db0b683af89984bb29f734e1bd7e
--- a/apps/web/src/lib/directory-helpers.js
+++ b/apps/web/src/lib/directory-helpers.js
@@ -14,6 +14,12 @@
 const ROUTING_PROTOCOL = directoryRouting.protocol ?? 'https';
 const PRIMARY_ROUTING_MODE =
   directoryRouting.primary === 'subdomain' ? 'subdomain' : 'subdirectory';
+export const directoryRoutingSettings = {
+  primaryMode: PRIMARY_ROUTING_MODE,
+  subdirectoryBase: SUBDIRECTORY_BASE,
+  subdomainRoot: SUBDOMAIN_ROOT,
+  protocol: ROUTING_PROTOCOL,
+};
 
 function ensureLeadingSlash(value) {
   if (!value) {
@@ -30,7 +36,7 @@
   return ensureLeadingSlash(trimmed.replace(/\/+$/, '')) || '/directories';
 }
 
-function sanitizeHostname(value) {
+export function sanitizeHostname(value) {
   const normalized = String(value ?? '')
     .trim()
     .toLowerCase()
@@ -51,7 +57,7 @@
   return normalized || fallback;
 };
 
-const normalizeSubdirectory = (value, fallback = 'directory') => {
+export const normalizeSubdirectory = (value, fallback = 'directory') => {
   if (!value) {
     return fallback;
   }
diff --git a/apps/web/src/lib/directory-routing.js b/apps/web/src/lib/directory-routing.js
new file mode 100644
index 0000000000000000000000000000000000000000..0c62e0c64dec9fc18df601588a23e2458ea80771
--- /dev/null
+++ b/apps/web/src/lib/directory-routing.js
@@ -0,0 +1,180 @@
+import {
+  buildDirectoryPagePath,
+  buildDirectoryRouteConfig,
+  directoryRoutingSettings,
+  getDirectorySubdirectorySlug,
+  normalizeSubdirectory,
+  sanitizeHostname,
+} from './directory-helpers.js';
+
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_WITH_LEADING = NORMALIZED_BASE.startsWith('/') ? NORMALIZED_BASE : `/${NORMALIZED_BASE}`;
+const BASE_STRIPPED = BASE_WITH_LEADING === '/' ? '' : BASE_WITH_LEADING.replace(/^\//, '');
+
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT}` : '';
+
+const normalizePathname = (pathname = '/') => {
+  if (!pathname) {
+    return '/';
+  }
+  const withLeading = pathname.startsWith('/') ? pathname : `/${pathname}`;
+  return withLeading.replace(/\/{2,}/g, '/');
+};
+
+const trimTrailingSlashes = (value) => (value === '/' ? '/' : value.replace(/\/+$/, '') || '/');
+
+const stripSubdirectoryBase = (pathname = '') => {
+  const normalizedPath = normalizePathname(pathname);
+  if (BASE_WITH_LEADING === '/') {
+    return normalizedPath.replace(/^\/+/, '');
+  }
+
+  const comparablePath = trimTrailingSlashes(normalizedPath).toLowerCase();
+  const comparableBase = BASE_WITH_LEADING.toLowerCase();
+
+  if (comparablePath === comparableBase) {
+    return '';
+  }
+
+  if (!comparablePath.startsWith(`${comparableBase}/`)) {
+    return null;
+  }
+
+  return normalizedPath.slice(BASE_WITH_LEADING.length).replace(/^\/+/, '');
+};
+
+const appendSubpath = (base, subpath) => {
+  if (!base) {
+    return base ?? null;
+  }
+  if (!subpath) {
+    return base;
+  }
+  const trimmed = base.endsWith('/') ? base.replace(/\/+$/, '') : base;
+  return `${trimmed}/${subpath}`;
+};
+
+const normalizeSubpath = (subpath = '') => {
+  if (!subpath) {
+    return '';
+  }
+  return normalizeSubdirectory(subpath, '');
+};
+
+const sanitizeRequestHost = (hostname = '') => sanitizeHostname(hostname);
+
+export function matchSubdirectoryRequest(directories = [], pathname = '/') {
+  if (!Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const rawRemainder = stripSubdirectoryBase(pathname);
+  if (rawRemainder === null) {
+    return null;
+  }
+
+  const normalizedPath = normalizeSubdirectory(rawRemainder, '');
+  if (!normalizedPath) {
+    return null;
+  }
+
+  let candidate = null;
+  for (const directory of directories) {
+    const slug = getDirectorySubdirectorySlug(directory);
+    if (!slug) {
+      continue;
+    }
+
+    if (normalizedPath === slug) {
+      return {
+        directory,
+        slug,
+        subpath: '',
+        subcategorySlug: '',
+      };
+    }
+
+    if (normalizedPath.startsWith(`${slug}/`)) {
+      const rest = normalizedPath.slice(slug.length + 1);
+      if (!candidate || slug.length > candidate.slug.length) {
+        candidate = { directory, slug, subpath: rest };
+      }
+    }
+  }
+
+  if (!candidate) {
+    return null;
+  }
+
+  const subcategorySlug = candidate.subpath.split('/')[0] ?? '';
+  return {
+    directory: candidate.directory,
+    slug: candidate.slug,
+    subpath: candidate.subpath,
+    subcategorySlug,
+  };
+}
+
+export function matchSubdomainRequest(directories = [], hostname = '', pathname = '/') {
+  if (!SUBDOMAIN_SUFFIX || !Array.isArray(directories) || directories.length === 0) {
+    return null;
+  }
+
+  const normalizedHost = sanitizeRequestHost(hostname);
+  if (
+    !normalizedHost ||
+    normalizedHost === SUBDOMAIN_ROOT ||
+    !normalizedHost.endsWith(SUBDOMAIN_SUFFIX)
+  ) {
+    return null;
+  }
+
+  const directory = directories.find((entry) => {
+    const routes = buildDirectoryRouteConfig(entry);
+    return routes.subdomainHost === normalizedHost;
+  });
+
+  if (!directory) {
+    return null;
+  }
+
+  let normalizedPath = normalizeSubdirectory(pathname, '');
+  if (BASE_STRIPPED && normalizedPath.startsWith(`${BASE_STRIPPED}/`)) {
+    normalizedPath = normalizedPath.slice(BASE_STRIPPED.length + 1);
+  } else if (normalizedPath === BASE_STRIPPED) {
+    normalizedPath = '';
+  }
+
+  const subcategorySlug = normalizedPath ? normalizedPath.split('/')[0] : '';
+  return {
+    directory,
+    subpath: normalizedPath,
+    subcategorySlug,
+    host: normalizedHost,
+  };
+}
+
+export function buildDirectoryResponseTargets(directory, subpath = '') {
+  if (!directory) {
+    return {
+      path: null,
+      canonicalUrl: null,
+      subdomainUrl: null,
+      subpath: '',
+    };
+  }
+
+  const normalizedSubpath = normalizeSubpath(subpath);
+  const basePath = buildDirectoryPagePath(directory);
+  const routeConfig = buildDirectoryRouteConfig(directory);
+
+  return {
+    path: appendSubpath(basePath, normalizedSubpath),
+    canonicalUrl: appendSubpath(routeConfig.canonicalUrl, normalizedSubpath),
+    subdomainUrl: appendSubpath(routeConfig.subdomainUrl, normalizedSubpath),
+    subpath: normalizedSubpath,
+  };
+}
diff --git a/apps/web/src/middleware.js b/apps/web/src/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..cc5e437d3eaadfa9f90a331e8c5997ae6499ed06
--- /dev/null
+++ b/apps/web/src/middleware.js
@@ -0,0 +1,175 @@
+import { defineMiddleware } from 'astro:middleware';
+import { fetchDirectoryCatalog } from './data/directory-service.js';
+import { directoryRoutingSettings } from './lib/directory-helpers.js';
+import {
+  buildDirectoryResponseTargets,
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+} from './lib/directory-routing.js';
+
+const PRIMARY_MODE = directoryRoutingSettings.primaryMode ?? 'subdirectory';
+const SUBDIRECTORY_BASE = directoryRoutingSettings.subdirectoryBase || '/directories';
+const SUBDOMAIN_ROOT = directoryRoutingSettings.subdomainRoot || '';
+const NORMALIZED_BASE =
+  !SUBDIRECTORY_BASE || SUBDIRECTORY_BASE === '/' ? '/' : SUBDIRECTORY_BASE.replace(/\/+$/, '');
+const BASE_LOWER = NORMALIZED_BASE.toLowerCase();
+const SUBDOMAIN_SUFFIX = SUBDOMAIN_ROOT ? `.${SUBDOMAIN_ROOT.toLowerCase()}` : '';
+const DIRECTORY_CACHE_TTL_MS = 5 * 60 * 1000;
+
+let cachedDirectories = [];
+let cacheTimestamp = 0;
+
+const looksLikeAssetPath = (pathname = '') => {
+  const segment = pathname.split('/').pop() ?? '';
+  return /\.[a-z0-9]{2,}($|\?)/i.test(segment);
+};
+
+const isSubdirectoryCandidate = (pathname = '') => {
+  if (!pathname || NORMALIZED_BASE === '/') {
+    return NORMALIZED_BASE === '/' ? pathname !== '/' : false;
+  }
+  const normalized = pathname.replace(/\/{2,}/g, '/');
+  const lowered = normalized.toLowerCase();
+  return lowered === BASE_LOWER || lowered.startsWith(`${BASE_LOWER}/`);
+};
+
+const isSubdomainCandidate = (hostname = '') => {
+  if (!SUBDOMAIN_SUFFIX || !hostname) {
+    return false;
+  }
+  const lowered = hostname.toLowerCase();
+  return lowered !== SUBDOMAIN_ROOT.toLowerCase() && lowered.endsWith(SUBDOMAIN_SUFFIX);
+};
+
+const absoluteUrlForPath = (contextUrl, path) => {
+  try {
+    const base = `${contextUrl.protocol}//${contextUrl.host}`;
+    const target = new URL(path, base);
+    target.search = contextUrl.search;
+    target.hash = '';
+    return target;
+  } catch {
+    return null;
+  }
+};
+
+const applySearch = (targetUrl, contextUrl) => {
+  if (!targetUrl) {
+    return null;
+  }
+  targetUrl.search = contextUrl.search;
+  targetUrl.hash = '';
+  return targetUrl;
+};
+
+const buildRedirectResponse = (context, target) => {
+  const finalTarget = applySearch(target, context.url);
+  if (!finalTarget) {
+    return null;
+  }
+  return context.redirect(finalTarget.toString(), 308);
+};
+
+const getDirectories = async () => {
+  const now = Date.now();
+  if (now - cacheTimestamp < DIRECTORY_CACHE_TTL_MS && cachedDirectories.length > 0) {
+    return cachedDirectories;
+  }
+
+  try {
+    const result = await fetchDirectoryCatalog();
+    if (Array.isArray(result)) {
+      cachedDirectories = result;
+      cacheTimestamp = now;
+      return cachedDirectories;
+    }
+  } catch {
+    // Fall through to return existing cache.
+  }
+
+  cacheTimestamp = now;
+  return cachedDirectories;
+};
+
+const handleSubdomainRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain') {
+    const rewriteTarget = absoluteUrlForPath(context.url, targets.path);
+    return rewriteTarget ? context.rewrite(rewriteTarget) : null;
+  }
+
+  if (targets.canonicalUrl) {
+    const redirectUrl = new URL(targets.canonicalUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const fallback = absoluteUrlForPath(context.url, targets.path);
+  return fallback ? context.rewrite(fallback) : null;
+};
+
+const handleSubdirectoryRequest = (context, match) => {
+  const targets = buildDirectoryResponseTargets(match.directory, match.subpath);
+  if (!targets.path) {
+    return null;
+  }
+
+  if (PRIMARY_MODE === 'subdomain' && targets.subdomainUrl) {
+    const redirectUrl = new URL(targets.subdomainUrl, context.url);
+    return buildRedirectResponse(context, redirectUrl);
+  }
+
+  const normalizedPath =
+    context.url.pathname === '/' ? '/' : context.url.pathname.replace(/\/+$/, '');
+  if (targets.path !== normalizedPath) {
+    const normalizedUrl = new URL(context.url.toString());
+    normalizedUrl.pathname = targets.path;
+    return buildRedirectResponse(context, normalizedUrl);
+  }
+
+  return null;
+};
+
+export const onRequest = defineMiddleware(async (context, next) => {
+  const { url } = context;
+  if (!url || looksLikeAssetPath(url.pathname)) {
+    return next();
+  }
+
+  const hostIsSubdomain = isSubdomainCandidate(url.hostname);
+  const pathIsDirectory = isSubdirectoryCandidate(url.pathname);
+
+  if (!hostIsSubdomain && !pathIsDirectory) {
+    return next();
+  }
+
+  const directories = await getDirectories();
+  if (!directories.length) {
+    return next();
+  }
+
+  if (hostIsSubdomain) {
+    const match = matchSubdomainRequest(directories, url.hostname, url.pathname);
+    if (match) {
+      const response = handleSubdomainRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  if (pathIsDirectory) {
+    const match = matchSubdirectoryRequest(directories, url.pathname);
+    if (match) {
+      const response = handleSubdirectoryRequest(context, match);
+      if (response) {
+        return response;
+      }
+    }
+  }
+
+  return next();
+});
diff --git a/apps/web/src/pages/directories/[...path].astro b/apps/web/src/pages/directories/[...path].astro
index 5dc2dd1d0cc78a11f51a2df5b4457a6f48e81fea..2e857982067f271cf3ef94993e711c5e11b20eb4
--- a/apps/web/src/pages/directories/[...path].astro
+++ b/apps/web/src/pages/directories/[...path].astro
@@ -84,4 +84,5 @@
   mapListings={filteredListings}
   totalListings={sortedListings.length}
   subcategoryNav={subcategoryNav}
+  subcategorySlug={subcategorySlug}
 />
diff --git a/apps/web/test/directory-helpers.test.mjs b/apps/web/test/directory-helpers.test.mjs
index ba98ff2e8c6820c27fb2a88f3dee0a256e1e8b24..da16c7abe7e229891080cbfd761b57dfdad3c25f
--- a/apps/web/test/directory-helpers.test.mjs
+++ b/apps/web/test/directory-helpers.test.mjs
@@ -19,6 +19,11 @@
   buildDirectoryMapPins,
   shouldRenderDirectoryMap,
 } from '../src/lib/directory-helpers.js';
+import {
+  matchSubdirectoryRequest,
+  matchSubdomainRequest,
+  buildDirectoryResponseTargets,
+} from '../src/lib/directory-routing.js';
 
 const sampleDirectories = [
   {
@@ -468,3 +473,58 @@
     'Discover curated Mega Directory listings on Mega Directory.'
   );
 });
+
+test('matchSubdirectoryRequest returns normalized directory + optional subcategory', () => {
+  const baseMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city',
+  );
+  assert.ok(baseMatch);
+  assert.strictEqual(baseMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(baseMatch.subpath, '');
+  assert.strictEqual(baseMatch.subcategorySlug, '');
+
+  const subcategoryMatch = matchSubdirectoryRequest(
+    sampleDirectories,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(subcategoryMatch);
+  assert.strictEqual(subcategoryMatch.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(subcategoryMatch.subpath, 'hvac');
+  assert.strictEqual(subcategoryMatch.subcategorySlug, 'hvac');
+
+  const missing = matchSubdirectoryRequest(sampleDirectories, '/directories/unknown/path');
+  assert.strictEqual(missing, null);
+});
+
+test('matchSubdomainRequest resolves directory + subcategory from host', () => {
+  const match = matchSubdomainRequest(
+    sampleDirectories,
+    'pros-nyc.megadirectory.local',
+    '/HVAC',
+  );
+  assert.ok(match);
+  assert.strictEqual(match.directory.slug, 'professional-services-new-york-city');
+  assert.strictEqual(match.subpath, 'hvac');
+  assert.strictEqual(match.subcategorySlug, 'hvac');
+
+  const missing = matchSubdomainRequest(sampleDirectories, 'unknown.megadirectory.local', '/');
+  assert.strictEqual(missing, null);
+});
+
+test('buildDirectoryResponseTargets appends subpath to all route variants', () => {
+  const directory = sampleDirectories[0];
+  const targets = buildDirectoryResponseTargets(directory, 'hvac');
+
+  assert.strictEqual(
+    targets.path,
+    '/directories/professional-services/new-york-city/hvac',
+  );
+  assert.ok(
+    targets.canonicalUrl.endsWith('/directories/professional-services/new-york-city/hvac'),
+  );
+  assert.strictEqual(
+    targets.subdomainUrl,
+    'https://pros-nyc.megadirectory.local/hvac',
+  );
+});

tokens used
141,613
**Routing Updates**
- Shared routing config + sanitizers so every layer uses the same canonical normalization, avoiding duplicated slug math (`apps/web/src/lib/directory-helpers.js:17`).
- Added `matchSubdirectoryRequest`, `matchSubdomainRequest`, and `buildDirectoryResponseTargets` utilities to centralize path/host parsing plus canonical/subdomain variant computation for directories and subcategories (`apps/web/src/lib/directory-routing.js:69`, `apps/web/src/lib/directory-routing.js:121`, `apps/web/src/lib/directory-routing.js:160`).
- Introduced an Astro middleware that caches directory metadata, rewrites subdomain hits to the correct static path when subdomains are primary, and 308-redirects to whichever URL style is configured as canonical (also normalizing stray slugs and ignoring asset requests) (`apps/web/src/middleware.js:10`–`apps/web/src/middleware.js:175`).
- Directory pages now append the active subcategory to canonical/JSON-LD URLs and receive the slug from the route so meta tags stay accurate regardless of routing mode (`apps/web/src/components/DirectoryPage.astro:35`, `apps/web/src/pages/directories/[...path].astro:33`, `apps/web/src/pages/directories/[...path].astro:87`).

**Tests**
- `npm run test --workspace apps/web` (passes).

**Next Steps**
1. Run `astro dev` and hit both `/directories/...` and `<subdomain>.<host>` URLs (toggle `directoryRouting.primary`) to confirm redirects/rewrite behavior matches your deployment expectations.
