id: 62
filename: 62_add_input_validation_layer.yaml
title: Add Input Validation Layer
description: >
  Implement comprehensive input validation using Zod to validate and type-check
  all API requests before they reach route handlers.

  Critical issue:
  - Basic validation in route handlers (manual checks)
  - No centralized validation logic
  - Inconsistent error messages
  - No type safety from validation to handler
  - Validation code duplicated across routes

  Implementation plan:

  1. Install validation dependencies
     - npm install zod
     - Zod provides TypeScript-first schema validation

  2. Create validation schemas for all DTOs
     - apps/api/src/validation/schemas/listing.ts
     - apps/api/src/validation/schemas/category.ts
     - apps/api/src/validation/schemas/directory.ts
     - apps/api/src/validation/schemas/address.ts

  3. Create validation middleware
     - apps/api/src/middleware/validateBody.ts
     - apps/api/src/middleware/validateQuery.ts
     - apps/api/src/middleware/validateParams.ts

  4. Define comprehensive schemas for all resources
     - Listing create/update
     - Category create/update
     - Directory create/update
     - Address validation
     - Query parameter validation (pagination, filters)

  5. Apply validation to all routes
     - Admin endpoints
     - Public endpoints
     - Crawler endpoints

  6. Generate TypeScript types from schemas
     - Export inferred types from Zod schemas
     - Use types in route handlers
     - Ensure type safety end-to-end

  Example schemas:

  # validation/schemas/listing.ts
  import { z } from 'zod';

  export const addressSchema = z.object({
    addressLine1: z.string().min(1, 'Address line 1 is required').max(200),
    addressLine2: z.string().max(200).optional(),
    city: z.string().min(1, 'City is required').max(100),
    region: z.string().min(2, 'Region must be at least 2 characters').max(3),
    postalCode: z.string().max(20).optional(),
    country: z.string().length(2, 'Country must be 2-letter ISO code')
  });

  export const createListingSchema = z.object({
    title: z.string().min(1, 'Title is required').max(200),
    slug: z.string()
      .regex(/^[a-z0-9-]+$/, 'Slug must be lowercase alphanumeric with hyphens')
      .min(1)
      .max(80),
    websiteUrl: z.string().url('Invalid website URL').optional(),
    contactEmail: z.string().email('Invalid email address').optional(),
    contactPhone: z.string().max(50).optional(),
    summary: z.string().max(1000).optional(),
    status: z.enum(['PENDING', 'APPROVED', 'REJECTED'], {
      errorMap: () => ({ message: 'Status must be PENDING, APPROVED, or REJECTED' })
    }),
    addresses: z.array(addressSchema)
      .min(1, 'At least one address is required')
      .max(10, 'Maximum 10 addresses allowed'),
    categoryIds: z.array(z.number().int().positive())
      .optional()
      .default([]),
    directoryId: z.number().int().positive().optional()
  });

  export const updateListingSchema = createListingSchema.partial().extend({
    id: z.number().int().positive()
  });

  export const listingQuerySchema = z.object({
    page: z.coerce.number().int().positive().default(1),
    limit: z.coerce.number().int().positive().max(100).default(20),
    status: z.enum(['PENDING', 'APPROVED', 'REJECTED']).optional(),
    categoryId: z.coerce.number().int().positive().optional(),
    directoryId: z.coerce.number().int().positive().optional(),
    search: z.string().max(200).optional()
  });

  // Export inferred types
  export type CreateListingDto = z.infer<typeof createListingSchema>;
  export type UpdateListingDto = z.infer<typeof updateListingSchema>;
  export type ListingQuery = z.infer<typeof listingQuerySchema>;

  # middleware/validateBody.ts
  import { Request, Response, NextFunction } from 'express';
  import { ZodSchema, ZodError } from 'zod';

  export function validateBody(schema: ZodSchema) {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        req.body = await schema.parseAsync(req.body);
        next();
      } catch (error) {
        if (error instanceof ZodError) {
          return res.status(400).json({
            error: 'Validation failed',
            details: error.errors.map(err => ({
              field: err.path.join('.'),
              message: err.message
            }))
          });
        }
        next(error);
      }
    };
  }

  export function validateQuery(schema: ZodSchema) {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        req.query = await schema.parseAsync(req.query);
        next();
      } catch (error) {
        if (error instanceof ZodError) {
          return res.status(400).json({
            error: 'Invalid query parameters',
            details: error.errors.map(err => ({
              field: err.path.join('.'),
              message: err.message
            }))
          });
        }
        next(error);
      }
    };
  }

  # Usage in routes:
  import { Router } from 'express';
  import { adminAuth } from '../middleware/auth';
  import { validateBody, validateQuery } from '../middleware/validation';
  import { createListingSchema, listingQuerySchema } from '../validation/schemas/listing';

  router.post('/listings',
    adminAuth,
    validateBody(createListingSchema),
    async (req, res) => {
      // req.body is now validated and typed as CreateListingDto
      const listing = await listingService.createListing(req.body);
      res.status(201).json({ data: listing });
    }
  );

  router.get('/listings',
    adminAuth,
    validateQuery(listingQuerySchema),
    async (req, res) => {
      // req.query is now validated and typed as ListingQuery
      const listings = await listingService.getListings(req.query);
      res.json({ data: listings });
    }
  );

  Additional schemas to create:
  - categorySchema (name, slug, description)
  - directorySchema (title, slug, subdomain, subdirectory, categoryId, locationId, status)
  - crawlerListingSchema (for /v1/crawler/listings endpoint)
  - paginationSchema (reusable for all list endpoints)

  Success criteria:
  - All API endpoints have schema validation
  - Validation errors return clear, structured messages
  - Types inferred from schemas used in handlers
  - No manual validation code in route handlers
  - 400 responses for invalid input
  - Validation tested with unit tests
  - Documentation updated with validation rules

dependencies: []
