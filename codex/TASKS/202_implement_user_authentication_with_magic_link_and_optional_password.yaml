id: 202
filename: 202_implement_user_authentication_with_magic_link_and_optional_password.yaml
title: Implement User Authentication with Magic Link and Optional Password
description: >
  Build complete authentication flow supporting magic link email authentication
  and optional password-based login. Users can log in via email with a temporary
  code or set a password for traditional username/password authentication.

objectives:
  - Enable magic link authentication via email (5 minute expiration)
  - Support optional password authentication (argon2id hashing)
  - Integrate with smtp2go for email delivery
  - Implement rate limiting to prevent abuse
  - Invalidate old magic codes when new ones are requested
  - Handle session lifecycle and token reuse prevention
  - Prepare schema for future 2FA configuration

database_schema:
  magic_links_table:
    fields:
      - id: integer, primary key, auto-increment
      - user_id: integer, foreign key to users(id), on delete cascade
      - code: string(12), not null, unique (12 char alphanumeric: A-Z, a-z, 0-9)
      - email: string(255), not null (email where link was sent)
      - expires_at: timestamp, not null (5 minutes from creation)
      - used_at: timestamp, nullable (null until used)
      - created_at: timestamp, not null, default now()
      - ip_address: string(45), nullable
    indexes:
      - unique: code
      - index: user_id
      - index: expires_at
      - index: email
    constraints:
      - code must be exactly 12 characters
      - expires_at must be future timestamp
      - used_at must be null or >= created_at

  future_2fa_table:
    description: Placeholder for future 2FA implementation
    fields:
      - id: integer, primary key
      - user_id: integer, foreign key to users(id)
      - method: enum('totp', 'sms', 'email'), not null
      - secret: string(255), nullable (for TOTP)
      - phone: string(20), nullable (for SMS)
      - enabled: boolean, default false
      - backup_codes: json, nullable (array of hashed backup codes)
      - created_at: timestamp
      - updated_at: timestamp

authentication_flows:
  magic_link_login:
    step_1_request_magic_link:
      endpoint: POST /v1/auth/magic-link
      request:
        email: string (valid email format)
      validation:
        - Email format is valid
        - Rate limit: max 3 requests per email per 15 minutes
        - Rate limit: max 10 requests per IP per hour
      process:
        - Find or create user by email
        - Invalidate any existing unused magic_links for this user_id
        - Generate 12 character random code (A-Z, a-z, 0-9)
        - Set expires_at to 5 minutes from now
        - Save magic_link record
        - Send email via smtp2go with magic link
        - Return success (always, even if email doesn't exist - prevent enumeration)
      response:
        success: true
        message: "If this email exists, we sent a magic link to {email}"

    step_2_verify_magic_link:
      endpoint: GET /v1/auth/magic-link/verify?code={code}
      request:
        code: string (12 characters from URL)
      validation:
        - Code is exactly 12 characters
        - Code exists in magic_links table
        - Code not already used (used_at is null)
        - Code not expired (expires_at > now)
      process:
        - Find magic_link by code
        - Verify all validations pass
        - Mark code as used (set used_at = now)
        - Get or create user by email from magic_link
        - Generate JWT session token
        - Create session record
        - Set httpOnly auth cookie
        - Redirect to return_url or /dashboard
      response:
        - 302 redirect with auth cookie set
        - On failure: redirect to /login?error=invalid_code

  password_login:
    step_1_authenticate:
      endpoint: POST /v1/auth/login
      request:
        email: string
        password: string
      validation:
        - Email format valid
        - Rate limit: max 5 failed attempts per email per 15 minutes
        - Rate limit: max 20 requests per IP per hour
      process:
        - Find user by email
        - If no user: return generic error (prevent enumeration)
        - If password_hash is null: return error "No password set, use magic link"
        - Verify password with argon2id.verify(password_hash, password)
        - If invalid: increment failed attempt counter, return error
        - If valid: generate JWT, create session, set cookie
      response:
        success: true
        token: JWT string
        user: {...user object}
      sets_cookie: auth_token (httpOnly, 7 days)

    step_2_set_password:
      endpoint: POST /v1/auth/password
      requires_auth: true
      request:
        password: string (min 8 chars)
        confirm_password: string (must match)
      validation:
        - User is authenticated
        - Password is at least 8 characters
        - Password matches confirm_password
        - Password meets complexity requirements (optional: 1 uppercase, 1 lowercase, 1 number)
      process:
        - Hash password with argon2id (time cost: 2, memory cost: 19456, parallelism: 1)
        - Update user.password_hash
        - Invalidate all other sessions for this user
        - Return success
      response:
        success: true
        message: "Password set successfully"

    step_3_change_password:
      endpoint: PUT /v1/auth/password
      requires_auth: true
      request:
        current_password: string
        new_password: string
        confirm_new_password: string
      validation:
        - User has existing password_hash
        - Current password is correct
        - New password meets requirements
        - New password matches confirmation
      process:
        - Verify current_password with argon2id
        - Hash new_password with argon2id
        - Update user.password_hash
        - Invalidate all other sessions except current
        - Return success
      response:
        success: true
        message: "Password changed successfully"

email_configuration:
  provider: smtp2go
  smtp_settings:
    host: mail.smtp2go.com
    port: 2525 (or 587, 8025, 80, 25)
    secure: true (use TLS)
    auth:
      user: ENV.SMTP2GO_USERNAME
      pass: ENV.SMTP2GO_API_KEY
  email_templates:
    magic_link:
      from: "noreply@{your-domain}"
      from_name: "{Site Name}"
      subject: "Your login link for {Site Name}"
      html_body: |
        <p>Hello,</p>
        <p>Click the link below to log in to {Site Name}:</p>
        <p><a href="{magic_link_url}">{magic_link_url}</a></p>
        <p>This link will expire in 5 minutes.</p>
        <p>If you didn't request this, you can safely ignore this email.</p>
      text_body: |
        Hello,

        Click the link below to log in to {Site Name}:
        {magic_link_url}

        This link will expire in 5 minutes.

        If you didn't request this, you can safely ignore this email.

password_hashing:
  algorithm: argon2id
  library: "@node-rs/argon2" (Node.js native binding for performance)
  parameters:
    time_cost: 2 (iterations)
    memory_cost: 19456 (19 MiB)
    parallelism: 1 (threads)
  example_usage: |
    import { hash, verify } from '@node-rs/argon2';

    // Hash password
    const passwordHash = await hash(password, {
      algorithm: argon2id,
      timeCost: 2,
      memoryCost: 19456,
      parallelism: 1,
    });

    // Verify password
    const isValid = await verify(passwordHash, password);

rate_limiting:
  magic_link_requests:
    per_email: 3 requests per 15 minutes
    per_ip: 10 requests per hour
    response_on_limit: 429 Too Many Requests
    message: "Too many requests. Please try again later."

  password_login:
    per_email: 5 failed attempts per 15 minutes
    per_ip: 20 requests per hour
    lockout_duration: 15 minutes after 5 failed attempts
    response_on_limit: 429 Too Many Requests
    message: "Too many login attempts. Please try again in 15 minutes."

  password_changes:
    per_user: 3 changes per hour
    response_on_limit: 429 Too Many Requests

security_considerations:
  magic_link_codes:
    - Generated using crypto.randomBytes() for cryptographic randomness
    - 12 characters: ~68 bits of entropy (62^12 possibilities)
    - No reuse: codes invalidated immediately after use
    - Short expiration: 5 minutes
    - Stored as plain text (not sensitive if properly randomized and short-lived)

  password_security:
    - argon2id resistant to GPU cracking attacks
    - Min 8 characters (consider 12+ for better security)
    - Optional complexity requirements
    - Passwords never logged or stored in plain text
    - Failed login attempts tracked and rate limited

  session_tokens:
    - JWT with strong secret (256-bit minimum)
    - Include jti (JWT ID) to enable revocation
    - Store jti hash in sessions table
    - Verify jti on each request to detect token reuse
    - Blacklist jti on logout

  email_enumeration_prevention:
    - Always return success for magic link requests (even if email doesn't exist)
    - Generic error messages for login failures
    - Same response time for existing/non-existing users (use constant-time comparison)

api_endpoints:
  POST /v1/auth/magic-link:
    description: Request magic link email
    rate_limit: 3/15min per email, 10/hour per IP
    request:
      email: string
    response:
      success: true
      message: "If this email exists, we sent a magic link"

  GET /v1/auth/magic-link/verify:
    description: Verify magic link code and create session
    query_params:
      code: string (12 chars)
      return_url: string (optional, where to redirect after login)
    response:
      - 302 redirect to return_url or /dashboard (on success)
      - 302 redirect to /login?error=invalid_code (on failure)
    sets_cookie: auth_token (on success)

  POST /v1/auth/login:
    description: Login with email and password
    rate_limit: 5 failed/15min per email, 20/hour per IP
    request:
      email: string
      password: string
    response:
      success: boolean
      token: string (JWT)
      user: object
    sets_cookie: auth_token

  POST /v1/auth/password:
    description: Set password for first time
    requires_auth: true
    request:
      password: string (min 8 chars)
      confirm_password: string
    response:
      success: boolean
      message: string

  PUT /v1/auth/password:
    description: Change existing password
    requires_auth: true
    request:
      current_password: string
      new_password: string
      confirm_new_password: string
    response:
      success: boolean
      message: string

  POST /v1/auth/password/reset:
    description: Request password reset (sends magic link)
    rate_limit: 3/15min per email
    request:
      email: string
    response:
      success: true
      message: "If this email exists, we sent a reset link"

frontend_implementation:
  login_page:
    path: /login
    components:
      - Email input field
      - Password input field (optional, show if user has password set)
      - "Send magic link" button
      - "Login with password" button (if password set)
      - "Forgot password?" link → sends magic link
      - "Continue as guest" link → creates anonymous account
      - Link to /register

  magic_link_verify_page:
    path: /auth/verify (handles redirect from email)
    behavior:
      - Extract code from URL query params
      - Call GET /v1/auth/magic-link/verify?code={code}
      - Show loading spinner
      - On success: redirect to dashboard or return_url
      - On error: show error message with option to request new link

  password_set_page:
    path: /settings/security
    requires_auth: true
    components:
      - Current password input (if password exists)
      - New password input
      - Confirm password input
      - Password strength indicator
      - Submit button
      - Success/error messages

  email_templates_location:
    path: apps/api/src/email/templates/
    files:
      - magic-link.html (HTML template)
      - magic-link.txt (plain text template)

cleanup_jobs:
  expired_magic_links:
    schedule: Every 5 minutes
    query: DELETE FROM magic_links WHERE expires_at < NOW()

  unused_magic_links:
    schedule: Daily at 2am
    query: DELETE FROM magic_links WHERE created_at < NOW() - INTERVAL '24 hours'

testing_requirements:
  magic_link_flow:
    - Request magic link returns success
    - Email is sent via smtp2go
    - Magic link contains valid code
    - Code can be verified within 5 minutes
    - Code cannot be reused after verification
    - Expired codes are rejected
    - Invalid codes are rejected
    - New magic link invalidates old unused codes
    - Rate limiting works (3 per email per 15min)

  password_flow:
    - Password can be set on new account
    - Password is hashed with argon2id
    - Login with correct password succeeds
    - Login with incorrect password fails
    - Failed login attempts are rate limited
    - Password can be changed with correct current password
    - Changing password invalidates other sessions
    - Rate limiting works (5 failed per 15min per email)

  security_tests:
    - Password hashes cannot be reversed
    - Magic codes have sufficient entropy
    - Session tokens contain correct claims
    - CSRF protection works
    - Email enumeration is prevented
    - Rate limits are enforced

dependencies: [201]
blockers:
  - smtp2go account credentials needed for email delivery
estimated_effort: 3-4 days
priority: high
status: pending
